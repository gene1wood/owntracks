{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OwnTracks OwnTracks is an Open Source project which provides an iOS and an Android app with which your smartphone records its current location. While there are many smartphone apps available which can do that, we think OwnTracks is special. Whether you want your young child to know where you currently are, or you want to keep track of where you spent your last vacation, or you and a group of friends want to see each other on a map, OwnTracks does that. It consists of an app which runs on your smart phone, and which periodically, publishes a small chunk of data which other OwnTracks users you authorize may see. The big deal here is which you authorize : we are extremely picky about the security features of OwnTracks . To be quite clear, you also run the backend in order to ensure that only you and the people you authorize have access to the data published by the apps. From this point onwards, it gets a bit complicated, but we'll try and ease your way into the world of OwnTracks so you may enjoy it. We think the best way to get started using OwnTracks is to follow this guide, chapter by chapter, but you certainly may fast-forward or even skip sections you're familiar with. Pressing Next on each page will guide you (pun!) through the guide. We'll now move on to explain what OwnTracks does and how it works .","title":"Intro"},{"location":"faq/","text":"Answers This is a list of question we really get asked a lot and some answers to these questions. Q: Can I have OwnTracks not publish location for a specific period of time? A: Set mode to manual (iOS) or disable automatic location reporting (Android) Q: How can I restart OwnTracks? A: Swip away and start (iOS), Force close and start (Android) Q: Can you remove Google Play Services from the Android app? A: No Q: Can you remove Google Maps from the Android app? A: No Q: Since updating to Android 6 (or higher), background location reporting does not work as before A: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. Your best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection. Q: I've moved, but OwnTracks is not reporting my location A: Depending on the mode the apps report location changes only after significant changes. Q: How do I enable region monitoring? (Waypoints) Q: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that. Q: Why are transition events delayed? Q: How can I increase reporting frequency and does that have any negative impact? A: I have a question A: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the OwnTracks meta tracker . Q: How can I report an issue? A: If you think you've found a bug, please report it on our respective android or ios issue tracker on Github.","title":"Answers"},{"location":"faq/#answers","text":"This is a list of question we really get asked a lot and some answers to these questions. Q: Can I have OwnTracks not publish location for a specific period of time? A: Set mode to manual (iOS) or disable automatic location reporting (Android) Q: How can I restart OwnTracks? A: Swip away and start (iOS), Force close and start (Android) Q: Can you remove Google Play Services from the Android app? A: No Q: Can you remove Google Maps from the Android app? A: No Q: Since updating to Android 6 (or higher), background location reporting does not work as before A: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. Your best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection. Q: I've moved, but OwnTracks is not reporting my location A: Depending on the mode the apps report location changes only after significant changes. Q: How do I enable region monitoring? (Waypoints) Q: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that. Q: Why are transition events delayed? Q: How can I increase reporting frequency and does that have any negative impact? A: I have a question A: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the OwnTracks meta tracker . Q: How can I report an issue? A: If you think you've found a bug, please report it on our respective android or ios issue tracker on Github.","title":"Answers"},{"location":"ideas/","text":"Ideas Over the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already. Allow KML, GPX export. This we do enable in the back-end. Publish charging alongside battery level. No. Add temperature to the JSON payload. No. Have the device track a route; we do this in the back-end. Feature to start a \"sequence\" which sets two custom attributes for transport mode (e.g. bicycle, walk, etc.) and/or a route name (e.g. drivehome2work_01032021) until manually turned off. If no sequence is started the attribute is just left empty. Makes querying the data much easier. Short term Mid-term Long-term Add presence. Are my friends in the area? Needs friends/family on same broker Needs 'standardized' topic names (maybe with Twitter id in topic?) Add transportation info (e.g. trains) as friends Queue updates on device (with tst etc) to be PUBlished upon available connection NFC support, suggested by mrizvic Very-long term, a.k.a. \"Neat ideas\" Publish incoming phone call (caller-id), submitted by @bordingnon . JPM: Also SMS? Have to force TLS then, at least. Requested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\" Generalized messaging app Indoors edition with iBeacons as requested in #296 Waypoints JPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload: { \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\"<current>\", \"lon\":<current>\", \"text\":\"utf-8 text\" } Remote control Maybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139) Interesting idea in #227 : device can change mode (e.g. silent , airplane mode , etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes. Add remote-control for setting waypoints via MQTT","title":"Ideas"},{"location":"ideas/#ideas","text":"Over the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already. Allow KML, GPX export. This we do enable in the back-end. Publish charging alongside battery level. No. Add temperature to the JSON payload. No. Have the device track a route; we do this in the back-end. Feature to start a \"sequence\" which sets two custom attributes for transport mode (e.g. bicycle, walk, etc.) and/or a route name (e.g. drivehome2work_01032021) until manually turned off. If no sequence is started the attribute is just left empty. Makes querying the data much easier.","title":"Ideas"},{"location":"ideas/#short-term","text":"","title":"Short term"},{"location":"ideas/#mid-term","text":"","title":"Mid-term"},{"location":"ideas/#long-term","text":"Add presence. Are my friends in the area? Needs friends/family on same broker Needs 'standardized' topic names (maybe with Twitter id in topic?) Add transportation info (e.g. trains) as friends Queue updates on device (with tst etc) to be PUBlished upon available connection NFC support, suggested by mrizvic","title":"Long-term"},{"location":"ideas/#very-long-term-aka-neat-ideas","text":"Publish incoming phone call (caller-id), submitted by @bordingnon . JPM: Also SMS? Have to force TLS then, at least. Requested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\" Generalized messaging app Indoors edition with iBeacons as requested in #296","title":"Very-long term, a.k.a. \"Neat ideas\""},{"location":"ideas/#waypoints","text":"JPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload: { \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\"<current>\", \"lon\":<current>\", \"text\":\"utf-8 text\" }","title":"Waypoints"},{"location":"ideas/#remote-control","text":"Maybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139) Interesting idea in #227 : device can change mode (e.g. silent , airplane mode , etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes. Add remote-control for setting waypoints via MQTT","title":"Remote control"},{"location":"people/","text":"People Alexander Rust created the first proof-of-concept for the Android app which started out under the very geeky name MQTTitude , a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013. Andrew Rowson then took over and now maintains the Android app. Only a few days later, Christoph Krey implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out. Jan-Piet Mens had the original crazy idea of combining location updates and MQTT and tries to keep abreast on what Christoph and Alexander do. As Ben once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles. Incidentally, Ben Jones , who works closely with us, has given us loads of invaluable feedback and he's the chap who created the mqttitude binding for the wonderful openHAB Home Automation project. Linus Groh created the OwnTracks Frontend which you'll definitely want to use! Contributors Many good people have assisted us, be it by testing, by contributing bits of code, documentation, or translations, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-) Brad Pillatsch wrote the initial implementation of PKCS#12 import for Android. brunkj for help in tracking down an address book crash. Matthew Bordignon for ideas and help with testing. Stefano Costa for bug reports. Mark Clark for bug reports. Adrian Brown originally suggested the idea for location-based services friesenkiwi contributed sundry large patches to Android and drove the LOST integration. Mikael Berthe initiated the idea for the _cp attribute (which we removed in May 2018). Peter Lindemann raised his hand for translating the iOS app into Dutch. Federico Hernandez contributed the Swedish translation of the iOS app.","title":"People"},{"location":"people/#people","text":"Alexander Rust created the first proof-of-concept for the Android app which started out under the very geeky name MQTTitude , a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013. Andrew Rowson then took over and now maintains the Android app. Only a few days later, Christoph Krey implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out. Jan-Piet Mens had the original crazy idea of combining location updates and MQTT and tries to keep abreast on what Christoph and Alexander do. As Ben once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles. Incidentally, Ben Jones , who works closely with us, has given us loads of invaluable feedback and he's the chap who created the mqttitude binding for the wonderful openHAB Home Automation project. Linus Groh created the OwnTracks Frontend which you'll definitely want to use!","title":"People"},{"location":"people/#contributors","text":"Many good people have assisted us, be it by testing, by contributing bits of code, documentation, or translations, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-) Brad Pillatsch wrote the initial implementation of PKCS#12 import for Android. brunkj for help in tracking down an address book crash. Matthew Bordignon for ideas and help with testing. Stefano Costa for bug reports. Mark Clark for bug reports. Adrian Brown originally suggested the idea for location-based services friesenkiwi contributed sundry large patches to Android and drove the LOST integration. Mikael Berthe initiated the idea for the _cp attribute (which we removed in May 2018). Peter Lindemann raised his hand for translating the iOS app into Dutch. Federico Hernandez contributed the Swedish translation of the iOS app.","title":"Contributors"},{"location":"press/","text":"Press English OwnTracks Poster @ eclipsecon Europe 2015 German Anwesenheitserkennung reloaded ownTracks & Mosquitto \u2013 Google Latitude-Clon im Eigenbau Latitude im Eigenbau \u2013 volle Kontrolle openHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung mentions OwnTracks openHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts","title":"Press"},{"location":"press/#press","text":"","title":"Press"},{"location":"press/#english","text":"OwnTracks Poster @ eclipsecon Europe 2015","title":"English"},{"location":"press/#german","text":"Anwesenheitserkennung reloaded ownTracks & Mosquitto \u2013 Google Latitude-Clon im Eigenbau Latitude im Eigenbau \u2013 volle Kontrolle openHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung mentions OwnTracks openHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts","title":"German"},{"location":"privacy/","text":"It's your data! Your data should be yours. OwnTracks does all it can to ensure that, and you decide where you store your data, how to process it, and for how long you store it (if at all). However, be advised, that if you're very concerned about privacy, you probably shouldn't be using a smartphone at all. OwnTracks uses your smartphone's location services to determine where it is. While you decide whether you want to enable or disable this feature (check your phone's documentation), there is no guarantee that the APIs used by OwnTracks won't submit your data to the vendor's servers. For example, it's quite possible that Apple or Google keep requests used for reverse geo-coding your location; there is pretty much nothing OwnTracks can do to avoid this. As one of the developers writes: We could, with great sacrifices to code complexity, battery efficiency and performance code around all native services offered by the platform in order to use third party maps and geo coders. In that case Google might not receive your geocoder requests but another third party that sells it. We could also work around the Play Services by handling all the location acquiring the old way by querying the GPS/WIFI/Cell positioning ourselves. I however doubt that these information isn't sent to Google in that case too. The thing is, if you don't want Google or Apple to collect your position you have to disable location services in which case you don't have to bother installing the app anyway. It's your choice. Privacy Policy Website Visitors Like most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website. OwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below. Gathering of Personally-Identifying Information Certain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in ways that require OwnTracks to gather personally-identifying information. The amount and type of information that OwnTracks gathers depends on the nature of the interaction. Those who engage in transactions with OwnTracks are asked to provide additional information, including as necessary the personal and financial information required to process those transactions. In each case, OwnTracks collects such information only insofar as is necessary or appropriate to fulfill the purpose of the visitor\u2019s interaction with OwnTracks. OwnTracks does not disclose personally-identifying information other than as described below. And visitors can always refuse to supply personally-identifying information, with the caveat that it may prevent them from engaging in certain website-related activities. OwnTracks collects personally-identifying information in the form of location reports made by OwnTracks' apps which use OwnTracks servers. This information may be stored in order to make it available to OwnTracks' users. Aggregated Statistics OwnTracks may collect statistics about the behavior of visitors to its websites. OwnTracks may display this information publicly or provide it to others. However, OwnTracks does not disclose personally-identifying information other than as described below. Protection of Certain Personally-Identifying Information OwnTracks discloses potentially personally-identifying and personally-identifying information only to those of its employees, contractors and affiliated organizations that (i) need to know that information in order to process it on OwnTracks\u2019s behalf or to provide services available at OwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others. Some of those employees, contractors and affiliated organizations may be located outside of your home country; by using OwnTracks\u2019s websites and servers, you consent to the transfer of such information to them. OwnTracks will not rent or sell potentially personally-identifying and personally-identifying information to anyone. Other than to its employees, contractors and affiliated organizations, as described above, OwnTracks discloses potentially personally-identifying and personally-identifying information only in response to a subpoena, court order or other governmental request, or when OwnTracks believes in good faith that disclosure is reasonably necessary to protect the property or rights of OwnTracks, third parties or the public at large. If you are a registered user of an OwnTracks website or service and have supplied your email address, OwnTracks may occasionally send you an email to tell you about new features, solicit your feedback, or just keep you up to date with what\u2019s going on with OwnTracks and our products. We primarily use our various product blogs to communicate this type of information, so we expect to keep this type of email to a minimum. If you send us a request (for example via a support email or via one of our feedback mechanisms), we reserve the right to publish it in order to help us clarify or respond to your request or to help us support other users. OwnTracks takes all measures reasonably necessary to protect against the unauthorized access, use, alteration or destruction of potentially personally-identifying and personally-identifying information. Cookies A cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies. Business Transfers If OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy. Ads Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers. Privacy Policy Changes Although most changes are likely to be minor, OwnTracks may change its Privacy Policy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks encourages visitors to frequently check this page for any changes to its Privacy Policy. Your continued use of this site after any change in this Privacy Policy will constitute your acceptance of such change. This privacy policy was adapted from Automattic's Privacy Policy .","title":"Privacy"},{"location":"privacy/#its-your-data","text":"Your data should be yours. OwnTracks does all it can to ensure that, and you decide where you store your data, how to process it, and for how long you store it (if at all). However, be advised, that if you're very concerned about privacy, you probably shouldn't be using a smartphone at all. OwnTracks uses your smartphone's location services to determine where it is. While you decide whether you want to enable or disable this feature (check your phone's documentation), there is no guarantee that the APIs used by OwnTracks won't submit your data to the vendor's servers. For example, it's quite possible that Apple or Google keep requests used for reverse geo-coding your location; there is pretty much nothing OwnTracks can do to avoid this. As one of the developers writes: We could, with great sacrifices to code complexity, battery efficiency and performance code around all native services offered by the platform in order to use third party maps and geo coders. In that case Google might not receive your geocoder requests but another third party that sells it. We could also work around the Play Services by handling all the location acquiring the old way by querying the GPS/WIFI/Cell positioning ourselves. I however doubt that these information isn't sent to Google in that case too. The thing is, if you don't want Google or Apple to collect your position you have to disable location services in which case you don't have to bother installing the app anyway. It's your choice.","title":"It's your data!"},{"location":"privacy/#privacy-policy","text":"","title":"Privacy Policy"},{"location":"privacy/#website-visitors","text":"Like most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website. OwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below.","title":"Website Visitors"},{"location":"privacy/#gathering-of-personally-identifying-information","text":"Certain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in ways that require OwnTracks to gather personally-identifying information. The amount and type of information that OwnTracks gathers depends on the nature of the interaction. Those who engage in transactions with OwnTracks are asked to provide additional information, including as necessary the personal and financial information required to process those transactions. In each case, OwnTracks collects such information only insofar as is necessary or appropriate to fulfill the purpose of the visitor\u2019s interaction with OwnTracks. OwnTracks does not disclose personally-identifying information other than as described below. And visitors can always refuse to supply personally-identifying information, with the caveat that it may prevent them from engaging in certain website-related activities. OwnTracks collects personally-identifying information in the form of location reports made by OwnTracks' apps which use OwnTracks servers. This information may be stored in order to make it available to OwnTracks' users.","title":"Gathering of Personally-Identifying Information"},{"location":"privacy/#aggregated-statistics","text":"OwnTracks may collect statistics about the behavior of visitors to its websites. OwnTracks may display this information publicly or provide it to others. However, OwnTracks does not disclose personally-identifying information other than as described below.","title":"Aggregated Statistics"},{"location":"privacy/#protection-of-certain-personally-identifying-information","text":"OwnTracks discloses potentially personally-identifying and personally-identifying information only to those of its employees, contractors and affiliated organizations that (i) need to know that information in order to process it on OwnTracks\u2019s behalf or to provide services available at OwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others. Some of those employees, contractors and affiliated organizations may be located outside of your home country; by using OwnTracks\u2019s websites and servers, you consent to the transfer of such information to them. OwnTracks will not rent or sell potentially personally-identifying and personally-identifying information to anyone. Other than to its employees, contractors and affiliated organizations, as described above, OwnTracks discloses potentially personally-identifying and personally-identifying information only in response to a subpoena, court order or other governmental request, or when OwnTracks believes in good faith that disclosure is reasonably necessary to protect the property or rights of OwnTracks, third parties or the public at large. If you are a registered user of an OwnTracks website or service and have supplied your email address, OwnTracks may occasionally send you an email to tell you about new features, solicit your feedback, or just keep you up to date with what\u2019s going on with OwnTracks and our products. We primarily use our various product blogs to communicate this type of information, so we expect to keep this type of email to a minimum. If you send us a request (for example via a support email or via one of our feedback mechanisms), we reserve the right to publish it in order to help us clarify or respond to your request or to help us support other users. OwnTracks takes all measures reasonably necessary to protect against the unauthorized access, use, alteration or destruction of potentially personally-identifying and personally-identifying information.","title":"Protection of Certain Personally-Identifying Information"},{"location":"privacy/#cookies","text":"A cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies.","title":"Cookies"},{"location":"privacy/#business-transfers","text":"If OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy.","title":"Business Transfers"},{"location":"privacy/#ads","text":"Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers.","title":"Ads"},{"location":"privacy/#privacy-policy-changes","text":"Although most changes are likely to be minor, OwnTracks may change its Privacy Policy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks encourages visitors to frequently check this page for any changes to its Privacy Policy. Your continued use of this site after any change in this Privacy Policy will constitute your acceptance of such change. This privacy policy was adapted from Automattic's Privacy Policy .","title":"Privacy Policy Changes"},{"location":"terminology/","text":"Terminology Some of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with. MQTT MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers And what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of your friends ). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same MQTT broker . There are a number of clients which do that already, and we're even going to show you how you can create your own client for specific purposes. Pub/Sub In MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so. broker A MQTT broker is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message. publish The act of sending a message to a broker. topic Each message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to. subscribe Clients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic owntracks/jane/iphone will, for example, not receive a message that is published to owntracks/john/nexus . QoS QoS or Quality of Service , specifies how the app should attempt to publish messages to an MQTT broker. QoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged. QoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times. QoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer. Retain When a message is published to a broker with the durable or retain flat set, it means that the MQTT broker will attempt to store the last published message on a particular topic. A client which subscribes to that topic will receive that last retained message once it connects to the broker. Geocoding Reverse geocoding is the act of looking up the address for a pair of coordinates. Geofence or Region A geofence or a region is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.","title":"Terminology"},{"location":"terminology/#terminology","text":"Some of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with.","title":"Terminology"},{"location":"terminology/#mqtt","text":"MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers And what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of your friends ). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same MQTT broker . There are a number of clients which do that already, and we're even going to show you how you can create your own client for specific purposes.","title":"MQTT"},{"location":"terminology/#pubsub","text":"In MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so.","title":"Pub/Sub"},{"location":"terminology/#broker","text":"A MQTT broker is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message.","title":"broker"},{"location":"terminology/#publish","text":"The act of sending a message to a broker.","title":"publish"},{"location":"terminology/#topic","text":"Each message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to.","title":"topic"},{"location":"terminology/#subscribe","text":"Clients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic owntracks/jane/iphone will, for example, not receive a message that is published to owntracks/john/nexus .","title":"subscribe"},{"location":"terminology/#qos","text":"QoS or Quality of Service , specifies how the app should attempt to publish messages to an MQTT broker. QoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged. QoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times. QoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer.","title":"QoS"},{"location":"terminology/#retain","text":"When a message is published to a broker with the durable or retain flat set, it means that the MQTT broker will attempt to store the last published message on a particular topic. A client which subscribes to that topic will receive that last retained message once it connects to the broker.","title":"Retain"},{"location":"terminology/#geocoding","text":"Reverse geocoding is the act of looking up the address for a pair of coordinates.","title":"Geocoding"},{"location":"terminology/#geofence-or-region","text":"A geofence or a region is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.","title":"Geofence or Region"},{"location":"clients/recorder/","text":"Recorder The OwnTracks Recorder is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database. Docker We have a multi-architecture Docker image which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. You pass environment variables into the container to configure it. This is documented on the docker-recorder repository. Recorder on Synology After installing Docker on your compatible Synology DiskStation, click on Image and Add the Recorder image from the URL https://hub.docker.com/r/owntracks/recorder ; you do not have to specify a username/password. Select latest when prompted to choose a tag. In list of images you should then see one called owntracks/recorder:latest as shown below. Then, click on Launch in the same window, select a container name (or leave it as owntracks-recorder1 ) and click on Advanced Settings . Under Volume , add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the /store mount path. Under Port Settings , ensure Local Port 8083 is mapped to Container Port 8083 ; you will have to replace Auto by 8083 . Under Environment , add two variables: OTR_HOST with the address or host name of your MQTT broker and OTR_PORT with its port number (typically 1883 ). If you need authentication, check the Recorder documentation for further variables you can set to configure that. Just before running the container, you should see something like this with the settings you specified: When you launch the container, it will show up in the Container tab: You should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above. Upgrades to the container running on your Synology DiskStation are easily done from the command line: $ docker stop owntracks-recorder1 $ docker pull owntracks/recorder:latest $ docker start owntracks-recorder1","title":"Docker"},{"location":"clients/recorder/#recorder","text":"The OwnTracks Recorder is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database.","title":"Recorder"},{"location":"clients/recorder/#docker","text":"We have a multi-architecture Docker image which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. You pass environment variables into the container to configure it. This is documented on the docker-recorder repository.","title":"Docker"},{"location":"clients/recorder/#recorder-on-synology","text":"After installing Docker on your compatible Synology DiskStation, click on Image and Add the Recorder image from the URL https://hub.docker.com/r/owntracks/recorder ; you do not have to specify a username/password. Select latest when prompted to choose a tag. In list of images you should then see one called owntracks/recorder:latest as shown below. Then, click on Launch in the same window, select a container name (or leave it as owntracks-recorder1 ) and click on Advanced Settings . Under Volume , add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the /store mount path. Under Port Settings , ensure Local Port 8083 is mapped to Container Port 8083 ; you will have to replace Auto by 8083 . Under Environment , add two variables: OTR_HOST with the address or host name of your MQTT broker and OTR_PORT with its port number (typically 1883 ). If you need authentication, check the Recorder documentation for further variables you can set to configure that. Just before running the container, you should see something like this with the settings you specified: When you launch the container, it will show up in the Container tab: You should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above. Upgrades to the container running on your Synology DiskStation are easily done from the command line: $ docker stop owntracks-recorder1 $ docker pull owntracks/recorder:latest $ docker start owntracks-recorder1","title":"Recorder on Synology"},{"location":"features/android/","text":"General Restrictions on Android 6 and higher. Since Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations. You may find HTTP mode more reliable on Android 6 and higher. The ongoing notification is required to run in the background. App standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings > Battery > Battery Optimization. Outgoing messages may only be sent in batched intervals. Location updates or event messages may be delayed. Incoming messages such as events might be delayed. When using MQTT, the broker connection is not guaranteed to be maintained permanently. A reconnect will be attempted regularly or when a message is sent. If the connection is established without the clean session flag, missed messages will be received once connected. Beacons are no long supported in OwnTracks for Android Vendor background restrictions Certain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits. A list of vendors known to interfer with background apps and a number of workarounds can be found at Don\u2019t kill my app! . Google Play Services Google Play Services are required to use OwnTracks that's distributed on the Google Play Store. They are used for: Battery efficient location access Scheduling of background jobs Resolving coordinates to addresses (an alterative Geocoding service can be configured) Displaying the map A separate \"flavour\" of OwnTracks called \"OSS\" aims to remove this dependency for people that can't or prefer not to use Google Play Services. This version will use other providers for maps, geocoding and location and is currently in development. The plan is to release this via the F-Droid app catalogue. Setup In the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things. By default a TLS secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device. In recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system. In HTTP mode the url is required to connect. In MQTT mode the host and username and password is required to connect. Debug Log Since Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app. To generate the logs, follow the next steps: Temporarily grant write access to local storage. Go to Android App Info > Permissions and enable the storage permission. Open the log viewer at Status > View Logs The most recent logs are displayed. To view debug log entries as well, select the Debug Logs option in the top right menu. The Share button (bottom right) allows the logs to be exported and shared, either to disk (via a suitable file manager app such as Total Commander ) or sent over email. Automation via Tasker, Automagic, etc. Since Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined modes : Move , Significant location change , Manual , Quiet . To set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action. Do not put any text into the fields listed as [LEAVE FIELD BLANK] above. Tasker example: To trigger Move mode in tasker, create a Send Intent action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Cat: None Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra(1): monitoring:2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Package: [LEAVE FIELD BLANK] Class: [LEAVE FIELD BLANK] Target: Service Mode Send This Extra Value Quiet monitoring:-1 Manual monitoring:0 Significant Changes monitoring:1 Move monitoring:2 Macrodroid example: To trigger Move mode in tasker, create a Send Intent action and enter the following information: Target: Service Action: org.owntracks.android.CHANGE_MONITORING Package: org.owntracks.android Class: [LEAVE FIELD BLANK] Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra 1 parameter name: monitoring Extra 1 value: 2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Extra(4): [LEAVE FIELD BLANK] Mode Send This Extra Value Quiet -1 Manual 0 Significant Changes 1 Move 2 Automagic example: To trigger Move mode in Automagic, create a Start Service action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Category List: [LEAVE FIELD BLANK] Data URI: [LEAVE FIELD BLANK] Data MIME Type: [LEAVE FIELD BLANK] Explicit Component: ticked Package Name: org.owntracks.android Class Name: [LEAVE FIELD BLANK] Flag List: [LEAVE FIELD BLANK] Extra: putInt(\"MONITORING\": 2) Mode Send This Extra Value Quiet putInt(\"monitoring\": -1) Manual putInt(\"monitoring\": 0) Significant Changes putInt(\"monitoring\": 1) Move putInt(\"monitoring\": 2) Other intents are, for instance: org.owntracks.android.SEND_LOCATION_USER sends a manual report (i.e. pushes a location) ADB example It's possible to send an intent to OwnTracks using the am command on the device shell. You just need to call start-service with the correct action, and optionally the extra that you need to set the specific mode. E.g. to set move mode: am start-service -a org.owntracks.android.CHANGE_MONITORING --ei monitoring 2","title":"Android"},{"location":"features/android/#general-restrictions-on-android-6-and-higher","text":"Since Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations. You may find HTTP mode more reliable on Android 6 and higher. The ongoing notification is required to run in the background. App standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings > Battery > Battery Optimization. Outgoing messages may only be sent in batched intervals. Location updates or event messages may be delayed. Incoming messages such as events might be delayed. When using MQTT, the broker connection is not guaranteed to be maintained permanently. A reconnect will be attempted regularly or when a message is sent. If the connection is established without the clean session flag, missed messages will be received once connected. Beacons are no long supported in OwnTracks for Android","title":"General Restrictions on Android 6 and higher."},{"location":"features/android/#vendor-background-restrictions","text":"Certain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits. A list of vendors known to interfer with background apps and a number of workarounds can be found at Don\u2019t kill my app! .","title":"Vendor background restrictions"},{"location":"features/android/#google-play-services","text":"Google Play Services are required to use OwnTracks that's distributed on the Google Play Store. They are used for: Battery efficient location access Scheduling of background jobs Resolving coordinates to addresses (an alterative Geocoding service can be configured) Displaying the map A separate \"flavour\" of OwnTracks called \"OSS\" aims to remove this dependency for people that can't or prefer not to use Google Play Services. This version will use other providers for maps, geocoding and location and is currently in development. The plan is to release this via the F-Droid app catalogue.","title":"Google Play Services"},{"location":"features/android/#setup","text":"In the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things. By default a TLS secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device. In recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system. In HTTP mode the url is required to connect. In MQTT mode the host and username and password is required to connect.","title":"Setup"},{"location":"features/android/#debug-log","text":"Since Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app. To generate the logs, follow the next steps: Temporarily grant write access to local storage. Go to Android App Info > Permissions and enable the storage permission. Open the log viewer at Status > View Logs The most recent logs are displayed. To view debug log entries as well, select the Debug Logs option in the top right menu. The Share button (bottom right) allows the logs to be exported and shared, either to disk (via a suitable file manager app such as Total Commander ) or sent over email.","title":"Debug Log"},{"location":"features/android/#automation-via-tasker-automagic-etc","text":"Since Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined modes : Move , Significant location change , Manual , Quiet . To set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action. Do not put any text into the fields listed as [LEAVE FIELD BLANK] above.","title":"Automation via Tasker, Automagic, etc."},{"location":"features/android/#tasker-example","text":"To trigger Move mode in tasker, create a Send Intent action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Cat: None Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra(1): monitoring:2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Package: [LEAVE FIELD BLANK] Class: [LEAVE FIELD BLANK] Target: Service Mode Send This Extra Value Quiet monitoring:-1 Manual monitoring:0 Significant Changes monitoring:1 Move monitoring:2","title":"Tasker example:"},{"location":"features/android/#macrodroid-example","text":"To trigger Move mode in tasker, create a Send Intent action and enter the following information: Target: Service Action: org.owntracks.android.CHANGE_MONITORING Package: org.owntracks.android Class: [LEAVE FIELD BLANK] Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra 1 parameter name: monitoring Extra 1 value: 2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Extra(4): [LEAVE FIELD BLANK] Mode Send This Extra Value Quiet -1 Manual 0 Significant Changes 1 Move 2","title":"Macrodroid example:"},{"location":"features/android/#automagic-example","text":"To trigger Move mode in Automagic, create a Start Service action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Category List: [LEAVE FIELD BLANK] Data URI: [LEAVE FIELD BLANK] Data MIME Type: [LEAVE FIELD BLANK] Explicit Component: ticked Package Name: org.owntracks.android Class Name: [LEAVE FIELD BLANK] Flag List: [LEAVE FIELD BLANK] Extra: putInt(\"MONITORING\": 2) Mode Send This Extra Value Quiet putInt(\"monitoring\": -1) Manual putInt(\"monitoring\": 0) Significant Changes putInt(\"monitoring\": 1) Move putInt(\"monitoring\": 2) Other intents are, for instance: org.owntracks.android.SEND_LOCATION_USER sends a manual report (i.e. pushes a location)","title":"Automagic example:"},{"location":"features/android/#adb-example","text":"It's possible to send an intent to OwnTracks using the am command on the device shell. You just need to call start-service with the correct action, and optionally the extra that you need to set the specific mode. E.g. to set move mode: am start-service -a org.owntracks.android.CHANGE_MONITORING --ei monitoring 2","title":"ADB example"},{"location":"features/beacons/","text":"iBeacons If you want to monitor an iBeacon region rather than a circular region set the radius to zero ( 0 ) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers. Set the UUID of the beacon, and you can optionally specify the major and/or minor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor. Setting major or minor number to zero ( 0 ) means no major or minor number is specified. Note that you should probably not use major or minor number 0 , because the meaning of 0 is \"any\". If the UUID is valid, iBeacon monitoring will start. Examples: Name myBeacons UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 0 Minor 0 Name mySpecificBeacon UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 1 Minor 33000 In the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas in the second example, OwnTracks would monitor just that one specific beacon with the major number 1 and the minor number 33000 . Notes The app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection. If you use a - as the first character in your Waypoint description e.g. -MyBeacon , the app will ignore short disruptions of the connection to the beacon (hold down). Setting the radius to a negative value (e.g. -1 ) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the share option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car. Example: office Upon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question. Instead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive iBeacons can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably. Beacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined major and minor numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The major number can be used, say, to identify an office building, whereas you'd configure a beacon's minor number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same major and minor numbers. Let's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the major and minor numbers. (How a beacon gets it's UUID, major , and minor set depends on the product.) We define a UUID, say, DEADBEEF-ABBA-CAFE-AFFE-123456789012 which we assign to all beacons, and configure them accordingly. (The Blukii iBeacons we use have a utility with which we can configure them accordingly.) What we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose Main@WestWing here) by a colon. A beacon's major and minor are optionally concatenated to that string, also colon-separated. Instead of painstakingly configuring this on the device proper, I prepare a small file called office.otrw (the .otrw extension is important), with the following JSON payload: { \"waypoints\" : [ { \"tst\" : 1432817332, \"lat\" : 52.0, \"_type\" : \"waypoint\", \"lon\" : 6.0, \"rad\" : 0, \"desc\" : \"Main@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001\" } ], \"_type\" : \"waypoints\" } I then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured. From this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an enter or leave event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification. We publish these events as JSON via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please. { \"_type\": \"transition\", \"acc\": 65, \"desc\": \"Main@WestWing\", \"event\": \"enter\", \"lat\": 2.2222, \"lon\": 1.1111, \"tid\": \"jp\", \"tst\": 1433342520, \"wtst\": 1432817332 } For instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc. To summarize: OwnTracks can monitor beacons by configuring it either with: a UUID only, in which case the app would report any beacon with that UUID, irrespective of its major / minor numbers. a UUID with a major number: the app would report iBeacons with the specified UUID and exactly that major number all three: the UUID , the major and minor numbers, in which case the app reports events on precisely that beacon. More examples Where exactly did I park my car?","title":"Beacons"},{"location":"features/beacons/#ibeacons","text":"If you want to monitor an iBeacon region rather than a circular region set the radius to zero ( 0 ) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers. Set the UUID of the beacon, and you can optionally specify the major and/or minor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor. Setting major or minor number to zero ( 0 ) means no major or minor number is specified. Note that you should probably not use major or minor number 0 , because the meaning of 0 is \"any\". If the UUID is valid, iBeacon monitoring will start. Examples: Name myBeacons UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 0 Minor 0 Name mySpecificBeacon UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 1 Minor 33000 In the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas in the second example, OwnTracks would monitor just that one specific beacon with the major number 1 and the minor number 33000 .","title":"iBeacons"},{"location":"features/beacons/#notes","text":"The app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection. If you use a - as the first character in your Waypoint description e.g. -MyBeacon , the app will ignore short disruptions of the connection to the beacon (hold down). Setting the radius to a negative value (e.g. -1 ) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the share option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car.","title":"Notes"},{"location":"features/beacons/#example-office","text":"Upon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question. Instead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive iBeacons can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably. Beacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined major and minor numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The major number can be used, say, to identify an office building, whereas you'd configure a beacon's minor number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same major and minor numbers. Let's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the major and minor numbers. (How a beacon gets it's UUID, major , and minor set depends on the product.) We define a UUID, say, DEADBEEF-ABBA-CAFE-AFFE-123456789012 which we assign to all beacons, and configure them accordingly. (The Blukii iBeacons we use have a utility with which we can configure them accordingly.) What we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose Main@WestWing here) by a colon. A beacon's major and minor are optionally concatenated to that string, also colon-separated. Instead of painstakingly configuring this on the device proper, I prepare a small file called office.otrw (the .otrw extension is important), with the following JSON payload: { \"waypoints\" : [ { \"tst\" : 1432817332, \"lat\" : 52.0, \"_type\" : \"waypoint\", \"lon\" : 6.0, \"rad\" : 0, \"desc\" : \"Main@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001\" } ], \"_type\" : \"waypoints\" } I then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured. From this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an enter or leave event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification. We publish these events as JSON via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please. { \"_type\": \"transition\", \"acc\": 65, \"desc\": \"Main@WestWing\", \"event\": \"enter\", \"lat\": 2.2222, \"lon\": 1.1111, \"tid\": \"jp\", \"tst\": 1433342520, \"wtst\": 1432817332 } For instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc. To summarize: OwnTracks can monitor beacons by configuring it either with: a UUID only, in which case the app would report any beacon with that UUID, irrespective of its major / minor numbers. a UUID with a major number: the app would report iBeacons with the specified UUID and exactly that major number all three: the UUID , the major and minor numbers, in which case the app reports events on precisely that beacon.","title":"Example: office"},{"location":"features/beacons/#more-examples","text":"Where exactly did I park my car?","title":"More examples"},{"location":"features/card/","text":"Card OwnTracks typically displays the TID of a friend on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name. We developed a new feature we call a card which you can use when in Private mode (MQTT) or in HTTP mode . A card is a retained message which contains a JSON payload which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device. { \"_type\": \"card\", \"name\": \"Jane Jolie\", \"face\": \"iV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg==\" } Creating a card Cards can be created with shell scripts or with a webapp. Shell Script We provide several utilities for creating a card in the Recorder's repository : If you have an image file you want to use, use image2card.sh , passing image-filename and fullname . If you know a user has a Github profile with a name and an avatar, use github2card.py which takes a Github username as argument. If you know a user has a Gravatar, use gravatar2card.sh , passing email and fullname . These utilities create a card on standard output, and you typically then publish the result as a retained message to your MQTT broker: ./github2card.py defunkt > my-card.json mosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r Note the topic branch ending in info and note the use of the retain flag ( -r ). Webapp A webapp is available to create cards in your browser and optionally publish them directly to your MQTT broker. Generating the face image We recommend formatting the face image as a 192x192 pixel image, encoded either as a JPEG or as a PNG. It is possible to use larger or smaller images, but 192x192 provides a good balance between image fidelity and data usage. Remember that this image will be transmitted many times over cellular data to all phones that use the app, so using very large images can be very costly. You should use JPEG encoding when the image depicts something complex, such as a photography of a real face. You should use PNG encoding when the image only contains simple flat colors, such as icons or drawings. We also recommend compressing the image to further save on data usage. A good app for this is Squoosh , but be warned that it uses Google trackers . For JPEG, the MozJPEG encoder with default settings is usually very good, and for PNG, the OxiPNG encoder with default settings is usually very good. Cards in Recorder in HTTP mode Using HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in <STORAGEDIR>/cards/<user>/<user>-<device>.json So, if \"jane\" is a friend with a device \"s8\" , the Recorder will load Jane's JSON card from the path <STORAGEDIR>/cards/jane/jane-s8.json. Note that as usual in Recorder, usernames and device names are lowercased. In contrib/faces/ of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the .json file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with jq . < file.json or python -mjson.tool file.json .)","title":"Card"},{"location":"features/card/#card","text":"OwnTracks typically displays the TID of a friend on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name. We developed a new feature we call a card which you can use when in Private mode (MQTT) or in HTTP mode . A card is a retained message which contains a JSON payload which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device. { \"_type\": \"card\", \"name\": \"Jane Jolie\", \"face\": \"iV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg==\" }","title":"Card"},{"location":"features/card/#creating-a-card","text":"Cards can be created with shell scripts or with a webapp.","title":"Creating a card"},{"location":"features/card/#shell-script","text":"We provide several utilities for creating a card in the Recorder's repository : If you have an image file you want to use, use image2card.sh , passing image-filename and fullname . If you know a user has a Github profile with a name and an avatar, use github2card.py which takes a Github username as argument. If you know a user has a Gravatar, use gravatar2card.sh , passing email and fullname . These utilities create a card on standard output, and you typically then publish the result as a retained message to your MQTT broker: ./github2card.py defunkt > my-card.json mosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r Note the topic branch ending in info and note the use of the retain flag ( -r ).","title":"Shell Script"},{"location":"features/card/#webapp","text":"A webapp is available to create cards in your browser and optionally publish them directly to your MQTT broker.","title":"Webapp"},{"location":"features/card/#generating-the-face-image","text":"We recommend formatting the face image as a 192x192 pixel image, encoded either as a JPEG or as a PNG. It is possible to use larger or smaller images, but 192x192 provides a good balance between image fidelity and data usage. Remember that this image will be transmitted many times over cellular data to all phones that use the app, so using very large images can be very costly. You should use JPEG encoding when the image depicts something complex, such as a photography of a real face. You should use PNG encoding when the image only contains simple flat colors, such as icons or drawings. We also recommend compressing the image to further save on data usage. A good app for this is Squoosh , but be warned that it uses Google trackers . For JPEG, the MozJPEG encoder with default settings is usually very good, and for PNG, the OxiPNG encoder with default settings is usually very good.","title":"Generating the face image"},{"location":"features/card/#cards-in-recorder-in-http-mode","text":"Using HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in <STORAGEDIR>/cards/<user>/<user>-<device>.json So, if \"jane\" is a friend with a device \"s8\" , the Recorder will load Jane's JSON card from the path <STORAGEDIR>/cards/jane/jane-s8.json. Note that as usual in Recorder, usernames and device names are lowercased. In contrib/faces/ of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the .json file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with jq . < file.json or python -mjson.tool file.json .)","title":"Cards in Recorder in HTTP mode"},{"location":"features/comparison/","text":"iOS / Android compared The OwnTracks Android and iOS apps try to be on par as far as the list of supported features is concernened. This table summarizes the current status. Feature iOS Android MQTT mode Y Y HTTP mode Y Y Location reporting Y Y TLS with system certificate Y Y Plain connections (no TLS) Y Y Username/password authentication Y Y Reconnection to broker Y Y Automatic PUB after move Y Y Automatic PUB after time Y Y Map with marker Y Y Reverse geocoding on map Y Y Accuracy of last-known loc Y Y Button for manual publish Y Y Configurable settings Y Y Move mode Y Y Friends list Y Y Geofencing Y Y Regions Y Y Location data (payload) published as JSON Y Y Remote configuration Y Y iBeacons Y Step-counting, a.k.a pedometer Y Payload encryption Y Y Android The broker connection works well with: No TLS (i.e. plain) TLS with Android system certificate authorities TLS with side-loaded user-provided self signed certificate authorities TLS with client certificates Username/password authentication to broker. Automatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is avaiable. Display of a marker at which the app believes the user to be at (lastKnownLocation) Reverse geo coding that displays the address of lastKnownLocation Accuracy of lastKnownLocation Button to manually publish lastKnownLocation iOS Runs on iPhones and iPads as an iPhone app. Not tested on iPods. Monitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \"significant location changes\" (>500m)) or as described in Move Mode below. In addition version >= 5.3 supports circular region monitoring (aka geo fences). In addition version >= 7.7 supports iBeacon region monitoring and ranging. publishes this locations via MQTT to the configured server while in foreground and background. The current location can be sent (a.k.a. published) on request.","title":"Comparison"},{"location":"features/comparison/#ios-android-compared","text":"The OwnTracks Android and iOS apps try to be on par as far as the list of supported features is concernened. This table summarizes the current status. Feature iOS Android MQTT mode Y Y HTTP mode Y Y Location reporting Y Y TLS with system certificate Y Y Plain connections (no TLS) Y Y Username/password authentication Y Y Reconnection to broker Y Y Automatic PUB after move Y Y Automatic PUB after time Y Y Map with marker Y Y Reverse geocoding on map Y Y Accuracy of last-known loc Y Y Button for manual publish Y Y Configurable settings Y Y Move mode Y Y Friends list Y Y Geofencing Y Y Regions Y Y Location data (payload) published as JSON Y Y Remote configuration Y Y iBeacons Y Step-counting, a.k.a pedometer Y Payload encryption Y Y","title":"iOS / Android compared"},{"location":"features/comparison/#android","text":"The broker connection works well with: No TLS (i.e. plain) TLS with Android system certificate authorities TLS with side-loaded user-provided self signed certificate authorities TLS with client certificates Username/password authentication to broker. Automatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is avaiable. Display of a marker at which the app believes the user to be at (lastKnownLocation) Reverse geo coding that displays the address of lastKnownLocation Accuracy of lastKnownLocation Button to manually publish lastKnownLocation","title":"Android"},{"location":"features/comparison/#ios","text":"Runs on iPhones and iPads as an iPhone app. Not tested on iPods. Monitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \"significant location changes\" (>500m)) or as described in Move Mode below. In addition version >= 5.3 supports circular region monitoring (aka geo fences). In addition version >= 7.7 supports iBeacon region monitoring and ranging. publishes this locations via MQTT to the configured server while in foreground and background. The current location can be sent (a.k.a. published) on request.","title":"iOS"},{"location":"features/debug/","text":"Debugging Designing mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest. Christoph and Alexander know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today. Be that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for. First and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory. Check whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so. Is your broker running and can it be reached by your device? We've given you tips on configuring your broker . Make liberal use of the Mosquitto clients to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.","title":"Debugging"},{"location":"features/debug/#debugging","text":"Designing mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest. Christoph and Alexander know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today. Be that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for. First and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory. Check whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so. Is your broker running and can it be reached by your device? We've given you tips on configuring your broker . Make liberal use of the Mosquitto clients to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.","title":"Debugging"},{"location":"features/encrypt/","text":"Payload encryption In addition to the transport encryption via TLS , the OwnTracks apps support payload encryption using libsodium , in particular secret-key authenticated encryption . We have also implemented support for payload encryption (i.e. decryption) in the OwnTracks Recorder . You configure a secret (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt the JSON with this secret and transport the payload in a new JSON object which looks like this: { \"_type\": \"encrypted\", \"data\": \"1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg=\" } If you want to share location with a friend, both you and your friend need to share the same secret . A secret should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different secret keys. Recorder You can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder. Add a key by determining the username and the device name of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the username is jjolie and the device name is Phone , the result will be jjolie-phone . Load the key into the (running) Recorder: echo \"jjolie-phone mysecreTpass01\" | ocat --load=keys From this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of _type: encrypted . The Recorder will decrypt the payload and will store the result in plain text in its storage. You can check which decryption keys you have stored by running: ocat --dump=keys You can also delete entries for specific devices by replacing the encryption key with DELETE : echo \"jjolie-phone DELETE\" | ocat --load=keys Be aware that this is a very powerful command that can corrupt your database if you write it incorrectly!","title":"Encryption"},{"location":"features/encrypt/#payload-encryption","text":"In addition to the transport encryption via TLS , the OwnTracks apps support payload encryption using libsodium , in particular secret-key authenticated encryption . We have also implemented support for payload encryption (i.e. decryption) in the OwnTracks Recorder . You configure a secret (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt the JSON with this secret and transport the payload in a new JSON object which looks like this: { \"_type\": \"encrypted\", \"data\": \"1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg=\" } If you want to share location with a friend, both you and your friend need to share the same secret . A secret should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different secret keys.","title":"Payload encryption"},{"location":"features/encrypt/#recorder","text":"You can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder. Add a key by determining the username and the device name of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the username is jjolie and the device name is Phone , the result will be jjolie-phone . Load the key into the (running) Recorder: echo \"jjolie-phone mysecreTpass01\" | ocat --load=keys From this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of _type: encrypted . The Recorder will decrypt the payload and will store the result in plain text in its storage. You can check which decryption keys you have stored by running: ocat --dump=keys You can also delete entries for specific devices by replacing the encryption key with DELETE : echo \"jjolie-phone DELETE\" | ocat --load=keys Be aware that this is a very powerful command that can corrupt your database if you write it incorrectly!","title":"Recorder"},{"location":"features/featured/","text":"Featured The iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type cmd : {\"action\": \"action\", \"content\": \"hello there!\", \"_type\": \"cmd\"} You can use url instead of content in the payload, in which case the tab opens with the appropriate URL loaded. {\"action\": \"action\", \"url\": \"http://example.com\", \"_type\": \"cmd\"} The tab pops up silently, i.e. without notification, and selecting the tab displays it. The open tab silently disappears if content and url are omitted. See also: Switching lights with OwnTracks, iBeacons, and openHAB","title":"Featured"},{"location":"features/featured/#featured","text":"The iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type cmd : {\"action\": \"action\", \"content\": \"hello there!\", \"_type\": \"cmd\"} You can use url instead of content in the payload, in which case the tab opens with the appropriate URL loaded. {\"action\": \"action\", \"url\": \"http://example.com\", \"_type\": \"cmd\"} The tab pops up silently, i.e. without notification, and selecting the tab displays it. The open tab silently disappears if content and url are omitted. See also: Switching lights with OwnTracks, iBeacons, and openHAB","title":"Featured"},{"location":"features/friends/","text":"Friends OwnTracks has a so-called Friends and Family capability which is enabled by default. The way this works is friends and/or family members who share a single MQTT broker can \"see\" eachother on the map, respectively on a list of friends held by the app. (This can be done either by configuring all apps to use the same broker or by what is called bridging .) Let's assume for a moment, that a user Jane (user name jjolie ) has an iPhone 4s (device name 4s ), and that she publishes location data to a topic at owntracks/jjolie/4s Let us further assume, that her friend John (user name john ) has an Android Nexus 4 (device name nex4 ) and he therefore publishes on the same broker to a topic called owntracks/john/nex4 Let us further assume that access control on the MQTT broker allows both users to subscribe to eachother's topics. Now, if both friends subscribe to a topic called owntracks/+/+ (which the apps do by default) their devices will effectively receive published location messages to either topic. So when either Jane or John publish their location, the other's device will receive it. What OwnTracks then does is to list these topic names (e.g. owntracks/jjolie/4s ) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh? Faces It gets better. You probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that. Depending on the device you're using, the procedure differs slightly. Android The app subscribes to a topic branch owntracks/+/+ on the broker per default to receive locations of other people connected to the same MQTT broker that publish to the default topic of owntracks/$username/$devicename . It then reads CARD s to find friends' names and faces. iOS The app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is owntracks/+/+ . Select the Friends button to see a list of friends: Tapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location. Who is that? (iOS only) It's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book: Select an entry then click on the bookmark icon on top right. The Address book opens. Select the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\"). When you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map. Voila!","title":"Friends"},{"location":"features/friends/#friends","text":"OwnTracks has a so-called Friends and Family capability which is enabled by default. The way this works is friends and/or family members who share a single MQTT broker can \"see\" eachother on the map, respectively on a list of friends held by the app. (This can be done either by configuring all apps to use the same broker or by what is called bridging .) Let's assume for a moment, that a user Jane (user name jjolie ) has an iPhone 4s (device name 4s ), and that she publishes location data to a topic at owntracks/jjolie/4s Let us further assume, that her friend John (user name john ) has an Android Nexus 4 (device name nex4 ) and he therefore publishes on the same broker to a topic called owntracks/john/nex4 Let us further assume that access control on the MQTT broker allows both users to subscribe to eachother's topics. Now, if both friends subscribe to a topic called owntracks/+/+ (which the apps do by default) their devices will effectively receive published location messages to either topic. So when either Jane or John publish their location, the other's device will receive it. What OwnTracks then does is to list these topic names (e.g. owntracks/jjolie/4s ) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh?","title":"Friends"},{"location":"features/friends/#faces","text":"It gets better. You probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that. Depending on the device you're using, the procedure differs slightly.","title":"Faces"},{"location":"features/friends/#android","text":"The app subscribes to a topic branch owntracks/+/+ on the broker per default to receive locations of other people connected to the same MQTT broker that publish to the default topic of owntracks/$username/$devicename . It then reads CARD s to find friends' names and faces.","title":"Android"},{"location":"features/friends/#ios","text":"The app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is owntracks/+/+ . Select the Friends button to see a list of friends: Tapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location.","title":"iOS"},{"location":"features/friends/#who-is-that","text":"(iOS only) It's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book: Select an entry then click on the bookmark icon on top right. The Address book opens. Select the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\"). When you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map. Voila!","title":"Who is that?"},{"location":"features/ios/","text":"Startup After downloading and installing the iPhone/iPad app , start it up. The first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location. Settings Access settings and the individual modes by pressing on the I on the top left. Friends The Friends feature shows self and all Friends published by the server, their picture or OwnTracks default icon, and their last location. Tapping on the entry switches back to map centered on friend's last location. The first time you launch the app you'll also be asked whether it may access your contacts data, which you should allow. (If you change your mind later, Privacy in General settings allows you to disable the feature.) Tapping on an location entry centers the map on the selected location. No geo-coding is done automatically in the background to limit mobile data usage. Location indicators and friendly faces The locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic. A red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds as good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h. A small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement) with the 12 o'clock position meaning North. If your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the Friends list, as soon as a location update for Jane is seen by the app. Region Monitoring and Waypoints For all manually published locations, a description, a region radius and a share flag can be edited. Setting the description of a location helps you to remember places. If a description is entered and the share flag set, the location is published to the MQTT broker as a waypoint once. If the description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the coordinate. A region may be 'waypoint'. The regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. If the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' monitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant. Everytime the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker. Use cases: * Define a home region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. * Share your favorite places with your friends (\"Best Sushi in Town\"). * Keep a private note (\"Parked Car here\"). * Use iBeacons to accurately report enter/leave events for your home * Use iBeacons to publish enter/leave events for individual rooms/floors in your home See also Waypoints . Region monitoring (a.k.a. Geo Fences) If the waypoint description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the specified coordinates. Regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. Every time the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker, specifying whether the device is entering or leaving said region. For example, you can define a home region to ensure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep a private note (\"Parked Car here\"). Region Monitoring with iBeacons Rather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers to the description to start region monitoring using iBeacons. e.g. * 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE' reports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' reports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity Region Monitoring with +follow Create a region with a name begining with a + character, e.g. +follow and set an initial radius to be greater than zero. From this moment onwards, lat and lon will be set dynamically at each location publish and radius will be the distance you've covered in 30 seconds, at least 50 meters. Available in version > 15.x.x: If the name of such a region starts with a number (e.g. +60follow ), the dynamically set new radius will be the distance you've covered in number seconds (minimum 50 meters). This follow -type region will not trigger enter/leave events or notifications, and location publishes will have a type setting of \"t\" : \"C\" . Region Monitoring with automatic monitoring mode change Available in version > 16.x.x Create a region with a name ending with '|<monitoring mode on enter>|<monitoring mode on exit> . E.g. Home|1|2 will switch to monitoring mode 2 (Move Mode) when exiting the region Home and will switch back to monitoring mode 1 (Significant Mode) when entering the region Home . Please note automatic change to monitoring mode -1 (Quiet Mode) will stop all further region detection. As the automatic change to monitoring mode 2 (Move Mode) does not work reliably under all circumstances, we recommend to add a +follow region, which will trigger a wake up of the app when moving. Region Monitoring with automatic battery level controlled monitoring mode change Available in version > 16.x.x A new Settings parameter \"downgrade\" indicates the percentage of battery level which is the threshold. If the phone is in Move Mode and the battery level drops below \"downgrade\" percent, the app will automatically switch from Move Mode to Significant Mode. If the phone did that automatic switch and detects the charges is connected, it will automatically switch back to Move Mode. This will happen when then next location update in Significant mode is processed. The fact the app is in \"downgraded\" mode is indicated in the UI by a trailing ! to the Significant mode (e.g. Significant! ). Remote configuration You can help your friends customize their copy of OwnTracks with remote configuration . Why do location publishes sometimes seem to cease to work? Here's what happens: If the app goes into Background, the connection is disconnected because the app cannot maintain the TCP connection in background. If you bring the app back into foreground, the app will re-connect. When a location change is recorded (no matter if manual, significant, move or region mode), a message is prepared and an attempt to connect to the broker is started. If there is an error, connect will be retried after 2, 4, 8, ..., 64, 64, .... seconds until it succeeds. BUT... If the application is in background or is sent to the background, retries are restarted eventually - depending on iOS' background execution model about every 10 minutes. With automatic modes switched off, even when bringing the app to foreground, no new location updates are generated.","title":"iOS"},{"location":"features/ios/#startup","text":"After downloading and installing the iPhone/iPad app , start it up. The first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location.","title":"Startup"},{"location":"features/ios/#settings","text":"Access settings and the individual modes by pressing on the I on the top left.","title":"Settings"},{"location":"features/ios/#friends","text":"The Friends feature shows self and all Friends published by the server, their picture or OwnTracks default icon, and their last location. Tapping on the entry switches back to map centered on friend's last location. The first time you launch the app you'll also be asked whether it may access your contacts data, which you should allow. (If you change your mind later, Privacy in General settings allows you to disable the feature.) Tapping on an location entry centers the map on the selected location. No geo-coding is done automatically in the background to limit mobile data usage.","title":"Friends"},{"location":"features/ios/#location-indicators-and-friendly-faces","text":"The locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic. A red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds as good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h. A small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement) with the 12 o'clock position meaning North. If your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the Friends list, as soon as a location update for Jane is seen by the app.","title":"Location indicators and friendly faces"},{"location":"features/ios/#region-monitoring-and-waypoints","text":"For all manually published locations, a description, a region radius and a share flag can be edited. Setting the description of a location helps you to remember places. If a description is entered and the share flag set, the location is published to the MQTT broker as a waypoint once. If the description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the coordinate. A region may be 'waypoint'. The regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. If the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' monitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant. Everytime the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker. Use cases: * Define a home region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. * Share your favorite places with your friends (\"Best Sushi in Town\"). * Keep a private note (\"Parked Car here\"). * Use iBeacons to accurately report enter/leave events for your home * Use iBeacons to publish enter/leave events for individual rooms/floors in your home See also Waypoints .","title":"Region Monitoring and Waypoints"},{"location":"features/ios/#region-monitoring-aka-geo-fences","text":"If the waypoint description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the specified coordinates. Regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. Every time the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker, specifying whether the device is entering or leaving said region. For example, you can define a home region to ensure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep a private note (\"Parked Car here\").","title":"Region monitoring (a.k.a. Geo Fences)"},{"location":"features/ios/#region-monitoring-with-ibeacons","text":"Rather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers to the description to start region monitoring using iBeacons. e.g. * 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE' reports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' reports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity","title":"Region Monitoring with iBeacons"},{"location":"features/ios/#region-monitoring-with-follow","text":"Create a region with a name begining with a + character, e.g. +follow and set an initial radius to be greater than zero. From this moment onwards, lat and lon will be set dynamically at each location publish and radius will be the distance you've covered in 30 seconds, at least 50 meters. Available in version > 15.x.x: If the name of such a region starts with a number (e.g. +60follow ), the dynamically set new radius will be the distance you've covered in number seconds (minimum 50 meters). This follow -type region will not trigger enter/leave events or notifications, and location publishes will have a type setting of \"t\" : \"C\" .","title":"Region Monitoring with +follow"},{"location":"features/ios/#region-monitoring-with-automatic-monitoring-mode-change","text":"Available in version > 16.x.x Create a region with a name ending with '|<monitoring mode on enter>|<monitoring mode on exit> . E.g. Home|1|2 will switch to monitoring mode 2 (Move Mode) when exiting the region Home and will switch back to monitoring mode 1 (Significant Mode) when entering the region Home . Please note automatic change to monitoring mode -1 (Quiet Mode) will stop all further region detection. As the automatic change to monitoring mode 2 (Move Mode) does not work reliably under all circumstances, we recommend to add a +follow region, which will trigger a wake up of the app when moving.","title":"Region Monitoring with automatic monitoring mode change"},{"location":"features/ios/#region-monitoring-with-automatic-battery-level-controlled-monitoring-mode-change","text":"Available in version > 16.x.x A new Settings parameter \"downgrade\" indicates the percentage of battery level which is the threshold. If the phone is in Move Mode and the battery level drops below \"downgrade\" percent, the app will automatically switch from Move Mode to Significant Mode. If the phone did that automatic switch and detects the charges is connected, it will automatically switch back to Move Mode. This will happen when then next location update in Significant mode is processed. The fact the app is in \"downgraded\" mode is indicated in the UI by a trailing ! to the Significant mode (e.g. Significant! ).","title":"Region Monitoring with automatic battery level controlled monitoring mode change"},{"location":"features/ios/#remote-configuration","text":"You can help your friends customize their copy of OwnTracks with remote configuration .","title":"Remote configuration"},{"location":"features/ios/#why-do-location-publishes-sometimes-seem-to-cease-to-work","text":"Here's what happens: If the app goes into Background, the connection is disconnected because the app cannot maintain the TCP connection in background. If you bring the app back into foreground, the app will re-connect. When a location change is recorded (no matter if manual, significant, move or region mode), a message is prepared and an attempt to connect to the broker is started. If there is an error, connect will be retried after 2, 4, 8, ..., 64, 64, .... seconds until it succeeds. BUT... If the application is in background or is sent to the background, retries are restarted eventually - depending on iOS' background execution model about every 10 minutes. With automatic modes switched off, even when bringing the app to foreground, no new location updates are generated.","title":"Why do location publishes sometimes seem to cease to work?"},{"location":"features/location/","text":"Location data Location data is obtained by your smartphone and published to the MQTT broker as follows: The Android and iOS apps offer 4 modes of location publication as well as region monitoring: Quiet mode: Only manual location reports. Icon [] Manual mode: Manual location reports and automated reports with region monitoring. Icon || Significant location change mode: Standard tracking mode with automated location reports. Icon |> Move mode: Frequent location ||> All four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons. iOS Move mode In move mode, the app monitors location permanently and publishes a new location as soon as the device moves locatorDisplacement meters or after locatorInterval seconds, whatever happens first. locatorDisplacement and locatorInterval can be adjusted by the user in the systems settings for OwnTracks. The defaults are 100m and 300 seconds (5 minutes). The payoff is higher battery usage as high as in navigation or tracker app. So it is recommend to use move mode while charging or during moves only - hence the name. Please note, move mode is active when the app is active (a.k.a in foreground). Significant location change mode iOS defines a Significant location change as traveling a distance of at least 500 meters in 5 minutes. This mode allows the app to run in background and minimize the power consumption. This standard tracking mode reports significant location changes only (>500m and at most once every 5 minutes). This is defined by Apple and is optimal with respect to battery usage. Examples: if you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a ping -type message once in a while.) if you move at least 500 meters, a new location will be published after 5 minutes if you move 10 kilometers in 5 minutes, only one location will be published Manual mode The app doesn't monitor location changes in manual mode while in background. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence or Beacon regions are still published automatically whilst in Manual mode. Quiet mode Same as Manual mode except that no region events are published. Region monitoring The app user may mark a previously manually published or manually created location as a monitored circular region by specifying a monitoring radius in meters. (See Regions .) The app will publish the location additionally every time the device leaves or enters one of the regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently thereof. It is switched on when a region is setup with description and radius. To switch region monitoring off, all regions have to be unmarked (by setting their radius to 0). Regions are shown on the map display in transparent blue or red circles. Red indicates the device is is within the region. Tags and POI On iOS, a user can set a point of interest (POI) during manual publish of a location or set a tag while for future location publishes. When tapping on \"publish location\" an action picker appears on which the user can choose to: Send location now. The current location is published, possibly enhanced with a previously set tag . Set POI. A user is asked to describe the POI (e.g. delicious seafood ) and the location is then transmitted with the poi added to the JSON payload. Set tag. Users can enter a tag (e.g. Spain 2023 ) which is added to the JSON of all subsequent location publishes, irrespective of the mode (i.e. this also works in significant changes mode, say), until the tag is removed. iBeacon monitoring The app user may mark a previously manually published or manually created location as a monitored beacon region by appending a beacon UUID to the region's name. The app will publish the location additionally every time the device leaves or enters one of the beacon regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently. It is switched on when a region's name has a valid UUID appended to it. If the device is within a monitored beacon region, the the beacon indicator is shown in red, otherwise blue meaning device is not in any iBeacon region. There are 2 kinds of locations: an automatic location created when iOS detects a change of location a manual location created by the user A manual location with a non-zero length remark (description) is a waypoint . A waypoint 's attributes are published when the waypoint is created or changed. If a waypoint specifies a radius, a circular region is monitored for enter/leave events . If a waypoint is not a circular region and the waypoint's description contains a valid iBeacon specification, a beacon region is monitored for enter/leave events. If an enter/leave event occurs an event message is published with the type attribute set to c or b for ( circular region_or _beacon region ). The message contains an event attribute specifying either enter or leave . The description of the waypoint is added to the published event message. Automatic Description iBeacon Radius Event Message /w Description Waypoint Message Y n/a n/a n/a N N N N N n/a n/a N N N N Y N N N N Y N Y N Y c N N N Y N Y c Y Y N Y Y N b N N N Y Y N b Y Y N Y Y Y c N N N Y Y Y c Y Y Android Move mode In move mode, the app monitors device location permanently. It requests a location fix every 10s (by default, configurable in the settings through moveModeLocatorInterval ) in high power mode and publishes a new location as soon as it arrives. This mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage. It is recommend to use move mode while charging or during periods that require highly accurate tracking while moving quickly. The locatorDisplacement option is ignored in this mode. Significant location change mode This standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives. This mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users. In addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw location request that is send to the Android location API. locatorInterval : The desired interval for active location updates. \"The location client will actively try to obtain location updates for your application at this interval, so it has a direct influence on the amount of power used by your application. Choose your interval wisely.\" moveModeLocatorInterval : The requested location interval in move mode. locatorDisplacement : The smallest displacement in meters the user must move between location updates. Defaults to 0 and is an and relationship with interval. Can be used to only receive updates when the device has moved. This means if the user has not moved by more than the displacement value, the location will not be reported at locatorInterval . Manual mode In manual mode, the app monitors device location with a low power location request. It uses the same interval configured for significant mode to receive low accuracy updates to use minimal battery power. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in Manual mode. Remote reportLocation commands are ignored. Quiet mode Same as Manual mode except that no region events are published.","title":"Location"},{"location":"features/location/#location-data","text":"Location data is obtained by your smartphone and published to the MQTT broker as follows: The Android and iOS apps offer 4 modes of location publication as well as region monitoring: Quiet mode: Only manual location reports. Icon [] Manual mode: Manual location reports and automated reports with region monitoring. Icon || Significant location change mode: Standard tracking mode with automated location reports. Icon |> Move mode: Frequent location ||> All four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons.","title":"Location data"},{"location":"features/location/#ios","text":"","title":"iOS"},{"location":"features/location/#move-mode","text":"In move mode, the app monitors location permanently and publishes a new location as soon as the device moves locatorDisplacement meters or after locatorInterval seconds, whatever happens first. locatorDisplacement and locatorInterval can be adjusted by the user in the systems settings for OwnTracks. The defaults are 100m and 300 seconds (5 minutes). The payoff is higher battery usage as high as in navigation or tracker app. So it is recommend to use move mode while charging or during moves only - hence the name. Please note, move mode is active when the app is active (a.k.a in foreground).","title":"Move mode"},{"location":"features/location/#significant-location-change-mode","text":"iOS defines a Significant location change as traveling a distance of at least 500 meters in 5 minutes. This mode allows the app to run in background and minimize the power consumption. This standard tracking mode reports significant location changes only (>500m and at most once every 5 minutes). This is defined by Apple and is optimal with respect to battery usage. Examples: if you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a ping -type message once in a while.) if you move at least 500 meters, a new location will be published after 5 minutes if you move 10 kilometers in 5 minutes, only one location will be published","title":"Significant location change mode"},{"location":"features/location/#manual-mode","text":"The app doesn't monitor location changes in manual mode while in background. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence or Beacon regions are still published automatically whilst in Manual mode.","title":"Manual mode"},{"location":"features/location/#quiet-mode","text":"Same as Manual mode except that no region events are published.","title":"Quiet mode"},{"location":"features/location/#region-monitoring","text":"The app user may mark a previously manually published or manually created location as a monitored circular region by specifying a monitoring radius in meters. (See Regions .) The app will publish the location additionally every time the device leaves or enters one of the regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently thereof. It is switched on when a region is setup with description and radius. To switch region monitoring off, all regions have to be unmarked (by setting their radius to 0). Regions are shown on the map display in transparent blue or red circles. Red indicates the device is is within the region.","title":"Region monitoring"},{"location":"features/location/#tags-and-poi","text":"On iOS, a user can set a point of interest (POI) during manual publish of a location or set a tag while for future location publishes. When tapping on \"publish location\" an action picker appears on which the user can choose to: Send location now. The current location is published, possibly enhanced with a previously set tag . Set POI. A user is asked to describe the POI (e.g. delicious seafood ) and the location is then transmitted with the poi added to the JSON payload. Set tag. Users can enter a tag (e.g. Spain 2023 ) which is added to the JSON of all subsequent location publishes, irrespective of the mode (i.e. this also works in significant changes mode, say), until the tag is removed.","title":"Tags and POI"},{"location":"features/location/#ibeacon-monitoring","text":"The app user may mark a previously manually published or manually created location as a monitored beacon region by appending a beacon UUID to the region's name. The app will publish the location additionally every time the device leaves or enters one of the beacon regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently. It is switched on when a region's name has a valid UUID appended to it. If the device is within a monitored beacon region, the the beacon indicator is shown in red, otherwise blue meaning device is not in any iBeacon region. There are 2 kinds of locations: an automatic location created when iOS detects a change of location a manual location created by the user A manual location with a non-zero length remark (description) is a waypoint . A waypoint 's attributes are published when the waypoint is created or changed. If a waypoint specifies a radius, a circular region is monitored for enter/leave events . If a waypoint is not a circular region and the waypoint's description contains a valid iBeacon specification, a beacon region is monitored for enter/leave events. If an enter/leave event occurs an event message is published with the type attribute set to c or b for ( circular region_or _beacon region ). The message contains an event attribute specifying either enter or leave . The description of the waypoint is added to the published event message. Automatic Description iBeacon Radius Event Message /w Description Waypoint Message Y n/a n/a n/a N N N N N n/a n/a N N N N Y N N N N Y N Y N Y c N N N Y N Y c Y Y N Y Y N b N N N Y Y N b Y Y N Y Y Y c N N N Y Y Y c Y Y","title":"iBeacon monitoring"},{"location":"features/location/#android","text":"","title":"Android"},{"location":"features/location/#move-mode_1","text":"In move mode, the app monitors device location permanently. It requests a location fix every 10s (by default, configurable in the settings through moveModeLocatorInterval ) in high power mode and publishes a new location as soon as it arrives. This mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage. It is recommend to use move mode while charging or during periods that require highly accurate tracking while moving quickly. The locatorDisplacement option is ignored in this mode.","title":"Move mode"},{"location":"features/location/#significant-location-change-mode_1","text":"This standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives. This mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users. In addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw location request that is send to the Android location API. locatorInterval : The desired interval for active location updates. \"The location client will actively try to obtain location updates for your application at this interval, so it has a direct influence on the amount of power used by your application. Choose your interval wisely.\" moveModeLocatorInterval : The requested location interval in move mode. locatorDisplacement : The smallest displacement in meters the user must move between location updates. Defaults to 0 and is an and relationship with interval. Can be used to only receive updates when the device has moved. This means if the user has not moved by more than the displacement value, the location will not be reported at locatorInterval .","title":"Significant location change mode"},{"location":"features/location/#manual-mode_1","text":"In manual mode, the app monitors device location with a low power location request. It uses the same interval configured for significant mode to receive low accuracy updates to use minimal battery power. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in Manual mode. Remote reportLocation commands are ignored.","title":"Manual mode"},{"location":"features/location/#quiet-mode_1","text":"Same as Manual mode except that no region events are published.","title":"Quiet mode"},{"location":"features/pedometer/","text":"Pedometer The iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only). The way this works is that the iPhone counts the steps you take, and OwnTracks can report these in a JSON payload upon request. Command In order for the app to actually report the steps counted by the device, you send it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.) mosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{\"_type\" : \"cmd\", \"action\": \"reportSteps\"}' Note how we\u2019re using QoS=2 here: the message is published to the MQTT broker, and when the phone next wakes up, which happens every few hundred seconds, it will obtain the message, and publish a JSON payload with the counted steps back to your MQTT broker. { \"_type\": \"steps\", \"from\": 1400455130, \"steps\": 1234, \"to\": 1400458000, \"tst\": 1400455130 } Daily reports We use the following small program to issue the JSON needed to request the steps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.) #!/usr/bin/env python import datetime import time import json import sys days = 0 def unix_epoch(t, delta): dt = t + delta # print dt return int(time.mktime(dt.timetuple())) now = datetime.datetime.today() f = now.replace(now.year, now.month, now.day, 0, 0, 1, 0) t = now.replace(now.year, now.month, now.day, 23, 59, 59, 0) delta = datetime.timedelta(days=days) payload = { '_type' : 'cmd', 'action' : 'reportSteps', 'from' : unix_epoch(f, delta), 'to' : unix_epoch(t, delta), } print json.dumps(payload) In the evening, a cron entry sends that off to our broker which will, eventually, deliver the message to the the phone. 50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l Daily reports with Openhab With openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab. At first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg mqtt-retain.url=tcp://192.168.1.1:1884 mqtt-retain.qos=2 After that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents: rule \"MQTT_OWNTRACKS_STEPS\" when // every day at 23:59 Time cron \"0 59 23 * * ? *\" then val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000 val long to1 = (now.millis / 1000) publish(\"mqtt-retain\",\"owntracks/jj/5s/cmd\",'{\"action\": \"reportSteps\", \"to\": '+ to1 +', \"_type\": \"cmd\", \"from\": '+ from1 +'}') end For usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items Number Steps_Yesterday \"[%d]\" { mqtt=\"<[mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]\" } Now You can make use of yesterday's steps count.","title":"Pedometer"},{"location":"features/pedometer/#pedometer","text":"The iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only). The way this works is that the iPhone counts the steps you take, and OwnTracks can report these in a JSON payload upon request.","title":"Pedometer"},{"location":"features/pedometer/#command","text":"In order for the app to actually report the steps counted by the device, you send it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.) mosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{\"_type\" : \"cmd\", \"action\": \"reportSteps\"}' Note how we\u2019re using QoS=2 here: the message is published to the MQTT broker, and when the phone next wakes up, which happens every few hundred seconds, it will obtain the message, and publish a JSON payload with the counted steps back to your MQTT broker. { \"_type\": \"steps\", \"from\": 1400455130, \"steps\": 1234, \"to\": 1400458000, \"tst\": 1400455130 }","title":"Command"},{"location":"features/pedometer/#daily-reports","text":"We use the following small program to issue the JSON needed to request the steps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.) #!/usr/bin/env python import datetime import time import json import sys days = 0 def unix_epoch(t, delta): dt = t + delta # print dt return int(time.mktime(dt.timetuple())) now = datetime.datetime.today() f = now.replace(now.year, now.month, now.day, 0, 0, 1, 0) t = now.replace(now.year, now.month, now.day, 23, 59, 59, 0) delta = datetime.timedelta(days=days) payload = { '_type' : 'cmd', 'action' : 'reportSteps', 'from' : unix_epoch(f, delta), 'to' : unix_epoch(t, delta), } print json.dumps(payload) In the evening, a cron entry sends that off to our broker which will, eventually, deliver the message to the the phone. 50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l","title":"Daily reports"},{"location":"features/pedometer/#daily-reports-with-openhab","text":"With openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab. At first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg mqtt-retain.url=tcp://192.168.1.1:1884 mqtt-retain.qos=2 After that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents: rule \"MQTT_OWNTRACKS_STEPS\" when // every day at 23:59 Time cron \"0 59 23 * * ? *\" then val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000 val long to1 = (now.millis / 1000) publish(\"mqtt-retain\",\"owntracks/jj/5s/cmd\",'{\"action\": \"reportSteps\", \"to\": '+ to1 +', \"_type\": \"cmd\", \"from\": '+ from1 +'}') end For usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items Number Steps_Yesterday \"[%d]\" { mqtt=\"<[mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]\" } Now You can make use of yesterday's steps count.","title":"Daily reports with Openhab"},{"location":"features/remoteconfig/","text":"Configuration file The configuration can be sent to the device as a file that can by imported into the apps. This can be used to initially configure the device or chane detailed settings later. Create a configuration file in JSON with an .otrc suffix (for OwnTracks Configuration) Ensure the JSON is valid with online JSON validator , jq or simply by running python -mjson.tool < your.otrc Send the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, ... you name it. Have the OwnTracks app user open the file on their device with OwnTracks. Here is a sample configuration file which contains some of the possible settings. { \"_type\": \"configuration\", \"auth\": true, \"username\": \"jjolie\", \"password\": \"s1kr3t\", \"host\": \"mybroker.example.org\", \"port\": 8883 } The _type entry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described on the JSON page . setConfiguration The configuration of a connected app can also be changed remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A _type: configuration as described on the JSON page can be send to the device. setWaypoints Waypoints can be configured remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the tst timestamp, so overwriting an existing tst actually overwrites an existing waypoint.) { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"waypoints\": [ { \"desc\": \"Some place\", \"rad\": 8867, \"lon\": 10.428771973, \"lat\": 46.935260881, \"tst\": 1437552714, \"_type\": \"waypoint\" } ], \"_type\": \"waypoints\" } } Publishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints. URL config Since January 2021, both iOS and Android apps can be configured by having the user click on an owntracks:///config?inline= URL containing a base64-encoded version of the content of an .otrc file. Say we have a file called j.otrc with the JSON _type: configuration shown above. We can use, say, the openssl utility to base64-encode encode the configuration into a single line: echo \"owntracks:///config?inline=$(openssl enc -a -A -in j.otrc)\" which results in this text: owntracks:///config?inline=ewogICJfdHlwZSI6ICJjb25maWd1cmF0aW9uIiwKICAiYXV0aCI6IHRydWUsCiAgInVzZXJuYW1lIjogImpqb2xpZSIsCiAgInBhc3N3b3JkIjogInMxa3IzdCIsCiAgImhvc3QiOiAibXlicm9rZXIuZXhhbXBsZS5vcmciLAogICJwb3J0IjogODg4Mwp9Cg== We can then paste that text into the @@ placeholder on an HTML like this: <html><body><p> <a href=\"@@\">Click to configure OwnTracks</a> </p></body></html> This link is then made available to click on after the user has installed the OwnTracks app for configuring it. By omitting, say, deviceID and tid it would be possible to \"mass configure\" a number of users' apps.","title":"Remoteconfig"},{"location":"features/remoteconfig/#configuration-file","text":"The configuration can be sent to the device as a file that can by imported into the apps. This can be used to initially configure the device or chane detailed settings later. Create a configuration file in JSON with an .otrc suffix (for OwnTracks Configuration) Ensure the JSON is valid with online JSON validator , jq or simply by running python -mjson.tool < your.otrc Send the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, ... you name it. Have the OwnTracks app user open the file on their device with OwnTracks. Here is a sample configuration file which contains some of the possible settings. { \"_type\": \"configuration\", \"auth\": true, \"username\": \"jjolie\", \"password\": \"s1kr3t\", \"host\": \"mybroker.example.org\", \"port\": 8883 } The _type entry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described on the JSON page .","title":"Configuration file"},{"location":"features/remoteconfig/#setconfiguration","text":"The configuration of a connected app can also be changed remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A _type: configuration as described on the JSON page can be send to the device.","title":"setConfiguration"},{"location":"features/remoteconfig/#setwaypoints","text":"Waypoints can be configured remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the tst timestamp, so overwriting an existing tst actually overwrites an existing waypoint.) { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"waypoints\": [ { \"desc\": \"Some place\", \"rad\": 8867, \"lon\": 10.428771973, \"lat\": 46.935260881, \"tst\": 1437552714, \"_type\": \"waypoint\" } ], \"_type\": \"waypoints\" } } Publishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints.","title":"setWaypoints"},{"location":"features/remoteconfig/#url-config","text":"Since January 2021, both iOS and Android apps can be configured by having the user click on an owntracks:///config?inline= URL containing a base64-encoded version of the content of an .otrc file. Say we have a file called j.otrc with the JSON _type: configuration shown above. We can use, say, the openssl utility to base64-encode encode the configuration into a single line: echo \"owntracks:///config?inline=$(openssl enc -a -A -in j.otrc)\" which results in this text: owntracks:///config?inline=ewogICJfdHlwZSI6ICJjb25maWd1cmF0aW9uIiwKICAiYXV0aCI6IHRydWUsCiAgInVzZXJuYW1lIjogImpqb2xpZSIsCiAgInBhc3N3b3JkIjogInMxa3IzdCIsCiAgImhvc3QiOiAibXlicm9rZXIuZXhhbXBsZS5vcmciLAogICJwb3J0IjogODg4Mwp9Cg== We can then paste that text into the @@ placeholder on an HTML like this: <html><body><p> <a href=\"@@\">Click to configure OwnTracks</a> </p></body></html> This link is then made available to click on after the user has installed the OwnTracks app for configuring it. By omitting, say, deviceID and tid it would be possible to \"mass configure\" a number of users' apps.","title":"URL config"},{"location":"features/security/","text":"Security OwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your loved ones is something only you respectively they should know. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes. If your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over TLS when connecting to your broker. The apps support authenticating to the MQTT broker with username and password which can be as strong (or as convoluted) as your broker supports. In HTTP mode, the apps provide support for HTTP basic authentication with TLS. Credentials you configure (i.e. username and password ) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits. The apps support using TLS client certificates for authentication to the MQTT broker. The apps support payload encryption for privacy. The apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server).","title":"Security"},{"location":"features/security/#security","text":"OwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your loved ones is something only you respectively they should know. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes. If your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over TLS when connecting to your broker. The apps support authenticating to the MQTT broker with username and password which can be as strong (or as convoluted) as your broker supports. In HTTP mode, the apps provide support for HTTP basic authentication with TLS. Credentials you configure (i.e. username and password ) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits. The apps support using TLS client certificates for authentication to the MQTT broker. The apps support payload encryption for privacy. The apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server).","title":"Security"},{"location":"features/tid/","text":"TID A TID is a tracker ID , a two-character identifier of your chosing, your initials, say. This TID is published in the JSON payload of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather long topic name . The TID of your friends is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained card published.","title":"Tracker ID"},{"location":"features/tid/#tid","text":"A TID is a tracker ID , a two-character identifier of your chosing, your initials, say. This TID is published in the JSON payload of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather long topic name . The TID of your friends is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained card published.","title":"TID"},{"location":"features/tls/","text":"TLS You want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using TLS . When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.) Configuring TLS ( Transport Layer Security ) for OwnTracks involves doing three things: Obtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one Configure TLS on the MQTT broker Configuring the app to use TLS You can share the certificate if you want to (though not many people will want it ...) It's so public, that it's perfectly OK to send yourself the file by, say, e-mail. Configure TLS on the Mosquitto broker We'll first show you how to set up TLS on your Mosquitto broker . The basic configuration for TLS in mosquitto.conf is: listener 8883 cafile ............. certfile ............. keyfile ............. (see also: mosquitto-tls .) 8883 is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port. cafile is the path to the certificate authority file certfile points to your server's certificate in PEM format keyfile points to your server's secret key file (which you never divulge!) Configure the OwnTracks app to use TLS We show you here how to set up your iOS or Android device with that kind of certificate. In both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a .crt extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment. In our example, the CA certificate is called MQTTitude-ca.crt . Android Note that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below). So, here's your e-mail message with said attachment. Now click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen MQTTitude , of course. Then click OK. That's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. Note that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying). iOS So, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself! You've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install. Read the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right. There you go! That's it: the certificate was installed. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. manual configuration on Android From the, say, e-mail you got with the certificate, click \"save\" on the attached .crt file which is stored on your device's Download folder. In OwnTracks's settings, select TLS (Custom Certificate) Now comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is /storage/emulated/0/Download/MQTTitude.crt . Your mileage, etc; When you click Connect , it will try and use your certificate. Good luck! ;-) The nitty gritty That CA certificate file we mentioned? The attachment called something.crt ? It looks like this, in fact, in what is called PEM format; but you don't really want to know that, but if you do, this is what it looks like: -----BEGIN CERTIFICATE----- MIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV BAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK ... pjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS cPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc= -----END CERTIFICATE----- That's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak: Certificate: Data: Version: 3 (0x2) Serial Number: e0:d7:9d:ed:b2:57:9d:73 Signature Algorithm: sha1WithRSAEncryption Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Validity Not Before: Aug 18 10:26:08 2013 GMT Not After : Aug 16 10:26:08 2023 GMT Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25: ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 X509v3 Authority Key Identifier: keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com serial:E0:D7:9D:ED:B2:57:9D:73 X509v3 Basic Constraints: CA:TRUE Signature Algorithm: sha1WithRSAEncryption 74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c: ... Better, huh? Well, at least parts of it are now readable. Hope you liked this. Obtain a certificate and key The following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with Mosquitto . You can also create your own self-signed certificate. We provide the generate-CA.sh utility for doing this easily. startssl.com If you have a key-pair issued by startssl.com , you'll be issued a key (in a *.key file), and a certificate (as *.pem or *.crt -- either contains a PEM-encoded certificate). Mosquitto will need the certificate chain for startssl.com , which you can find as ca-bundle.crt at www.startssl.com/certs/ . As far as TLS is concerned, you'll therefore set up your mosquitto.conf as follows, specifying corrrect paths to the files. listener 8883 cafile ca-bundle.crt certfile server.crt keyfile server.key Then download the startssl.com CA certificate ( ca.crt ) and install that on your device as described above.","title":"TLS"},{"location":"features/tls/#tls","text":"You want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using TLS . When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.) Configuring TLS ( Transport Layer Security ) for OwnTracks involves doing three things: Obtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one Configure TLS on the MQTT broker Configuring the app to use TLS You can share the certificate if you want to (though not many people will want it ...) It's so public, that it's perfectly OK to send yourself the file by, say, e-mail.","title":"TLS"},{"location":"features/tls/#configure-tls-on-the-mosquitto-broker","text":"We'll first show you how to set up TLS on your Mosquitto broker . The basic configuration for TLS in mosquitto.conf is: listener 8883 cafile ............. certfile ............. keyfile ............. (see also: mosquitto-tls .) 8883 is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port. cafile is the path to the certificate authority file certfile points to your server's certificate in PEM format keyfile points to your server's secret key file (which you never divulge!)","title":"Configure TLS on the Mosquitto broker"},{"location":"features/tls/#configure-the-owntracks-app-to-use-tls","text":"We show you here how to set up your iOS or Android device with that kind of certificate. In both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a .crt extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment. In our example, the CA certificate is called MQTTitude-ca.crt .","title":"Configure the OwnTracks app to use TLS"},{"location":"features/tls/#android","text":"Note that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below). So, here's your e-mail message with said attachment. Now click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen MQTTitude , of course. Then click OK. That's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. Note that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying).","title":"Android"},{"location":"features/tls/#ios","text":"So, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself! You've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install. Read the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right. There you go! That's it: the certificate was installed. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.","title":"iOS"},{"location":"features/tls/#manual-configuration-on-android","text":"From the, say, e-mail you got with the certificate, click \"save\" on the attached .crt file which is stored on your device's Download folder. In OwnTracks's settings, select TLS (Custom Certificate) Now comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is /storage/emulated/0/Download/MQTTitude.crt . Your mileage, etc; When you click Connect , it will try and use your certificate. Good luck! ;-)","title":"manual configuration on Android"},{"location":"features/tls/#the-nitty-gritty","text":"That CA certificate file we mentioned? The attachment called something.crt ? It looks like this, in fact, in what is called PEM format; but you don't really want to know that, but if you do, this is what it looks like: -----BEGIN CERTIFICATE----- MIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV BAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK ... pjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS cPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc= -----END CERTIFICATE----- That's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak: Certificate: Data: Version: 3 (0x2) Serial Number: e0:d7:9d:ed:b2:57:9d:73 Signature Algorithm: sha1WithRSAEncryption Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Validity Not Before: Aug 18 10:26:08 2013 GMT Not After : Aug 16 10:26:08 2023 GMT Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25: ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 X509v3 Authority Key Identifier: keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com serial:E0:D7:9D:ED:B2:57:9D:73 X509v3 Basic Constraints: CA:TRUE Signature Algorithm: sha1WithRSAEncryption 74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c: ... Better, huh? Well, at least parts of it are now readable. Hope you liked this.","title":"The nitty gritty"},{"location":"features/tls/#obtain-a-certificate-and-key","text":"The following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with Mosquitto . You can also create your own self-signed certificate. We provide the generate-CA.sh utility for doing this easily.","title":"Obtain a certificate and key"},{"location":"features/tls/#startsslcom","text":"If you have a key-pair issued by startssl.com , you'll be issued a key (in a *.key file), and a certificate (as *.pem or *.crt -- either contains a PEM-encoded certificate). Mosquitto will need the certificate chain for startssl.com , which you can find as ca-bundle.crt at www.startssl.com/certs/ . As far as TLS is concerned, you'll therefore set up your mosquitto.conf as follows, specifying corrrect paths to the files. listener 8883 cafile ca-bundle.crt certfile server.crt keyfile server.key Then download the startssl.com CA certificate ( ca.crt ) and install that on your device as described above.","title":"startssl.com"},{"location":"features/tlscert/","text":"Client certificates The OwnTracks iOS and Android clients can be configured to use TLS client certificates to authenticate against their MQTT broker. This is the next best thing to two-factor authentication, where the apps have a TLS key and a certificate which has to be presented to the broker for successful authentication. Mosquitto When using the Mosquitto broker support for TLS certificates can be enabled as follows: require_certificate true use_identity_as_username true Client certs To create a client certificate and key, you can use, say, generate-CA.sh from our tools repository . ./generate-CA.sh client jjolie This produces at least two files which are required on the OwnTracks devices: a .key file and a .crt file. PKCS#12 In order to safely transport a user's key and certificate to the OwnTracks app, we make use of the PKCS#12 container format. OpenSSL's pkcs12 subcommand creates this container and protects it with a passphrase you specify. This passphrase we will later require in the app. openssl pkcs12 \\ -export \\ -in jjolie.crt \\ -inkey jjolie.key \\ -name \"Jane's certificate/key\" \\ -out jjolie.p12 You now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a .otrp extension so that it can be opened in OwnTracks. You also send the CA certificate to the device and install it there, as discussed in TLS Android Save the certificate to your device in an easy accessible location Import the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser. The file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device. Specify the certificate password (certificates without password are not supported). iOS We recommend you proceed as follows: Install the TLS CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.) Send the prepared PKCS#12 file (with an .otrp extension) to your device, and open it. It will be imported into OwnTracks Launch OwnTracks, select Settings and TLS. Select the otrp file you just imported as Client Certificate Filename, and below that, enter its passphrase. Leave Use Custom Security Policy disabled. Verify the connection to your broker. If need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button Use Custom Security Policy can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only. Mode None; do not use pinned certificates to validate servers Public Key; validate host (broker) certificates against the public keys of the pinned certificate Certificate; validate host certificates against pinned certificates Pinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled. Validate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled. Allow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates. Validate Domain Name; whether or not to validate the domain name in the certificate's CN field. Note: on iOS self-signed certificates require Custom Security Policy to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.) Client certificates are independent of the custom security policy settings. If you wish to use certificate pinning, you must provide a DER-encoded file with an .otre extension to the device containing the pinned certificate. openssl x509 \\ -in ca.crt \\ -out ca.otre \\ -outform DER","title":"TLS client"},{"location":"features/tlscert/#client-certificates","text":"The OwnTracks iOS and Android clients can be configured to use TLS client certificates to authenticate against their MQTT broker. This is the next best thing to two-factor authentication, where the apps have a TLS key and a certificate which has to be presented to the broker for successful authentication.","title":"Client certificates"},{"location":"features/tlscert/#mosquitto","text":"When using the Mosquitto broker support for TLS certificates can be enabled as follows: require_certificate true use_identity_as_username true","title":"Mosquitto"},{"location":"features/tlscert/#client-certs","text":"To create a client certificate and key, you can use, say, generate-CA.sh from our tools repository . ./generate-CA.sh client jjolie This produces at least two files which are required on the OwnTracks devices: a .key file and a .crt file.","title":"Client certs"},{"location":"features/tlscert/#pkcs12","text":"In order to safely transport a user's key and certificate to the OwnTracks app, we make use of the PKCS#12 container format. OpenSSL's pkcs12 subcommand creates this container and protects it with a passphrase you specify. This passphrase we will later require in the app. openssl pkcs12 \\ -export \\ -in jjolie.crt \\ -inkey jjolie.key \\ -name \"Jane's certificate/key\" \\ -out jjolie.p12 You now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a .otrp extension so that it can be opened in OwnTracks. You also send the CA certificate to the device and install it there, as discussed in TLS","title":"PKCS#12"},{"location":"features/tlscert/#android","text":"Save the certificate to your device in an easy accessible location Import the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser. The file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device. Specify the certificate password (certificates without password are not supported).","title":"Android"},{"location":"features/tlscert/#ios","text":"We recommend you proceed as follows: Install the TLS CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.) Send the prepared PKCS#12 file (with an .otrp extension) to your device, and open it. It will be imported into OwnTracks Launch OwnTracks, select Settings and TLS. Select the otrp file you just imported as Client Certificate Filename, and below that, enter its passphrase. Leave Use Custom Security Policy disabled. Verify the connection to your broker. If need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button Use Custom Security Policy can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only. Mode None; do not use pinned certificates to validate servers Public Key; validate host (broker) certificates against the public keys of the pinned certificate Certificate; validate host certificates against pinned certificates Pinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled. Validate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled. Allow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates. Validate Domain Name; whether or not to validate the domain name in the certificate's CN field. Note: on iOS self-signed certificates require Custom Security Policy to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.) Client certificates are independent of the custom security policy settings. If you wish to use certificate pinning, you must provide a DER-encoded file with an .otre extension to the device containing the pinned certificate. openssl x509 \\ -in ca.crt \\ -out ca.otre \\ -outform DER","title":"iOS"},{"location":"features/tours/","text":"Tours: Location Sharing Currently: iOS and Recorder only. Requires: enabled remote CMD on device. You might occasionally wish to share your location with somebody who doesn't have OwnTracks. For these situations you can set up what we call a Tour -- a time-limited view of your location which can be viewed from a Web browser. The OwnTracks Recorder gets a request for a Tour as a JSON published to the ../request subtopic or POSTed to the HTTP endpoint: { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\" } } The Recorder creates a View from this and returns a unique URL to this View which you can share with anybody you want to. { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tour\", \"status\": 200, \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\", \"url\": \"http://localhost:8085/view/7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\" } Your last location is marked on this View's map with a red dot and the track of your movements between the from and to times can be loaded. The important bit: the visitor of the unique URL will not see your location prior to the specified from time nor after the to time. It is also possible to completely delete the Tour in which case a user attempting to access it would get a 404 Not Found. Tours can outlive the to field if you want to, say, provide a historic map of where you once were (i.e. My 2019 vacation on Mallorca ). An authorized client may also request a list of current Tours with this JSON: { \"_type\": \"request\", \"request\": \"tours\" } whereupon an array of existing Tours and their unique URLs is returned: { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tours\", \"tours\": [ { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\", \"url\": \"http://localhost:8085/view/0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } ], \"ntours\": 1 } Only Tours which have been created by a user for their specific device will be enumerated in the Tours list. Tours can be \"un-toured\" (i.e. deleted) with this payload: { \"_type\": \"request\", \"request\": \"untour\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } For Tours to work, the Recorder needs to be compiled with support for HTTP and TOURS, and the following settings need defining: OTR_HTTPPREFIX must be configured to contain the URL to the Recorder as seen from \"outside\", i.e. from the Internet. This setting is used to construct the unique URL which will be returned for a Tour. So, if you have, say, a Recorder behind an NGINX proxy (as described in our README), then the setting would say console export OTR_HTTPPREFIX=\"https://example.net/owntracks\" on the other hand, if you're testing internally and your Recorder is listening on port 8085, you might do this: console export OTR_HTTPPREFIX=\"http://localhost:8085\" Initially we thought the term \"share\" would be good but then decided it's a too ambiguous word, and we didn't want to run into the mess we created with mixing terms (remember region and waypoint? :-) ). After a bit of pondering we think the word tour as in (\"I did a tour last year I want to show you\") or as in (\"I am now on tour\") is adequate.","title":"Tours"},{"location":"features/tours/#tours-location-sharing","text":"Currently: iOS and Recorder only. Requires: enabled remote CMD on device. You might occasionally wish to share your location with somebody who doesn't have OwnTracks. For these situations you can set up what we call a Tour -- a time-limited view of your location which can be viewed from a Web browser. The OwnTracks Recorder gets a request for a Tour as a JSON published to the ../request subtopic or POSTed to the HTTP endpoint: { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\" } } The Recorder creates a View from this and returns a unique URL to this View which you can share with anybody you want to. { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tour\", \"status\": 200, \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\", \"url\": \"http://localhost:8085/view/7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\" } Your last location is marked on this View's map with a red dot and the track of your movements between the from and to times can be loaded. The important bit: the visitor of the unique URL will not see your location prior to the specified from time nor after the to time. It is also possible to completely delete the Tour in which case a user attempting to access it would get a 404 Not Found. Tours can outlive the to field if you want to, say, provide a historic map of where you once were (i.e. My 2019 vacation on Mallorca ). An authorized client may also request a list of current Tours with this JSON: { \"_type\": \"request\", \"request\": \"tours\" } whereupon an array of existing Tours and their unique URLs is returned: { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tours\", \"tours\": [ { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\", \"url\": \"http://localhost:8085/view/0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } ], \"ntours\": 1 } Only Tours which have been created by a user for their specific device will be enumerated in the Tours list. Tours can be \"un-toured\" (i.e. deleted) with this payload: { \"_type\": \"request\", \"request\": \"untour\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } For Tours to work, the Recorder needs to be compiled with support for HTTP and TOURS, and the following settings need defining: OTR_HTTPPREFIX must be configured to contain the URL to the Recorder as seen from \"outside\", i.e. from the Internet. This setting is used to construct the unique URL which will be returned for a Tour. So, if you have, say, a Recorder behind an NGINX proxy (as described in our README), then the setting would say console export OTR_HTTPPREFIX=\"https://example.net/owntracks\" on the other hand, if you're testing internally and your Recorder is listening on port 8085, you might do this: console export OTR_HTTPPREFIX=\"http://localhost:8085\" Initially we thought the term \"share\" would be good but then decided it's a too ambiguous word, and we didn't want to run into the mess we created with mixing terms (remember region and waypoint? :-) ). After a bit of pondering we think the word tour as in (\"I did a tour last year I want to show you\") or as in (\"I am now on tour\") is adequate.","title":"Tours: Location Sharing"},{"location":"features/traccar/","text":"Traccar Traccar is a free and open source GPS tracking system for which there exists an OwnTracks protocol decoder (called owntracks ) which is, by default, configured on TCP port 5144 on the Traccar server: <entry key='owntracks.port'>5144</entry> Thus you need to configure OwnTracks clients in HTTP mode to connect to your Traccar server at this port, using a URL such as http://traccar.example.net:5144 To make Traccar accept a connection from an owntracks client, you need to set a matching identifier . This identifier is per default the tid of your device. If you have configured a topic for your device, owntracks will identify using the topic instead of the tid (currently iOS only). An example of a configuration using a topic of owntracks/jane/phone to identify against the Traccar server. Notes Neither encryption nor friends are supported in Traccar. If you see a 400 error in the Traccar log, this means the identifier you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one, tid or topic . HTTP Payloads HTTP POST payloads shall contain at least the elements lat , lon , _type:location , tst , and either or both of tid and topic . If topic is contained in the payload, that will be used as Traccar's identifier (in which case tid will be added to attributes), else tid . {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"tst\":1497476456, \"tid\":\"JJ\"} {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"topic\":\"owntracks/jane/phone\", \"tid\": \"JJ\"} The following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes: vel , alt , cog , acc , t , batt , so with an HTTP payload that an OwnTracks app produces like { \"cog\": 271, \"batt\": 41, \"lon\": 2.29513, \"acc\": 5, \"vel\": 61, \"vac\": 21, \"lat\": 48.85833, \"t\": \"u\", \"tst\": 1497508651, \"alt\": 167, \"_type\": \"location\", \"topic\": \"owntracks/jane/iphone\", \"p\": 71, \"tid\": \"JJ\" } a query on the Traccar API could produce something like this: [ { \"id\": 475, \"attributes\": { \"t\": \"u\", \"battery\": 41, \"tid\": \"JJ\", \"ip\": \"127.0.0.1\", \"distance\": 0, \"totalDistance\": 0 }, \"deviceId\": 4, \"type\": null, \"protocol\": \"owntracks\", \"serverTime\": \"2017-06-15T06:37:32.000+0000\", \"deviceTime\": \"2017-06-15T06:37:31.000+0000\", \"fixTime\": \"2017-06-15T06:37:31.000+0000\", \"outdated\": false, \"valid\": true, \"latitude\": 48.85833, \"longitude\": 2.29513, \"altitude\": 167, \"speed\": 1.18575, \"course\": 271, \"address\": \"9 Avenue Anatole France, Paris, \u00cele-de-France, FR\", \"accuracy\": 5, \"network\": null } ]","title":"Traccar"},{"location":"features/traccar/#traccar","text":"Traccar is a free and open source GPS tracking system for which there exists an OwnTracks protocol decoder (called owntracks ) which is, by default, configured on TCP port 5144 on the Traccar server: <entry key='owntracks.port'>5144</entry> Thus you need to configure OwnTracks clients in HTTP mode to connect to your Traccar server at this port, using a URL such as http://traccar.example.net:5144 To make Traccar accept a connection from an owntracks client, you need to set a matching identifier . This identifier is per default the tid of your device. If you have configured a topic for your device, owntracks will identify using the topic instead of the tid (currently iOS only). An example of a configuration using a topic of owntracks/jane/phone to identify against the Traccar server.","title":"Traccar"},{"location":"features/traccar/#notes","text":"Neither encryption nor friends are supported in Traccar. If you see a 400 error in the Traccar log, this means the identifier you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one, tid or topic .","title":"Notes"},{"location":"features/traccar/#http-payloads","text":"HTTP POST payloads shall contain at least the elements lat , lon , _type:location , tst , and either or both of tid and topic . If topic is contained in the payload, that will be used as Traccar's identifier (in which case tid will be added to attributes), else tid . {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"tst\":1497476456, \"tid\":\"JJ\"} {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"topic\":\"owntracks/jane/phone\", \"tid\": \"JJ\"} The following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes: vel , alt , cog , acc , t , batt , so with an HTTP payload that an OwnTracks app produces like { \"cog\": 271, \"batt\": 41, \"lon\": 2.29513, \"acc\": 5, \"vel\": 61, \"vac\": 21, \"lat\": 48.85833, \"t\": \"u\", \"tst\": 1497508651, \"alt\": 167, \"_type\": \"location\", \"topic\": \"owntracks/jane/iphone\", \"p\": 71, \"tid\": \"JJ\" } a query on the Traccar API could produce something like this: [ { \"id\": 475, \"attributes\": { \"t\": \"u\", \"battery\": 41, \"tid\": \"JJ\", \"ip\": \"127.0.0.1\", \"distance\": 0, \"totalDistance\": 0 }, \"deviceId\": 4, \"type\": null, \"protocol\": \"owntracks\", \"serverTime\": \"2017-06-15T06:37:32.000+0000\", \"deviceTime\": \"2017-06-15T06:37:31.000+0000\", \"fixTime\": \"2017-06-15T06:37:31.000+0000\", \"outdated\": false, \"valid\": true, \"latitude\": 48.85833, \"longitude\": 2.29513, \"altitude\": 167, \"speed\": 1.18575, \"course\": 271, \"address\": \"9 Avenue Anatole France, Paris, \u00cele-de-France, FR\", \"accuracy\": 5, \"network\": null } ]","title":"HTTP Payloads"},{"location":"features/waypoints/","text":"Regions (Waypoints) The base topic for publishes from the devices (OwnTracks apps) is what you configure it to be in the app's preferences/settings. For argument's sake we'll use the default owntracks/<user>/<device> as our example. This base topic is used for publishes of type location (see JSON ). All messages published to this base topic are retained if you have configured the app to retain them. Additionally, if you've configured a waypoint, regions, or geo-fence (we intermix these terms a lot to mean basically the same thing), a transition event will be published upon entering or leaving a waypoint, containing: rad ius (if its value is greater than 0) desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. rid (> January 2021) with the region ID of the region. If you set up a region (or waypoint or geo-fence, you get the drift), the app publishes that region (with retain=0 irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . Entering or leaving a waypoint will be published as a transition message and will contain a wtst (for historical purposes) with the timestamp of when the region was originally defined. (Note that that branch is /waypoint -- singular.) For example, If Jane configures a region on her iPhone, the app could publish the following payload to owntracks/jane/phone/waypoint : { \"_type\": \"waypoint\", \"desc\": \"Paris is lovely\", \"lat\": \"48.858330\", \"lon\": \"2.295130\", \"rad\": \"50\", \"tst\": \"1385997757\", \"rid\": \"f7676c\" } When you set up a region (with a desc ription and a rad ius), this region is published to the broker with the current time stamp. If you update the region definition on the device at a later stage, the region is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius and lat itude / lon gitude, but with the same rid . To be precise, the rid (region ID) is used as an identifier of the region even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting regions by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location , transition , and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of regions, e.g. for displaying to users. In regions When the apps publish a _type = location message, they add to that an array called inregions (and as from January 2021 an array called inrids ) with the names of the regions and their rid s respectively. The inregions array might be consumed by humans whereas the inrids array would be consumed by developers who will wish to associate the region IDs ( rid ) with the values in inrids . Adding on iOS On iOS you can navigate to the place where you want to place a region, Tap long and edit the Region. The region is always placed at the center of the map (hence it's predefined name Center , which you should change to something meaningful). With a bit of practice, you can then drag the region to it's final destination on the map or, and this may be easier, edit the region and specify its exact coordinates. Adding on Android On Android, regions can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker. Remote loading of regions Instead of configuring multiple regions on the device, they can be loaded remotely with the setWaypoints cmd message if remote configuration is enabled on the device. You can use this to import individual regions or groups of pre-configured regions which are merged into the existing regions definition on the device. Recall, however, that the rid element is like a key which uniquely identifies each region / waypoint. Deleting regions On iOS a region can be deleted by swiping it away. On Android, a long press is required. Beacons Ranging In addition to circular regions, the iOS app can monitor its proximity to BLE Beacons .","title":"Waypoints"},{"location":"features/waypoints/#regions-waypoints","text":"The base topic for publishes from the devices (OwnTracks apps) is what you configure it to be in the app's preferences/settings. For argument's sake we'll use the default owntracks/<user>/<device> as our example. This base topic is used for publishes of type location (see JSON ). All messages published to this base topic are retained if you have configured the app to retain them. Additionally, if you've configured a waypoint, regions, or geo-fence (we intermix these terms a lot to mean basically the same thing), a transition event will be published upon entering or leaving a waypoint, containing: rad ius (if its value is greater than 0) desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. rid (> January 2021) with the region ID of the region. If you set up a region (or waypoint or geo-fence, you get the drift), the app publishes that region (with retain=0 irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . Entering or leaving a waypoint will be published as a transition message and will contain a wtst (for historical purposes) with the timestamp of when the region was originally defined. (Note that that branch is /waypoint -- singular.) For example, If Jane configures a region on her iPhone, the app could publish the following payload to owntracks/jane/phone/waypoint : { \"_type\": \"waypoint\", \"desc\": \"Paris is lovely\", \"lat\": \"48.858330\", \"lon\": \"2.295130\", \"rad\": \"50\", \"tst\": \"1385997757\", \"rid\": \"f7676c\" } When you set up a region (with a desc ription and a rad ius), this region is published to the broker with the current time stamp. If you update the region definition on the device at a later stage, the region is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius and lat itude / lon gitude, but with the same rid . To be precise, the rid (region ID) is used as an identifier of the region even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting regions by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location , transition , and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of regions, e.g. for displaying to users.","title":"Regions (Waypoints)"},{"location":"features/waypoints/#in-regions","text":"When the apps publish a _type = location message, they add to that an array called inregions (and as from January 2021 an array called inrids ) with the names of the regions and their rid s respectively. The inregions array might be consumed by humans whereas the inrids array would be consumed by developers who will wish to associate the region IDs ( rid ) with the values in inrids .","title":"In regions"},{"location":"features/waypoints/#adding-on-ios","text":"On iOS you can navigate to the place where you want to place a region, Tap long and edit the Region. The region is always placed at the center of the map (hence it's predefined name Center , which you should change to something meaningful). With a bit of practice, you can then drag the region to it's final destination on the map or, and this may be easier, edit the region and specify its exact coordinates.","title":"Adding on iOS"},{"location":"features/waypoints/#adding-on-android","text":"On Android, regions can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker.","title":"Adding on Android"},{"location":"features/waypoints/#remote-loading-of-regions","text":"Instead of configuring multiple regions on the device, they can be loaded remotely with the setWaypoints cmd message if remote configuration is enabled on the device. You can use this to import individual regions or groups of pre-configured regions which are merged into the existing regions definition on the device. Recall, however, that the rid element is like a key which uniquely identifies each region / waypoint.","title":"Remote loading of regions"},{"location":"features/waypoints/#deleting-regions","text":"On iOS a region can be deleted by swiping it away. On Android, a long press is required.","title":"Deleting regions"},{"location":"features/waypoints/#beacons-ranging","text":"In addition to circular regions, the iOS app can monitor its proximity to BLE Beacons .","title":"Beacons Ranging"},{"location":"guide/apps/","text":"OwnTracks apps The OwnTracks apps operate in one of two modes (discussed in scenarios ), and you tell the app in which mode you want to use it. In Private MQTT mode, you configure our iOS and Android app to access your broker, and in Private HTTP mode you do similarly but with an HTTP endpoint. iOS Android There are other clients you can use with OwnTracks.","title":"Apps"},{"location":"guide/apps/#owntracks-apps","text":"The OwnTracks apps operate in one of two modes (discussed in scenarios ), and you tell the app in which mode you want to use it. In Private MQTT mode, you configure our iOS and Android app to access your broker, and in Private HTTP mode you do similarly but with an HTTP endpoint.","title":"OwnTracks apps"},{"location":"guide/apps/#ios","text":"","title":"iOS"},{"location":"guide/apps/#android","text":"There are other clients you can use with OwnTracks.","title":"Android"},{"location":"guide/beacons/","text":"iBeacons What is an iBeacon? An iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement. If you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received. What you can do with iBeacons in OwnTracks This data is detected by your OwnTracks iOS device and can be used for region monitoring. Use an iBeacon to get your exact location Position an iBeacon in your study and get enter- and leave-events from that room. Use an iBeacon to connect yourself with a vehicle Equip your car with an iBeacon and monitor how much time you spend commuting. Always see where you parked your car. Use an iBeacon to track a valuable accessory Fit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind. Full feature set is here .","title":"Beacons"},{"location":"guide/beacons/#ibeacons","text":"","title":"iBeacons"},{"location":"guide/beacons/#what-is-an-ibeacon","text":"An iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement. If you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received.","title":"What is an iBeacon?"},{"location":"guide/beacons/#what-you-can-do-with-ibeacons-in-owntracks","text":"This data is detected by your OwnTracks iOS device and can be used for region monitoring. Use an iBeacon to get your exact location Position an iBeacon in your study and get enter- and leave-events from that room. Use an iBeacon to connect yourself with a vehicle Equip your car with an iBeacon and monitor how much time you spend commuting. Always see where you parked your car. Use an iBeacon to track a valuable accessory Fit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind. Full feature set is here .","title":"What you can do with iBeacons in OwnTracks"},{"location":"guide/bridge/","text":"Bridging In order to profit from the Friends feature in OwnTracks, all contacts you want to be able to track on your your device must share a broker, but that can be difficult if both you and your friend (henceforce \"Jane\" in the examples that follow) also use your brokers for other purposes. Mosquitto (and some other MQTT brokers) have a feature called bridging which basically lets you connect two (or more) brokers together. Let's assume that you and Jane want to see each other's location updates while maintaining a connection from your devices to your respective MQTT brokers at home. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those. What will happen? Setting up a bridge is not difficult, but there are some things we have to keep in mind. In this example, we'll assume the following: Your broker will initiate a connection to Jane's broker You'll be using TLS to protect credentials and data in transit Jane has given you (e.g. via e-mail) a copy of her TLS CA certificate Jane has set up an ACL on her Mosquitto broker to ensure you have access only to her OwnTracks location data and nothing else. Jane has a username and password for your broker to use when connecting to her broker, and she's given you both. Jane has a device called nexus7 and she publishes location updates to her broker at owntracks/jane/nexus7 . You have an iPhone and want to share your location data with Jane. You publish (on your broker) to owntracks/john/iphone . Here's what you configure on your broker 's mosquitto.conf : # Bridge to Jane connection br-me-to-jane bridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt bridge_insecure false address jane.example.org:8883 cleansession false clientid br-john-jane start_type automatic username john password s3cr1t notifications false try_private true topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic iphone out 2 owntracks/john/ owntracks/john/ These last two lines define which topic branches will be published ( out ) and which will be subscribed to ( in ) from the point of view of your broker. There are a lot of things you can tweak in this configuration, but this is should get you started. Publishes When your device publishes location data to your broker, it will publish the single topic owntracks/john/iphone to Jane's broker. Conversely, as your broker is now subscribed to Jane's at owntracks/jane/nexus7 , it will receive Jane's location data and re-publish that to your connected device. Events OwnTracks uses more than just a single topic per user as documented . This means we must add more topic statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location now ). Assuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes in to our broker. The second line is new: it bridges Jane's nexus7 events into our broker. topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/ CMD Tapping on OwnTrack's request location update publishes a cmd to the destination device, so we bridge that topic out towards Jane's broker: topic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/ MQTTitude Let's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration: topic # in 2 owntracks/ mqttitude/ What this does is: your bridge subscribes to the remote topic mqttitude/# and all received messages will be republished at owntracks/ on your broker (note the in direction). Neat, eh? Consult the manual page for mosquitto.conf for more details.","title":"Bridging"},{"location":"guide/bridge/#bridging","text":"In order to profit from the Friends feature in OwnTracks, all contacts you want to be able to track on your your device must share a broker, but that can be difficult if both you and your friend (henceforce \"Jane\" in the examples that follow) also use your brokers for other purposes. Mosquitto (and some other MQTT brokers) have a feature called bridging which basically lets you connect two (or more) brokers together. Let's assume that you and Jane want to see each other's location updates while maintaining a connection from your devices to your respective MQTT brokers at home. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those.","title":"Bridging"},{"location":"guide/bridge/#what-will-happen","text":"Setting up a bridge is not difficult, but there are some things we have to keep in mind. In this example, we'll assume the following: Your broker will initiate a connection to Jane's broker You'll be using TLS to protect credentials and data in transit Jane has given you (e.g. via e-mail) a copy of her TLS CA certificate Jane has set up an ACL on her Mosquitto broker to ensure you have access only to her OwnTracks location data and nothing else. Jane has a username and password for your broker to use when connecting to her broker, and she's given you both. Jane has a device called nexus7 and she publishes location updates to her broker at owntracks/jane/nexus7 . You have an iPhone and want to share your location data with Jane. You publish (on your broker) to owntracks/john/iphone . Here's what you configure on your broker 's mosquitto.conf : # Bridge to Jane connection br-me-to-jane bridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt bridge_insecure false address jane.example.org:8883 cleansession false clientid br-john-jane start_type automatic username john password s3cr1t notifications false try_private true topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic iphone out 2 owntracks/john/ owntracks/john/ These last two lines define which topic branches will be published ( out ) and which will be subscribed to ( in ) from the point of view of your broker. There are a lot of things you can tweak in this configuration, but this is should get you started.","title":"What will happen?"},{"location":"guide/bridge/#publishes","text":"When your device publishes location data to your broker, it will publish the single topic owntracks/john/iphone to Jane's broker. Conversely, as your broker is now subscribed to Jane's at owntracks/jane/nexus7 , it will receive Jane's location data and re-publish that to your connected device.","title":"Publishes"},{"location":"guide/bridge/#events","text":"OwnTracks uses more than just a single topic per user as documented . This means we must add more topic statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location now ). Assuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes in to our broker. The second line is new: it bridges Jane's nexus7 events into our broker. topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/","title":"Events"},{"location":"guide/bridge/#cmd","text":"Tapping on OwnTrack's request location update publishes a cmd to the destination device, so we bridge that topic out towards Jane's broker: topic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/","title":"CMD"},{"location":"guide/bridge/#mqttitude","text":"Let's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration: topic # in 2 owntracks/ mqttitude/ What this does is: your bridge subscribes to the remote topic mqttitude/# and all received messages will be republished at owntracks/ on your broker (note the in direction). Neat, eh? Consult the manual page for mosquitto.conf for more details.","title":"MQTTitude"},{"location":"guide/broker/","text":"MQTT broker An MQTT broker is a service to which MQTT clients connect. These clients publish data to specific topics and they can subscribe to one or more topics to receive messages. A topic is like an \"address\" for a particular message. For example, a topic for a device that publishes a temperature reading of your living room may be temperature/indoors/living , whereas a device which publishes weather data could do so to weather/germany/frankfurt . In the particular case of OwnTracks, we use a topic branch called owntracks/username/device , but you can override that name if you prefer to. The reason we've chosen that structure is to accomodate friends and family on a single broker, taking into consideration that a particular user might have more than one device. Private broker You set up a private broker under your control. This sounds more difficult than it actually is, and there are some very nice brokers you can use free of charge on your own infrastructure. As an example, we've written up how to install Mosquitto on a Raspberry Pi. RasPi The hardest bit is installing an OS, say, Raspbian Wheezy , onto an SD card, but there are many tutorials on how to do that. (Here's an example using Mac OS X .) A basic install will suffice, and after logging in with Raspbian's default username and password, we'll get started from there. Note that the current Raspbian Wheezy mosquitto package does NOT contain the mosquitto_passwd tool. If you want to use it, make sure you install the package from a mosquitto repo: Roger Light, Mosquitto 's creator has thankfully (!) set up a few Mosquitto repositories we can use to obtain the latest and greatest version, so we'll do just that. We first perform the required steps to add and activate the repository. The last step in particular can take a few moments. curl -O http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key sudo apt-key add mosquitto-repo.gpg.key rm mosquitto-repo.gpg.key cd /etc/apt/sources.list.d/ sudo curl -O http://repo.mosquitto.org/debian/mosquitto-$(awk -F\"[)(]+\" '/VERSION=/ {print $2}' /etc/os-release).list sudo apt-get update Now we can go ahead and install Mosquitto proper. There are three packages: mosquitto is the MQTT broker (i.e. server) mosquitto-clients are the command-line clients, which I recommend you install Don't install python-mosquitto ; if you want to do programming with Python and MQTT, we show you how to do so with the Paho Python module . sudo apt-get install mosquitto mosquitto-clients Regrettably, as with most Debian packages, the broker is immediately started; stop it. sudo /etc/init.d/mosquitto stop That concludes the installation of the Mosquitto MQTT broker, and we'll now proceed to its configuration. This section is geared towards a configuration of Mosquitto which will work well with OwnTracks. In particular we want the following features enabled by default: Connections to the broker must be authenticated either against user/password or using client certificates. Connections to the broker shall also be TLS protected. This requires a (server-side) TLS certificate and key which will be configured automatically. ACLs will restrict who may access what. To create a mosquitto user database, use sudo mosquitto_passwd -c /etc/mosquitto/passwd <username> . You will be prompted to enter a password. That will be the password required to connect to the server (with the username you chose). If you want to add more users, repeat the command without -c as that will create (i.e. overwrite) the passwd file. Add a config line password_file /etc/mosquitto/passwd to /etc/mosquitto/mosquitto.conf . If you want to use certificates to identify yourself to the broker and/or to TLS-encrypt the TCP session, we've got some utilities over at the OwnTracks repository which are going to automate this process for you. It's a work-in-progress (of course), but this is what sudo ./mosquitto-setup.sh looks like at the moment: Saving previous configuration as mosquitto.conf-20130901-133525 Generating a 2048 bit RSA private key .................................................................................................+++ ...............................+++ writing new private key to '/etc/mosquitto/ca.key' ----- Created CA certificate in /etc/mosquitto/ca.crt subject= commonName = An MQTT broker organizationName = MQTTitude.org emailAddress = nobody@example.net --- Creating server key and signing request Generating RSA private key, 2048 bit long modulus ............+++ ..............+++ e is 65537 (0x10001) --- Creating and signing server certificate Signature ok subject=/CN=raspberrypi/O=MQTTitude.org/emailAddress=nobody@example.net Getting CA Private Key A CA is created together with a server key-pair with a whole bunch of subjAltName settings: X509v3 Subject Alternative Name: IP Address:192.168.1.189, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1, DNS:broker.example.com, DNS:foo.example.de, DNS:localhost Check for a couple of broker settings in /etc/mosquitto/mosquitto.conf . Your mileage may vary, but you might want to set the following parameters: listener 1883 persistence_file mosquitto.db log_dest syslog log_dest stdout log_dest topic log_type error log_type warning log_type notice log_type information connection_messages true log_timestamp true allow_anonymous false password_file /etc/mosquitto/passwd Will it work? Let's start the broker manually to see what it says: sudo /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf 1378042632: mosquitto version 1.2 (build date 2013-08-09 21:49:03+0100) starting 1378042632: Config loaded from /etc/mosquitto/mosquitto.conf. 1378042632: Opening ipv4 listen socket on port 1883. 1378042632: Opening ipv4 listen socket on port 8883. 1378042632: Opening ipv6 listen socket on port 8883. 1378042632: Warning: Address family not supported by protocol ...^C 1378042634: mosquitto version 1.2 terminating 1378042634: Saving in-memory database to /tmp/mosquitto.db. The Mosquitto clients need to have access to a copy of the CA certificate ( ca.crt ) and you can transport that insecurely to your clients (it's a public certificate). mosquitto_pub --cafile ca.crt -h 127.0.0.1 -p 8883 ... That's it for the moment. Testing Once you've chosen an MQTT broker, make sure you feel comfortable with the utilities it provides to subscribe and publish to topics. We recommend the Mosquitto utilities for doing so. For example, to subscribe to all topics prefixed by owntracks on your broker: mosquitto_sub -h hostname -p 1883 -v -t 'owntracks/#' (Note that the hash symbol has to be quoted in the shell which is why we've put the whole topic branch in single quotes.) In another screen you could publish a test message: mosquitto_pub -h hostname -p 1883 -t 'owntracks/test' -m 'hello world' and in the first screen you'd see the topic name followed by a space and the message payload . Once you feel comfortable with what is going on, you should consider adding TLS . Bridging If you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up how you can bridge brokers . Logging Before doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening. Mosquitto typically logs via syslog , and syslog 's configuration defines where the log messages are actually written to. Your syslog may be called syslog , rsyslog , syslog-ng , or anything else for that matter. In case of doubt, check the files in /var/log ; one of them ought to have what you're looking for (e..g messages , syslog , localmessages , or even debugmessages ). Mosquitto typically logs each connection request, a publish, a subscribe request, etc. (Read the manpage for mosquitto.conf to learn how to configure logging. A successful publish of an OwnTracks location could look somewhat like this: mosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes)) mosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7) mosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7) mosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7) ACLs You will definitely want to set up Access Control Lists (ACLs) on your broker so that you can control who may see what. As an example, suppose Jane (username jjolie ) should be able to publish to her OwnTracks MQTT topics and Fred (username fred ) should be allowed to see Jane's location, we could configure something like this: user jjolie topic owntracks/jjolie/# user fred topic read owntracks/jjolie/5s topic owntracks/fred/nexus/# Firewall If you want to run your Private broker it's possibly going to be at home under your desk (or is it in your small office?). Be that as it may, how does an OwnTracks app reach (network-wise) that broker? Chances are you have some form of router which connects the local network in your home to the Internet. OwnTracks runs on the device which is in your pocket or your purse, or wherever you placed it, and it must be able to connect to your MQTT broker, but it cannot: your router hopefully has a firewall configured on it which will allow outgoing (from your home outwards) connections, but it is sure to not allow incoming connections. We must change that, at least for MQTT, and we're going to assume you've configured TLS, i.e. your broker is (also) listening on TCP port 8883 What you need to do to get this working is to reconfigure your router to allow incoming TCP traffic on port 8883 and to hand that off to the TCP/IP address of your MQTT broker. The exact details on how to do that vary from vendor to vendor, but a close look at the documentation of your router should show you how to do that. What is also likely, or at least possible, is that your home doesn't have a fixed TCP/IP address, but one which changes periodically. The OwnTracks apps won't be able to find your home then, will they? If you keep \"moving\" (i.e changing addresses). A service which is typically (if maybe incorrectly) called dynamic DNS comes to the rescue. These services allow you to configure a DNS name (e.g. freds-router.example.org ) which points to the changing IP address of your router. Once you've completed those steps, configure the OwnTracks apps to use the shiny new DNS name and TCP port number (8883) and you should be all set. OwnTracks So, you've configured your broker and you are familiar with the mosquitto command-line clients, so now it's time to see if you can get OwnTracks to speak to your broker .","title":"Broker"},{"location":"guide/broker/#mqtt-broker","text":"An MQTT broker is a service to which MQTT clients connect. These clients publish data to specific topics and they can subscribe to one or more topics to receive messages. A topic is like an \"address\" for a particular message. For example, a topic for a device that publishes a temperature reading of your living room may be temperature/indoors/living , whereas a device which publishes weather data could do so to weather/germany/frankfurt . In the particular case of OwnTracks, we use a topic branch called owntracks/username/device , but you can override that name if you prefer to. The reason we've chosen that structure is to accomodate friends and family on a single broker, taking into consideration that a particular user might have more than one device.","title":"MQTT broker"},{"location":"guide/broker/#private-broker","text":"You set up a private broker under your control. This sounds more difficult than it actually is, and there are some very nice brokers you can use free of charge on your own infrastructure. As an example, we've written up how to install Mosquitto on a Raspberry Pi.","title":"Private broker"},{"location":"guide/broker/#raspi","text":"The hardest bit is installing an OS, say, Raspbian Wheezy , onto an SD card, but there are many tutorials on how to do that. (Here's an example using Mac OS X .) A basic install will suffice, and after logging in with Raspbian's default username and password, we'll get started from there. Note that the current Raspbian Wheezy mosquitto package does NOT contain the mosquitto_passwd tool. If you want to use it, make sure you install the package from a mosquitto repo: Roger Light, Mosquitto 's creator has thankfully (!) set up a few Mosquitto repositories we can use to obtain the latest and greatest version, so we'll do just that. We first perform the required steps to add and activate the repository. The last step in particular can take a few moments. curl -O http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key sudo apt-key add mosquitto-repo.gpg.key rm mosquitto-repo.gpg.key cd /etc/apt/sources.list.d/ sudo curl -O http://repo.mosquitto.org/debian/mosquitto-$(awk -F\"[)(]+\" '/VERSION=/ {print $2}' /etc/os-release).list sudo apt-get update Now we can go ahead and install Mosquitto proper. There are three packages: mosquitto is the MQTT broker (i.e. server) mosquitto-clients are the command-line clients, which I recommend you install Don't install python-mosquitto ; if you want to do programming with Python and MQTT, we show you how to do so with the Paho Python module . sudo apt-get install mosquitto mosquitto-clients Regrettably, as with most Debian packages, the broker is immediately started; stop it. sudo /etc/init.d/mosquitto stop That concludes the installation of the Mosquitto MQTT broker, and we'll now proceed to its configuration. This section is geared towards a configuration of Mosquitto which will work well with OwnTracks. In particular we want the following features enabled by default: Connections to the broker must be authenticated either against user/password or using client certificates. Connections to the broker shall also be TLS protected. This requires a (server-side) TLS certificate and key which will be configured automatically. ACLs will restrict who may access what. To create a mosquitto user database, use sudo mosquitto_passwd -c /etc/mosquitto/passwd <username> . You will be prompted to enter a password. That will be the password required to connect to the server (with the username you chose). If you want to add more users, repeat the command without -c as that will create (i.e. overwrite) the passwd file. Add a config line password_file /etc/mosquitto/passwd to /etc/mosquitto/mosquitto.conf . If you want to use certificates to identify yourself to the broker and/or to TLS-encrypt the TCP session, we've got some utilities over at the OwnTracks repository which are going to automate this process for you. It's a work-in-progress (of course), but this is what sudo ./mosquitto-setup.sh looks like at the moment: Saving previous configuration as mosquitto.conf-20130901-133525 Generating a 2048 bit RSA private key .................................................................................................+++ ...............................+++ writing new private key to '/etc/mosquitto/ca.key' ----- Created CA certificate in /etc/mosquitto/ca.crt subject= commonName = An MQTT broker organizationName = MQTTitude.org emailAddress = nobody@example.net --- Creating server key and signing request Generating RSA private key, 2048 bit long modulus ............+++ ..............+++ e is 65537 (0x10001) --- Creating and signing server certificate Signature ok subject=/CN=raspberrypi/O=MQTTitude.org/emailAddress=nobody@example.net Getting CA Private Key A CA is created together with a server key-pair with a whole bunch of subjAltName settings: X509v3 Subject Alternative Name: IP Address:192.168.1.189, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1, DNS:broker.example.com, DNS:foo.example.de, DNS:localhost Check for a couple of broker settings in /etc/mosquitto/mosquitto.conf . Your mileage may vary, but you might want to set the following parameters: listener 1883 persistence_file mosquitto.db log_dest syslog log_dest stdout log_dest topic log_type error log_type warning log_type notice log_type information connection_messages true log_timestamp true allow_anonymous false password_file /etc/mosquitto/passwd Will it work? Let's start the broker manually to see what it says: sudo /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf 1378042632: mosquitto version 1.2 (build date 2013-08-09 21:49:03+0100) starting 1378042632: Config loaded from /etc/mosquitto/mosquitto.conf. 1378042632: Opening ipv4 listen socket on port 1883. 1378042632: Opening ipv4 listen socket on port 8883. 1378042632: Opening ipv6 listen socket on port 8883. 1378042632: Warning: Address family not supported by protocol ...^C 1378042634: mosquitto version 1.2 terminating 1378042634: Saving in-memory database to /tmp/mosquitto.db. The Mosquitto clients need to have access to a copy of the CA certificate ( ca.crt ) and you can transport that insecurely to your clients (it's a public certificate). mosquitto_pub --cafile ca.crt -h 127.0.0.1 -p 8883 ... That's it for the moment.","title":"RasPi"},{"location":"guide/broker/#testing","text":"Once you've chosen an MQTT broker, make sure you feel comfortable with the utilities it provides to subscribe and publish to topics. We recommend the Mosquitto utilities for doing so. For example, to subscribe to all topics prefixed by owntracks on your broker: mosquitto_sub -h hostname -p 1883 -v -t 'owntracks/#' (Note that the hash symbol has to be quoted in the shell which is why we've put the whole topic branch in single quotes.) In another screen you could publish a test message: mosquitto_pub -h hostname -p 1883 -t 'owntracks/test' -m 'hello world' and in the first screen you'd see the topic name followed by a space and the message payload . Once you feel comfortable with what is going on, you should consider adding TLS .","title":"Testing"},{"location":"guide/broker/#bridging","text":"If you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up how you can bridge brokers .","title":"Bridging"},{"location":"guide/broker/#logging","text":"Before doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening. Mosquitto typically logs via syslog , and syslog 's configuration defines where the log messages are actually written to. Your syslog may be called syslog , rsyslog , syslog-ng , or anything else for that matter. In case of doubt, check the files in /var/log ; one of them ought to have what you're looking for (e..g messages , syslog , localmessages , or even debugmessages ). Mosquitto typically logs each connection request, a publish, a subscribe request, etc. (Read the manpage for mosquitto.conf to learn how to configure logging. A successful publish of an OwnTracks location could look somewhat like this: mosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes)) mosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7) mosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7) mosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7)","title":"Logging"},{"location":"guide/broker/#acls","text":"You will definitely want to set up Access Control Lists (ACLs) on your broker so that you can control who may see what. As an example, suppose Jane (username jjolie ) should be able to publish to her OwnTracks MQTT topics and Fred (username fred ) should be allowed to see Jane's location, we could configure something like this: user jjolie topic owntracks/jjolie/# user fred topic read owntracks/jjolie/5s topic owntracks/fred/nexus/#","title":"ACLs"},{"location":"guide/broker/#firewall","text":"If you want to run your Private broker it's possibly going to be at home under your desk (or is it in your small office?). Be that as it may, how does an OwnTracks app reach (network-wise) that broker? Chances are you have some form of router which connects the local network in your home to the Internet. OwnTracks runs on the device which is in your pocket or your purse, or wherever you placed it, and it must be able to connect to your MQTT broker, but it cannot: your router hopefully has a firewall configured on it which will allow outgoing (from your home outwards) connections, but it is sure to not allow incoming connections. We must change that, at least for MQTT, and we're going to assume you've configured TLS, i.e. your broker is (also) listening on TCP port 8883 What you need to do to get this working is to reconfigure your router to allow incoming TCP traffic on port 8883 and to hand that off to the TCP/IP address of your MQTT broker. The exact details on how to do that vary from vendor to vendor, but a close look at the documentation of your router should show you how to do that. What is also likely, or at least possible, is that your home doesn't have a fixed TCP/IP address, but one which changes periodically. The OwnTracks apps won't be able to find your home then, will they? If you keep \"moving\" (i.e changing addresses). A service which is typically (if maybe incorrectly) called dynamic DNS comes to the rescue. These services allow you to configure a DNS name (e.g. freds-router.example.org ) which points to the changing IP address of your router. Once you've completed those steps, configure the OwnTracks apps to use the shiny new DNS name and TCP port number (8883) and you should be all set.","title":"Firewall"},{"location":"guide/broker/#owntracks","text":"So, you've configured your broker and you are familiar with the mosquitto command-line clients, so now it's time to see if you can get OwnTracks to speak to your broker .","title":"OwnTracks"},{"location":"guide/clients/","text":"Clients Using our OwnTracks app is cool, but what do you do with the location data the apps send (i.e. publish ) to the MQTT broker? We have some suggestions. You know that OwnTracks publishes location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called JSON , and this is what it looks like . When you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that. mosquitto_sub mosquitto_sub is a very basic command-line client provided by the Mosquitto project . However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with stdout pointing to a file. In it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in. mosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#' mosquitto_sub and it's counterpart, mosquitto_pub for publishing to a broker, support a slew of options. It'll be worth your while to study their manual page . Recorder We recommend our very own OwnTracks Recorder because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind. And the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well. Read more about the Recorder . mqttwarn You will recall the discussion on MQTT , and the analogy with the cauldron. On this matter, mqttwarn , while not specific to OwnTracks, is another client you can connect to your MQTT broker . We think it is worth mentioning, and both Ben and JP -- the creators -- are quite pleased with what it does. mqttwarn lets you do things like submitting a tweet each time OwnTracks reports a location (but do consider whether you really want that ;]), send an e-mail when a loved one enters a particular region, or use ntfy.sh to deliver a notification to your mobile phone, just to name a few examples of what is possible. Think of a self-hosted IFTTT or Zapier, but all that running on your premises, and a bit less enterprise. Technically speaking, mqttwarn is a highly configurable MQTT message router, where the routing targets are notification plugins, written in Python. mqttwarn currently supports well over 90 different notification services or providers. A picture says a thousand words. Enjoy exploring the mqttwarn documentation . openHAB Presence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action. This is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal MQTT broker where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in private mode , all your data is 'yours' and yours alone - there is no cloud service collecting, storing and potentially mining your data. Read more about openHAB and OwnTracks . Home Assistant Another home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal MQTT broker . It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4. See the demo for an example of the map with OwnTracks devices or read more about how Home Assistant connects to your private MQTT broker , how to enable OwnTracks support in Home Assistant and how to configure automations based on zones . OwnTracks-Cards This is a webapp to create and edit OwnTracks cards . It can be either used to just create the JSON representation of the card, which has to be published to the MQTT broker manually. Or it can directly publish the card to an MQTT broker connected via websockets. Just head over to the demo and create a card. Configure your MQTT broker by clicking the connection state. The source code can be found on Github . Roll your own If you feel really brave, you can write your own program which subscribes to OwnTracks data, but don't forget to tell us about it! Related Here are some projects we know of which use and/or integrate OwnTracks and/or which are useful when using MQTT in general or OwnTracks in particular. MQTT Inspector for iOS , written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT. the thing system ( code ) A Clojure webapp that aims to manage information gathered from OwnTracks; clojure-mqttitude-backend An OwnTracks flow by Giovanni @juzam Angoli for Node-RED which publishes messages to pushover.net upon entering or leaving a geo-fence. MyMQTT is an app for Android which enables you to subscribe and publish to an MQTT broker. Matthew Bordignon made a small Web page which uses Websockets to display the barometer reading published by OwnTracks for iOS. ( Screenshot .) PHP front & backend for OwnTracks payloads Orion, an alternative to OwnTracks Recorder with powerful visualization features ( server , web client , demo ) OwntracksOSM is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches ( screenshots ). From OwnTracks to QGIS , a solution to import OwnTracks data into QGIS. Magic Mirror module for displaying results from OpenTracks Prometheus OwnTracks Exporter hauk-snitch bridges OwnTracks and Hauk and makes it easy to share your current live location with other people for a given period of time. Just send them a link, all they need is a browser. mqottrace , written by Michael Staats is a Perl program which collects OwnTracks locations and stores them in an SQLite3 database; it also includes a tool to convert this data to GPX format.","title":"Clients"},{"location":"guide/clients/#clients","text":"Using our OwnTracks app is cool, but what do you do with the location data the apps send (i.e. publish ) to the MQTT broker? We have some suggestions. You know that OwnTracks publishes location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called JSON , and this is what it looks like . When you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that.","title":"Clients"},{"location":"guide/clients/#mosquitto_sub","text":"mosquitto_sub is a very basic command-line client provided by the Mosquitto project . However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with stdout pointing to a file. In it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in. mosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#' mosquitto_sub and it's counterpart, mosquitto_pub for publishing to a broker, support a slew of options. It'll be worth your while to study their manual page .","title":"mosquitto_sub"},{"location":"guide/clients/#recorder","text":"We recommend our very own OwnTracks Recorder because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind. And the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well. Read more about the Recorder .","title":"Recorder"},{"location":"guide/clients/#mqttwarn","text":"You will recall the discussion on MQTT , and the analogy with the cauldron. On this matter, mqttwarn , while not specific to OwnTracks, is another client you can connect to your MQTT broker . We think it is worth mentioning, and both Ben and JP -- the creators -- are quite pleased with what it does. mqttwarn lets you do things like submitting a tweet each time OwnTracks reports a location (but do consider whether you really want that ;]), send an e-mail when a loved one enters a particular region, or use ntfy.sh to deliver a notification to your mobile phone, just to name a few examples of what is possible. Think of a self-hosted IFTTT or Zapier, but all that running on your premises, and a bit less enterprise. Technically speaking, mqttwarn is a highly configurable MQTT message router, where the routing targets are notification plugins, written in Python. mqttwarn currently supports well over 90 different notification services or providers. A picture says a thousand words. Enjoy exploring the mqttwarn documentation .","title":"mqttwarn"},{"location":"guide/clients/#openhab","text":"Presence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action. This is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal MQTT broker where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in private mode , all your data is 'yours' and yours alone - there is no cloud service collecting, storing and potentially mining your data. Read more about openHAB and OwnTracks .","title":"openHAB"},{"location":"guide/clients/#home-assistant","text":"Another home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal MQTT broker . It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4. See the demo for an example of the map with OwnTracks devices or read more about how Home Assistant connects to your private MQTT broker , how to enable OwnTracks support in Home Assistant and how to configure automations based on zones .","title":"Home Assistant"},{"location":"guide/clients/#owntracks-cards","text":"This is a webapp to create and edit OwnTracks cards . It can be either used to just create the JSON representation of the card, which has to be published to the MQTT broker manually. Or it can directly publish the card to an MQTT broker connected via websockets. Just head over to the demo and create a card. Configure your MQTT broker by clicking the connection state. The source code can be found on Github .","title":"OwnTracks-Cards"},{"location":"guide/clients/#roll-your-own","text":"If you feel really brave, you can write your own program which subscribes to OwnTracks data, but don't forget to tell us about it!","title":"Roll your own"},{"location":"guide/clients/#related","text":"Here are some projects we know of which use and/or integrate OwnTracks and/or which are useful when using MQTT in general or OwnTracks in particular. MQTT Inspector for iOS , written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT. the thing system ( code ) A Clojure webapp that aims to manage information gathered from OwnTracks; clojure-mqttitude-backend An OwnTracks flow by Giovanni @juzam Angoli for Node-RED which publishes messages to pushover.net upon entering or leaving a geo-fence. MyMQTT is an app for Android which enables you to subscribe and publish to an MQTT broker. Matthew Bordignon made a small Web page which uses Websockets to display the barometer reading published by OwnTracks for iOS. ( Screenshot .) PHP front & backend for OwnTracks payloads Orion, an alternative to OwnTracks Recorder with powerful visualization features ( server , web client , demo ) OwntracksOSM is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches ( screenshots ). From OwnTracks to QGIS , a solution to import OwnTracks data into QGIS. Magic Mirror module for displaying results from OpenTracks Prometheus OwnTracks Exporter hauk-snitch bridges OwnTracks and Hauk and makes it easy to share your current live location with other people for a given period of time. Just send them a link, all they need is a browser. mqottrace , written by Michael Staats is a Perl program which collects OwnTracks locations and stores them in an SQLite3 database; it also includes a tool to convert this data to GPX format.","title":"Related"},{"location":"guide/scenarios/","text":"Scenarios There are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the technical terminology handy. There is a bit of stuff you have to learn about in order to use OwnTracks: MQTT brokers , topics , but the upside is that you get to use many of the neat features MQTT mode or HTTP mode come with. For example, you can set up friends . HTTP mode If you don't want to go to the trouble of hosting your own MQTT setup, you can use HTTP mode to publish location data to a HTTP server of your chosing , and you can also use our Recorder for doing so. MQTT mode This is where you say adios! (or whatever you say in your language when you leave) to us, continue to use our app (still free of charge of course -- it's Open Source), and host everything yourself. And to be honest, that's precisely what we think you should do so that you only (and the people you authorize) see where you are. That is the Own in OwnTracks: it's your own data and you only should see it. In MQTT mode you're on your own: you set up and configure your MQTT broker , you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up. What you basically have to do is to set up an MQTT broker Optionally use existing clients to consume OwnTracks data Possibly dig in and write your own client and do really cool stuff! We urge you to resist the temptation of using MQTT mode with one of the many public brokers hosted by different organizations. While it is an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy. If you need assistance, we may be able to help you on our Talk site. You will now want to configure a client with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not write your own client ? Now it's time to discuss topics .","title":"Scenarios"},{"location":"guide/scenarios/#scenarios","text":"There are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the technical terminology handy. There is a bit of stuff you have to learn about in order to use OwnTracks: MQTT brokers , topics , but the upside is that you get to use many of the neat features MQTT mode or HTTP mode come with. For example, you can set up friends .","title":"Scenarios"},{"location":"guide/scenarios/#http-mode","text":"If you don't want to go to the trouble of hosting your own MQTT setup, you can use HTTP mode to publish location data to a HTTP server of your chosing , and you can also use our Recorder for doing so.","title":"HTTP mode"},{"location":"guide/scenarios/#mqtt-mode","text":"This is where you say adios! (or whatever you say in your language when you leave) to us, continue to use our app (still free of charge of course -- it's Open Source), and host everything yourself. And to be honest, that's precisely what we think you should do so that you only (and the people you authorize) see where you are. That is the Own in OwnTracks: it's your own data and you only should see it. In MQTT mode you're on your own: you set up and configure your MQTT broker , you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up. What you basically have to do is to set up an MQTT broker Optionally use existing clients to consume OwnTracks data Possibly dig in and write your own client and do really cool stuff! We urge you to resist the temptation of using MQTT mode with one of the many public brokers hosted by different organizations. While it is an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy. If you need assistance, we may be able to help you on our Talk site. You will now want to configure a client with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not write your own client ? Now it's time to discuss topics .","title":"MQTT mode"},{"location":"guide/topics/","text":"Topics If you use HTTP mode skip this chapter. You now know that MQTT is a messaging protocol, and that it uses topic names to label messages. topic names can be structured into multiple topic levels by separating them with a forward slash ( / ). topic levels are UTF-8 text strings, and almost any character is valid except / , * , and + . The last two are used to address sets of topic names. The principles during the design of the OwnTracks topic-naming scheme were human readability traffic minimization granular access control topic name Root Typically an MQTT broker hosts multiple applications. To create a separate name space for OwnTracks we use a topic name root as the beginning of a topic name. Per default this is owntracks/ , but you may choose any other root (e.g. peters/locations/ ) or, if you prefer, the empty string. In order to change the default behaviour of owntracks/ create a personalized configuration from scratch or, export your current configuration, edit that and re-import to your device. On Android you trigger the import function by opening the .otrc file in a file manager; on iOS by, say, opening the file in Mail, Dropbox or similar app. The settings which have to be changed are pubTopicBase subTopic Device name Locations are captured in OwnTracks by devices (e.g. your Smartphone). The device name forms the second component of the topic name. In order to avoid clashes in naming and to simplify subscription and authorization we decided to use two topic levels The user name or identifier (e.g. peter ) The device name (e.g. iPhone ) A typical topic name for a device would therefore be peter/iPhone . Other device naming schemes are possible and transparent to OwnTracks (e.g. using just one level peters-iPhone or multiple levels aFamily/father/iPhone ), but under any one OwnTracks name root the number of levels used for device names have to be the same. Base topic name Combining the topic name root and the device name result in what we call base topic name for each device (e.g. owntracks/peter/iPhone ). The devices label their location messages with the base topic name when publishing to the MQTT broker. Subscribing to location Messages Given the structure explained above, the topic filter you can use to subscribe to the location messages of all devices is owntracks/+/+ (the topic name root plus a so-called wild card ( + ) for each level of the device name. Additional topic names For additional communication from and to devices, OwnTracks uses topic names relative to the base topic name. Devices listen to the relative topic name cmd for commands you can publish to OwnTracks devices (i.e. owntracks/peter/iPhone/cmd ). For example, if authorized, you could request a location update from a friend's device by publishing an appropriate payload to said topic. The output of specific OwnTracks commands is published by the device to the relative topic names step , dump , etc. In addition, devices subscribe to the relative topic name info for information about other devices. Messages published with the relative topic name info (e.g. owntracks/peter/iPhone/info ) contain a card payload -- the name and avatar of a user with which authorized users can identify, say, Peter within their OwnTracks app. Devices publish their waypoints to the relative topic name waypoint and the corresponding events the transition into or out of a waypoint triggers, to the relative topic name event . Summary A device (named peter/iPhone in this example) is connected to an MQTT Broker with the OwnTracks name Root owntracks . It publishes location messages labeled with the topic name owntracks/peter/iPhone . The same device publishes waypoints labeled as owntracks/peter/iPhone/waypoint and publishes to owntracks/peter/iPhone/event when entering or leaving a waypoint (i.e. a monitored region). The same device subscribes to owntracks/+/+ to receive location messages of all other devices it is authorized for which are connected to the same MQTT broker. In addition, the device may listen to owntracks/+/+/event if the user of the devices wants to be informed about other users entering or leaving monitored regions. Subscribing to owntracks/+/+/info gives the device access to additional information about the other devices. If a device's owner allows other users to ad-hoc request messages from his device, the device will subscribe to owntracks/peter/iPhone/cmd as well, and it will listen for OwnTracks commands; responses to these commands will be published and labeled owntracks/peter/iPhone/dump , owntracks/peter/iPhone/step , etc. A full set of supported topic names and expected payloads is documented in our JSON API . Terms used topic name OwnTracks topic name root OwnTracks device name OwnTracks base topic name relative topic names OwnTracks device OwnTracks user OwnTracks command","title":"Topics"},{"location":"guide/topics/#topics","text":"If you use HTTP mode skip this chapter. You now know that MQTT is a messaging protocol, and that it uses topic names to label messages. topic names can be structured into multiple topic levels by separating them with a forward slash ( / ). topic levels are UTF-8 text strings, and almost any character is valid except / , * , and + . The last two are used to address sets of topic names. The principles during the design of the OwnTracks topic-naming scheme were human readability traffic minimization granular access control","title":"Topics"},{"location":"guide/topics/#topic-name-root","text":"Typically an MQTT broker hosts multiple applications. To create a separate name space for OwnTracks we use a topic name root as the beginning of a topic name. Per default this is owntracks/ , but you may choose any other root (e.g. peters/locations/ ) or, if you prefer, the empty string. In order to change the default behaviour of owntracks/ create a personalized configuration from scratch or, export your current configuration, edit that and re-import to your device. On Android you trigger the import function by opening the .otrc file in a file manager; on iOS by, say, opening the file in Mail, Dropbox or similar app. The settings which have to be changed are pubTopicBase subTopic","title":"topic name Root"},{"location":"guide/topics/#device-name","text":"Locations are captured in OwnTracks by devices (e.g. your Smartphone). The device name forms the second component of the topic name. In order to avoid clashes in naming and to simplify subscription and authorization we decided to use two topic levels The user name or identifier (e.g. peter ) The device name (e.g. iPhone ) A typical topic name for a device would therefore be peter/iPhone . Other device naming schemes are possible and transparent to OwnTracks (e.g. using just one level peters-iPhone or multiple levels aFamily/father/iPhone ), but under any one OwnTracks name root the number of levels used for device names have to be the same.","title":"Device name"},{"location":"guide/topics/#base-topic-name","text":"Combining the topic name root and the device name result in what we call base topic name for each device (e.g. owntracks/peter/iPhone ). The devices label their location messages with the base topic name when publishing to the MQTT broker.","title":"Base topic name"},{"location":"guide/topics/#subscribing-to-location-messages","text":"Given the structure explained above, the topic filter you can use to subscribe to the location messages of all devices is owntracks/+/+ (the topic name root plus a so-called wild card ( + ) for each level of the device name.","title":"Subscribing to location Messages"},{"location":"guide/topics/#additional-topic-names","text":"For additional communication from and to devices, OwnTracks uses topic names relative to the base topic name. Devices listen to the relative topic name cmd for commands you can publish to OwnTracks devices (i.e. owntracks/peter/iPhone/cmd ). For example, if authorized, you could request a location update from a friend's device by publishing an appropriate payload to said topic. The output of specific OwnTracks commands is published by the device to the relative topic names step , dump , etc. In addition, devices subscribe to the relative topic name info for information about other devices. Messages published with the relative topic name info (e.g. owntracks/peter/iPhone/info ) contain a card payload -- the name and avatar of a user with which authorized users can identify, say, Peter within their OwnTracks app. Devices publish their waypoints to the relative topic name waypoint and the corresponding events the transition into or out of a waypoint triggers, to the relative topic name event .","title":"Additional topic names"},{"location":"guide/topics/#summary","text":"A device (named peter/iPhone in this example) is connected to an MQTT Broker with the OwnTracks name Root owntracks . It publishes location messages labeled with the topic name owntracks/peter/iPhone . The same device publishes waypoints labeled as owntracks/peter/iPhone/waypoint and publishes to owntracks/peter/iPhone/event when entering or leaving a waypoint (i.e. a monitored region). The same device subscribes to owntracks/+/+ to receive location messages of all other devices it is authorized for which are connected to the same MQTT broker. In addition, the device may listen to owntracks/+/+/event if the user of the devices wants to be informed about other users entering or leaving monitored regions. Subscribing to owntracks/+/+/info gives the device access to additional information about the other devices. If a device's owner allows other users to ad-hoc request messages from his device, the device will subscribe to owntracks/peter/iPhone/cmd as well, and it will listen for OwnTracks commands; responses to these commands will be published and labeled owntracks/peter/iPhone/dump , owntracks/peter/iPhone/step , etc. A full set of supported topic names and expected payloads is documented in our JSON API .","title":"Summary"},{"location":"guide/topics/#terms-used","text":"topic name OwnTracks topic name root OwnTracks device name OwnTracks base topic name relative topic names OwnTracks device OwnTracks user OwnTracks command","title":"Terms used"},{"location":"guide/waypoints/","text":"Waypoints If you've configured a geo-fence, a location message will contain the elements: rad ius (if its value is greater than 0): unit: meters desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. If you set up a waypoint, the app publishes that waypoint (without the retain flag, irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . When you set up a waypoint (with a desc ription and a rad ius), this waypoint is published to the broker with the current time stamp. If you update the waypoint definition on the device at a later stage, the waypoint is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius. To be precise, the tst timestamp is used as an identifier of the waypoint even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting waypoints by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.","title":"Waypoints"},{"location":"guide/waypoints/#waypoints","text":"If you've configured a geo-fence, a location message will contain the elements: rad ius (if its value is greater than 0): unit: meters desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. If you set up a waypoint, the app publishes that waypoint (without the retain flag, irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . When you set up a waypoint (with a desc ription and a rad ius), this waypoint is published to the broker with the current time stamp. If you update the waypoint definition on the device at a later stage, the waypoint is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius. To be precise, the tst timestamp is used as an identifier of the waypoint even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting waypoints by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.","title":"Waypoints"},{"location":"guide/whathow/","text":"What OwnTracks does The OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other things we'll discuss in a moment). We'd like you to read this bit again: waits for the smart phone to tell it that the device has moved It is very important to understand that OwnTracks literally waits for the device's operating system to inform it of a movement; only then can OwnTracks react and do something. To make matters even more complicated 1 , OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing. That's basically all OwnTracks does. More That last sentence isn't true. Strike it. OwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and that of your friends on a map. Ah: better. It can also detect when you enter or leave a particular region for which you set a so-called waypoint . People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.) OwnTracks also has a pedometer, a.k.a. step counter (on iPhone 5S, 6) which you can query remotely. OwnTracks has support for iBeacons , and it gives you neat notifications when one of your friends gets home so you can phone them over a land-line to plan a get-together. OwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.) And finally, though for us this is very important, OwnTracks does all this securely. How OwnTracks works The OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's moved a significant distance 2 , it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \" hey, I'm here \", whereby \" here \" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server. This last server is called a broker and the contact is made with an open, lightweight, standardized protocol called MQTT . (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called publish in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is something you provide. Instead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server. Above: the general architecture of OwnTracks The broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend, to a program which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later. The important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's yours . We'll now cover the two scenarios . and believe us, they are complicated \u21a9 This is a relative amount, but you can tune it a bit. \u21a9","title":"What it does"},{"location":"guide/whathow/#what-owntracks-does","text":"The OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other things we'll discuss in a moment). We'd like you to read this bit again: waits for the smart phone to tell it that the device has moved It is very important to understand that OwnTracks literally waits for the device's operating system to inform it of a movement; only then can OwnTracks react and do something. To make matters even more complicated 1 , OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing. That's basically all OwnTracks does.","title":"What OwnTracks does"},{"location":"guide/whathow/#more","text":"That last sentence isn't true. Strike it. OwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and that of your friends on a map. Ah: better. It can also detect when you enter or leave a particular region for which you set a so-called waypoint . People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.) OwnTracks also has a pedometer, a.k.a. step counter (on iPhone 5S, 6) which you can query remotely. OwnTracks has support for iBeacons , and it gives you neat notifications when one of your friends gets home so you can phone them over a land-line to plan a get-together. OwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.) And finally, though for us this is very important, OwnTracks does all this securely.","title":"More"},{"location":"guide/whathow/#how-owntracks-works","text":"The OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's moved a significant distance 2 , it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \" hey, I'm here \", whereby \" here \" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server. This last server is called a broker and the contact is made with an open, lightweight, standardized protocol called MQTT . (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called publish in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is something you provide. Instead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server. Above: the general architecture of OwnTracks The broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend, to a program which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later. The important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's yours . We'll now cover the two scenarios . and believe us, they are complicated \u21a9 This is a relative amount, but you can tune it a bit. \u21a9","title":"How OwnTracks works"},{"location":"tech/http/","text":"HTTP An optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all JSON payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads. The URL you enter in the setting for HTTP mode has the following syntax: http[s]://[user[:password]@]host[:port]/path Authentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS ( https:// scheme). The encryption feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself. The Recorder supports HTTP mode out of the box at the /pub end point, as long as it is built with HTTP support and a --http-port is configured. When using Recorder in this mode, set the URL to: http[s]://recorder_host[:port]/pub The username and password for HTTP Basic authentication can be configured in application settings, under Identification . Device name and tracker name can also be configured there. Username and device name are required when using the Recorder. Parameters for username and devicename can also be included in the URL ( ?u=user&d=device ), or alternatively using the X-Limit-U and X-Limit-D headers respectively. You can also force username using a proxy as described in the Recorder's documentation. All publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same JSON payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.) If the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code ( 2xx ) is returned the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time. If the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array [] . It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid _type as described in JSON . Support for the following _type is implemented: _type iOS Android Usage location Y Y Can return friend location objects. cmd Y Y with action set to dump , reportLocation , reportSteps , action , and setWaypoints card Y Y Can return card objects for self and friends transition Y Y Obtain friends' transition events. Distinguishing payloads When a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from: On iOS, a new topic key is added to the payload if the payload is unencrypted. If the payload is encrypted, the topic key is only available in the decrypted payload. Both the Android and iOS apps (iOS after #560 is implemented) include headers to identify the user ( X-Limit-U ) and the device ( X-Limit-D ) if the user has entered this information in the \"Identification\" section of the connection settings. Content-Type: application/json X-Limit-U: jjolie X-Limit-D: myphone PHP example Using a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table: mysql> select * from locations; +---------------------+------+-----------+----------+ | dt | tid | lat | lon | +---------------------+------+-----------+----------+ | 2016-02-20 09:16:05 | JJ | 48.858330 | 2.295130 | | 2016-02-20 09:19:49 | JJ | 48.860430 | 2.294010 | +---------------------+------+-----------+----------+ For the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a tst timestamp when the event actually occurred. <?php # Obtain the JSON payload from an OwnTracks app POSTed via HTTP # and insert into database table. header(\"Content-type: application/json\"); $payload = file_get_contents(\"php://input\"); $data = @json_decode($payload, true); if ($data['_type'] == 'location') { # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6)); $mysqli = new mysqli(\"127.0.0.1\", \"user\", \"password\", \"database\"); $tst = $data['tst']; $lat = $data['lat']; $lon = $data['lon']; $tid = $data['tid']; # Convert timestamp to a format suitable for mysql $dt = date('Y-m-d H:i:s', $tst); $sql = \"INSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?)\"; $stmt = $mysqli->prepare($sql); # bind parameters (s = string, i = integer, d = double, b = blob) $stmt->bind_param('ssdd', $dt, $tid, $lat, $lon); $stmt->execute(); $stmt->close(); } $response = array(); # optionally add objects to return to the app (e.g. # friends or cards) print json_encode($response); ?> Assuming the Web server hosting this example is called example.com , and assuming the above script is in Jane's home directory's public_html saved as loc.php , the URL you configure in the OwnTracks app would be http://example.com/~jane/loc.php . We urge you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of https://user:password@example.com/~jane/loc.php . There's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you study the API documentation . Testing your HTTP endpoint An simple example for testing a HTTP endpoint you set up: #!/bin/sh user=jane device=phone payload=$(jo _type=location \\ t=u \\ batt=11 \\ lat=48.856826 \\ lon=2.292713 \\ tid=JJ \\ tst=$(date +%s) \\ topic=\"owntracks/$user/$device\") curl --data \"${payload}\" http://127.0.0.1:8085/pub?u=${user}&d=${device} see also: Traccar","title":"HTTP"},{"location":"tech/http/#http","text":"An optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all JSON payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads. The URL you enter in the setting for HTTP mode has the following syntax: http[s]://[user[:password]@]host[:port]/path Authentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS ( https:// scheme). The encryption feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself. The Recorder supports HTTP mode out of the box at the /pub end point, as long as it is built with HTTP support and a --http-port is configured. When using Recorder in this mode, set the URL to: http[s]://recorder_host[:port]/pub The username and password for HTTP Basic authentication can be configured in application settings, under Identification . Device name and tracker name can also be configured there. Username and device name are required when using the Recorder. Parameters for username and devicename can also be included in the URL ( ?u=user&d=device ), or alternatively using the X-Limit-U and X-Limit-D headers respectively. You can also force username using a proxy as described in the Recorder's documentation. All publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same JSON payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.) If the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code ( 2xx ) is returned the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time. If the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array [] . It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid _type as described in JSON . Support for the following _type is implemented: _type iOS Android Usage location Y Y Can return friend location objects. cmd Y Y with action set to dump , reportLocation , reportSteps , action , and setWaypoints card Y Y Can return card objects for self and friends transition Y Y Obtain friends' transition events.","title":"HTTP"},{"location":"tech/http/#distinguishing-payloads","text":"When a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from: On iOS, a new topic key is added to the payload if the payload is unencrypted. If the payload is encrypted, the topic key is only available in the decrypted payload. Both the Android and iOS apps (iOS after #560 is implemented) include headers to identify the user ( X-Limit-U ) and the device ( X-Limit-D ) if the user has entered this information in the \"Identification\" section of the connection settings. Content-Type: application/json X-Limit-U: jjolie X-Limit-D: myphone","title":"Distinguishing payloads"},{"location":"tech/http/#php-example","text":"Using a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table: mysql> select * from locations; +---------------------+------+-----------+----------+ | dt | tid | lat | lon | +---------------------+------+-----------+----------+ | 2016-02-20 09:16:05 | JJ | 48.858330 | 2.295130 | | 2016-02-20 09:19:49 | JJ | 48.860430 | 2.294010 | +---------------------+------+-----------+----------+ For the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a tst timestamp when the event actually occurred. <?php # Obtain the JSON payload from an OwnTracks app POSTed via HTTP # and insert into database table. header(\"Content-type: application/json\"); $payload = file_get_contents(\"php://input\"); $data = @json_decode($payload, true); if ($data['_type'] == 'location') { # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6)); $mysqli = new mysqli(\"127.0.0.1\", \"user\", \"password\", \"database\"); $tst = $data['tst']; $lat = $data['lat']; $lon = $data['lon']; $tid = $data['tid']; # Convert timestamp to a format suitable for mysql $dt = date('Y-m-d H:i:s', $tst); $sql = \"INSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?)\"; $stmt = $mysqli->prepare($sql); # bind parameters (s = string, i = integer, d = double, b = blob) $stmt->bind_param('ssdd', $dt, $tid, $lat, $lon); $stmt->execute(); $stmt->close(); } $response = array(); # optionally add objects to return to the app (e.g. # friends or cards) print json_encode($response); ?> Assuming the Web server hosting this example is called example.com , and assuming the above script is in Jane's home directory's public_html saved as loc.php , the URL you configure in the OwnTracks app would be http://example.com/~jane/loc.php . We urge you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of https://user:password@example.com/~jane/loc.php . There's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you study the API documentation .","title":"PHP example"},{"location":"tech/http/#testing-your-http-endpoint","text":"An simple example for testing a HTTP endpoint you set up: #!/bin/sh user=jane device=phone payload=$(jo _type=location \\ t=u \\ batt=11 \\ lat=48.856826 \\ lon=2.292713 \\ tid=JJ \\ tst=$(date +%s) \\ topic=\"owntracks/$user/$device\") curl --data \"${payload}\" http://127.0.0.1:8085/pub?u=${user}&d=${device} see also: Traccar","title":"Testing your HTTP endpoint"},{"location":"tech/json/","text":"Types OwnTracks publishes its message payloads in JSON format. The different payload types are identified by a mandatory _type element. Depending on the app platform, different payload types are supported. _type iOS Android beacon Y N card Y Y cmd Y Y configuration Y Y encrypted Y Y location Y Y lwt Y Y steps Y N transition Y Y waypoint Y Y waypoints Y Y Topics In MQTT mode the apps publish to: owntracks/user/device with _type=location for location updates, and with _type=lwt owntracks/user/device/cmd with _type=cmd for remote commands owntracks/user/device/event with _type=transition for enter/leave events owntracks/user/device/step to report step counter owntracks/user/device/beacon for beacon ranging owntracks/user/device/dump for config dumps In MQTT mode apps subscribe to: owntracks/user/device/cmd if remote commands are enabled owntracks/+/+ for seeing other user's locations, depending on broker ACL owntracks/+/+/event for transition messages ( enter / leave ) owntracks/+/+/info for obtaining cards . In HTTP mode the apps POST their data to a single endpoint you configure. _type=location This location object describes the location of the device that reported it. { \"_type\" : \"location\", elements } acc Accuracy of the reported location in meters without unit (iOS,Android/integer/meters/optional) alt Altitude measured above sea level (iOS,Android/integer/meters/optional) batt Device battery level (iOS,Android/integer/percent/optional) bs Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full (iOS, Android) cog Course over ground (iOS/integer/degree/optional) lat latitude (iOS,Android/float/degree/required) lon longitude (iOS,Android/float/degree/required) rad radius around the region when entering/leaving (iOS/integer/meters/optional) t trigger for the location report (iOS,Android/string/optional) p ping issued randomly by background task (iOS,Android) c circular region enter/leave event (iOS,Android) b beacon region enter/leave event (iOS) r response to a reportLocation cmd message (iOS,Android) u manual publish requested by the user (iOS,Android) t timer based publish in move move (iOS) v updated by Settings/Privacy/Locations Services/System Services/Frequent Locations monitoring (iOS) tid Tracker ID used to display the initials of a user (iOS,Android/string/optional) required for http mode tst UNIX epoch timestamp in seconds of the location fix (iOS,Android/integer/epoch/required) vac vertical accuracy of the alt element (iOS/integer/meters/optional) vel velocity (iOS,Android/integer/kmh/optional) p barometric pressure (iOS/float/kPa/optional/extended data) poi point of interest name (iOS/string/optional) conn Internet connectivity status (route to host) when the message is created (iOS,Android/string/optional/extended data) w phone is connected to a WiFi connection (iOS,Android) o phone is offline (iOS,Android) m mobile data (iOS,Android) tag name of the tag (iOS/string/optional) topic (only in HTTP payloads) contains the original publish topic (e.g. owntracks/jane/phone ). (iOS,Android >= 2.4,string) inregions contains a list of regions the device is currently in (e.g. [\"Home\",\"Garage\"] ). Might be empty. (iOS,Android/list of strings/optional) inrids contains a list of region IDs the device is currently in (e.g. [\"6da9cf\",\"3defa7\"] ). Might be empty. (iOS,Android/list of strings/optional) SSID , if available, is the unique name of the WLAN. (iOS,string/optional) BSSID , if available, identifies the access point. (iOS,string/optional) created_at identifies the time at which the message is constructed (vs. tst which is the timestamp of the GPS fix) (iOS,Android) m identifies the monitoring mode at which the message is constructed ( significant = 1 , move = 2 ) (iOS/integer/optional) Notes The tst in a ping is a current timestamp , so that it doesn't look like a duplicate. The tid defaults to the last two characters of the topic A missing t element also indicates an automatic location update A publish of \"_type\": \"location\" with a \"b\" trigger is sent when an iOS device enters or leaves a beacon in addition to a \"_type\": \"transition\" : if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated. The acc , alt , cog , vac , vel elements are only added if they are not zero Some Android devices always return 0 for alt or vel Elements marked with extended data are only added if extendedData=true is configured Greenwich The OwnTracks edition of the Choral Greenwich device reports the following additional elements in a _type=location message: { \"_type\": \"location\", elements } alt Altitude measured above sea level (integer/meters/optional) batt Device battery level (integer/percent/optional) cog Course over ground (integer/degree/optional) dist Distance travelled since the last location report (integer/meters/optional) trip Distance travelled since the last reboot (integer/meters/optional) vel velocity (integer/kmh/optional) t trigger for the location report (string/optional) f First publish after reboot m Manually requested locations (e.g. by publishing to /cmd ) t Time for location published because device is moving. T Time for location published because of time passed while device is stationary ( maxInterval ) k Transitioning from move to stationary (park) v Transitioning from stationary to move (mo-v-e) l Last known position when device lost GPS fix L Last known position before gracefull shutdown Notes The device can be configured to produce or not produce fields marked as optional Queclink OwnTracks works with a selection of trackers by Queclink , for which the protocol conversion is done via qtripp . Queclink devices report the following additional elements in a _type=location message: { \"_type\": \"location\", elements } t trigger for the location report (string/optional) o Corner M Mileage ! Tow or fake tow or sensor without ignition a motionless (aka park) i ignition on I ignition off e external power off E external power ON 1 Devices powered up 2 Battery stop charging 3 Battery start charging 9 Battery power low h harsh behavior s speed alarm odometer total distance of the device (float/kilometers/optional) hmc total hours of operation (float/seconds/optional) ubatt voltage of the battery (float/volts/optional) uext voltage of the external power source (float/volts/optional) vin vehicle identification number (string/optional) imei identification number (string/optional) name vehicle name (string/optional) don is duration since ignition on (float/seconds/optional) doff is duration since ignition off (float/seconds/optional) aiv is analog input voltage (float/volts/optional) rpm is engine rounds per minute (float/rounds per minute/optional) fcon is fuel consumption (float/L per 100km/optional) flvl is fuel level (float/percent/optional) anum is number of analog inputs (integer/optional) adid-xx is id of analog input number xx (string/optional) adty-xx is type of analog input number xx (string/optional) adda-xx is data of analog input number xx (string/optional) temp_c-xx is temperature of analog input number xx (float/celsius/optional) can is can data (string/optional) din1 is status of digital input 1 (boolean/optional) din2 is status of digital input 2 (boolean/optional) dout1 is status of digital output 1 (boolean/optional) dout2 is status of digital output 2 (boolean/optional) ign is status of ignition (boolean/optional) motion is motion status (boolean/optional) tow is status of tow sensor (boolean/optional) fake is status of fake tow sensor (boolean/optional) sens is status of motion sensor (boolean/optional) sent is epoch when message was sent (integer/epoch/optional) mcc is mobile country code (integer/optional) mnc is mobile network code (integer/optional) lac is location area code (string/optional) cid is cell id (string/optional) nmds is non movement detection status (boolean/optional) rit queclink record id and type (integer/optional) rty queclink record type (integer/optional) rid queclink record id (integer/optional) mst queclink motion state (integer/optional) count is counter of message (string/optional) raw_line raw data (string/optional) counter number of ignored positions (integer/optional) ignored indicates counter positions have been ignored (boolean/optional) Notes The device can be configured to produce or not produce fields marked as optional _type=lwt A last will and testament is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this: { \"_type\":\"lwt\", elements } tst UNIX epoch timestamp at which the app first connected (iOS,Android/integer/epoch/required) _type=waypoint Waypoints / regions denote specific geographical regions that you want to keep track of. You define a region in the OwnTracks app, and OwnTracks publishes this waypoint to the topic branch ../waypoint (singular). OwnTracks also monitors these waypoints and will publish {_type: \"transition\", ...} message when entering or leaving the region. A waypoint may also define a BLE Beacon instead of a geographical region. { \"_type\" : \"waypoint\", elements } desc Name of the waypoint that is included in the sent transition message, copied into the location message inregions array when a current position is within a region. (iOS,Android,string/required) lat Latitude (iOS,Android/float/meters/optional) lon Longitude (iOS,Android/float/meters/optional) rad Radius around the latitude and longitude coordinates (iOS,Android/integer/meters/optional) tst Timestamp of creation of region, copied into the wtst element of the transition message (iOS,Android/integer/epoch/required) uuid UUID of the BLE Beacon (iOS/string/optional) major Major number of the BLE Beacon (iOS/integer/optional) minor Minor number of the BLE Beacon_(iOS/integer/optional)_ rid region ID, created automatically, copied into the location payload inrids array (iOS/string)_ Notes In iOS version >= 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the desc element. If lat , lon and rad elements are present, transition messages are sent when entering and leaving the geographical region If uuid , major , minor elements are present, BLE becons with that specifications are monitored Beacons and Geographical regions can be defined together Waypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage. Waypoints are sent to the broker and transition messages contain a desc and event element. _type=transition A transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained. { \"_type\": \"transition\", elements } wtst Timestamp of waypoint creation (iOS,Android/integer/epoch/required) lat Latitude at which the event occured (iOS,Android/float/meters/optional) lon Longitue at which the event occured (iOS,Android/float/meters/optional) tst Timestamp at which the event occured (iOS,Android/integer/epoch/required) acc Accuracy of the geographical coordinates (iOS,Android/float/meters/required) tid Tracker ID of the waypoint (iOS/string/none/optional) event Event that triggered the transition (iOS,Android/string/required) enter The device entered the defined geographical region or BLE Beacon range (iOS) leave The device left the defined geographical region or BLE Beacon range (iOS) desc Name of the waypoint (iOS,Android/string/optional) tid TrackerID required in http mode. t Trigger of the event (iOS,Android/string/optional) c Circular geographical region (iOS, Android) b BLE Beacon (iOS) l Loction update (Android) rid Region ID (iOS/Android, after January 2021) _type=configuration The device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages. { \"_type\": \"configuration\", elements } allowRemoteLocation Respond to reportLocation cmd message (iOS/boolean) allowinvalidcerts disable TLS certificate checks insecure (iOS/boolean) auth Use username and password for endpoint authentication (iOS,Android/boolean) autostartOnBoot Autostart the app on device boot (Android/boolean) cleanSession MQTT endpoint clean session (iOS,Android/boolean) clientId client id to use for MQTT connect. Defaults to \" user deviceId \" (iOS,Android/string) clientpkcs Name of the client pkcs12 file (iOS/string) cmd Respond to cmd messages (iOS,Android/boolean) deviceId id of the device used for pubTopicBase and clientId construction. Defaults to the os name of the device (iOS,Android/string) downgrade battery level below which to downgrade monitoring from move mode (iOS/integer/percent/optional) extendedData Add extended data attributes to location messages (iOS,Android/boolean) host MQTT endpoint host (iOS,Android/string) ignoreInaccurateLocations Location accuracy below which reports are supressed (iOS,Android/integer/meters) ignoreStaleLocations Number of days after which location updates are assumed stale (iOS,Android/integer/days) keepalive MQTT endpoint keepalive (iOS,Android/integer/seconds) locatorDisplacement maximum distance between location source updates (iOS,Android/integer/meters) locatorInterval maximum interval between location source updates (iOS,Android/integer/seconds) locatorPriority source/power setting for location updates (Android/integer/) 0 NO_POWER / best accuracy possible with zero additional power consumption (Android) 1 LOW_POWER / city level accuracy (Android) 2 BALANCED_POWER / block level accuracy based on Wifi/Cell (Android) 3 HIGH_POWER / most accurate accuracy based on GPS (Android) locked Locks settings screen on device for editing (iOS/boolean) maxHistory Number of notifications to store historically. Zero (0) means no notifications are stored and history tab is hidden. Defaults to zero. (iOS/integer) mode Endpoint protocol mode (iOS,Android/integer) 0 Private MQTT (iOS, Android) 3 Private HTTP (iOS, Android) monitoring Location reporting mode (iOS,Android/integer) -1 Quiet 0 Manual 1 Significant 2 Move mqttProtocolLevel MQTT broker protocol level (iOS,Android/integer) 3 MQTT 3 (default) 4 MQTT 3.1.1 5 MQTT 5 (iOS only) notificationLocation Show last reported location in ongoing notification (Android/boolean) opencageApiKey API key for alternate Geocoding provider. See https://opencagedata.com/ for details. (Android/string) passphrase Passphrase of the client pkcs12 file (iOS/string) password Endpoint password (iOS,Android/string) ping Interval in which location messages of with t : p are reported (Android/integer) port MQTT endpoint port (iOS,Android/integer) positions Number of locations to keep and display (iOS/integer) pubTopicBase MQTT topic base to which the app publishes; %u is replaced by the user name, %d by device (iOS,Android/string) pubRetain MQTT retain flag for reported messages (iOS,Android/boolean) pubQos MQTT QoS level for reported messages (iOS,Android/integer) ranging Beacon ranging (iOS/boolean) remoteConfiguration Allow remote configuration by sending a setConfiguration cmd message (Android/boolean) servercer Blank separated list of certificate file names in DER format (iOS/string) sub subscribe to subTopic via MQTT (iOS,Android/boolean) subTopic A whitespace separated list of MQTT topics to which the app subscribes if sub is true (defaults see topics ) (iOS,Android/string) subQos (iOS,Android/boolean) tid Two digit Tracker ID used to display short name and default face of a user (iOS,Android/string) tls MQTT endpoint TLS connection (iOS,Android/boolean) tlsClientCrtPassword Passphrase of the client pkcs12 file (Android/string) url HTTP endpoint URL to which messages are POSTed (iOS,Android/string) username Endpoint username (iOS,Android/string) willRetain willTopic willQos ws use MQTT over Websocket, default false (iOS,Android/boolean) waypoints Array of waypoint messages (iOS,Android/array) Notes When importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a mode element, the mode is changed first and all remaining elements are imported for the new mode. In MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60). Afterwards, an lwt message will be send. _type=beacon These messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life. { \"_type\":\"beacon\", elements } desc name of the seen beacon (iOS/String) uuid UUID of the seen beacon (iOS/String) major Major number of the seen beacon (iOS/integer/epoch) minor Minor number of the seen beacon (iOS/integer/epoch) tst Timestamp at which the beacon was seen (iOS/integer/epoch) acc Accuracy of the proximity value (iOS/integer/meters) rssi Received signal strength of the beacon (iOS/integer/decibel) prox Relative distance to the beacon (iOS/integer) 0 Proximity of the beacon could not be determined 1 Beacon is in the immediate vicinity 2 Beacon is relatively close to the user 3 Beacon is far away Notes The theoretical relationship between RSSI and distance is RSSI[dbm] = \u2212(10n log10(d) \u2212 A) where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon. _type=cmd {\"_type\":\"cmd\",\"action\":\"reportLocation\"} {\"_type\":\"cmd\",\"action\":\"reportSteps\"} {\"_type\":\"cmd\",\"action\":\"dump\"} {\"_type\":\"cmd\",\"action\":\"waypoints\"} {\"_type\":\"cmd\",\"action\":\"clearWaypoints\"} {\"_type\":\"cmd\",\"action\":\"setConfiguration\",\"configuration\":{\"_type\":\"configuration\",...} {\"_type\":\"cmd\",\"action\":\"setWaypoints\",\"waypoints\":{\"_type\":\"waypoints\",\"waypoints\":[...]} {\"_type\":\"cmd\",\"action\":\"action\",\"content\":\"Backend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org\"} {\"_type\":\"cmd\",\"action\":\"action\",\"content\":\"<a href='http://support.owntracks.org'>Backend Maintenance tonight</a>\"} {\"_type\":\"cmd\",\"action\":\"action\",\"url\":\"http://support.owntracks.org\"} {\"_type\":\"cmd\",\"action\":\"action\",\"notification\":\"Warning! Battery low\"} action action to be performed by the device (iOS,Android/string) action Inserts an additional Featured Content tab in the UI (iOS) dump Triggers the publish of a configuration message (iOS) reportSteps Triggers the report of a steps messages_(iOS)_ from Timestamp (iOS/epoch/optional) to Timestamp (iOS/epoch/optional) reportLocation Triggers the publish of a location messages (iOS,Android) Don\u2018t expect device to be online. Send with QoS>0. Device will receive and repond when activated next time. clearWaypoints deletes all waypoints/regions (iOS) setWaypoints Imports (merge) and activates new waypoints (iOS,Android) waypoints Array of waypoint messages to import (iOS,Android/array/required) setConfiguration Imports and activates new configuration values (iOS,Android) configuration Configuration message to import (iOS,Android/required) waypoints Triggers publish of a waypoints message (iOS,Android) Notes If url for the action cmd message is specified, the URL is opened in a full screen web view within the app If the optional extern boolean is true a click on the notification will launch an external browser instead If url is not specified the text of the content element is displayed. Links embedded in the text are operational. If the content consists of HTML, it is rendered The Featured Content tab can be removed with an action cmd message without content and without url element If the action cmd contains a notification element, the value of the element is shown in the app (iOS) On iOS, the array of waypoints to the setWaypoints command allows updates / removal; the key of the waypoint is its name ( desc ). If you specify an invalid lat or lon (invalid means out of range number value e.g. -1000000 , a string like \"foo\" will result in a 0 in app) the waypoint is deleted. _type=steps { \"_type\":\"steps\", elements } tst Timestamp of the request (iOS/integer/epoch) steps Steps walked with the device in the specfied time period (iOS/integer/steps) from Effective start of time period (iOS/integer/epoch) to Effective end of time period (iOS/integer/epoch) Notes steps is -1 if device does not support step counting or specified time period is invalid _type=card Apps read Card to display a name and icon for a user. { \"_type\": \"card\", elements } name Name to identify a user (iOS,Android/string/optional) face Base64 encoded PNG image that is displayed instead of the Tracker ID (iOS,Android/string/optional) _type=waypoints The app can export a list of configured waypoints to the endpoint ../waypoints (plural). { \"_type\": \"waypoints\", elements } _creator Identification of what created the array. Ignored by the apps (iOS,Android/string/optional) waypoints Array of waypoint messages (iOS,Android/array/required) _type=encrypted Apps can optionally encrypt outgoing messages with a shared symmetric key. The encrypted message is contained in the data element. For security reasons, the encryption key is not exported with configuration messages and cannot be imported. { \"_type\": \"encrypted\", elements } data Encrypted and Base64 encoded original JSON message (iOS,Android/string/required)","title":"JSON"},{"location":"tech/json/#types","text":"OwnTracks publishes its message payloads in JSON format. The different payload types are identified by a mandatory _type element. Depending on the app platform, different payload types are supported. _type iOS Android beacon Y N card Y Y cmd Y Y configuration Y Y encrypted Y Y location Y Y lwt Y Y steps Y N transition Y Y waypoint Y Y waypoints Y Y","title":"Types"},{"location":"tech/json/#topics","text":"In MQTT mode the apps publish to: owntracks/user/device with _type=location for location updates, and with _type=lwt owntracks/user/device/cmd with _type=cmd for remote commands owntracks/user/device/event with _type=transition for enter/leave events owntracks/user/device/step to report step counter owntracks/user/device/beacon for beacon ranging owntracks/user/device/dump for config dumps In MQTT mode apps subscribe to: owntracks/user/device/cmd if remote commands are enabled owntracks/+/+ for seeing other user's locations, depending on broker ACL owntracks/+/+/event for transition messages ( enter / leave ) owntracks/+/+/info for obtaining cards . In HTTP mode the apps POST their data to a single endpoint you configure.","title":"Topics"},{"location":"tech/json/#_typelocation","text":"This location object describes the location of the device that reported it. { \"_type\" : \"location\", elements } acc Accuracy of the reported location in meters without unit (iOS,Android/integer/meters/optional) alt Altitude measured above sea level (iOS,Android/integer/meters/optional) batt Device battery level (iOS,Android/integer/percent/optional) bs Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full (iOS, Android) cog Course over ground (iOS/integer/degree/optional) lat latitude (iOS,Android/float/degree/required) lon longitude (iOS,Android/float/degree/required) rad radius around the region when entering/leaving (iOS/integer/meters/optional) t trigger for the location report (iOS,Android/string/optional) p ping issued randomly by background task (iOS,Android) c circular region enter/leave event (iOS,Android) b beacon region enter/leave event (iOS) r response to a reportLocation cmd message (iOS,Android) u manual publish requested by the user (iOS,Android) t timer based publish in move move (iOS) v updated by Settings/Privacy/Locations Services/System Services/Frequent Locations monitoring (iOS) tid Tracker ID used to display the initials of a user (iOS,Android/string/optional) required for http mode tst UNIX epoch timestamp in seconds of the location fix (iOS,Android/integer/epoch/required) vac vertical accuracy of the alt element (iOS/integer/meters/optional) vel velocity (iOS,Android/integer/kmh/optional) p barometric pressure (iOS/float/kPa/optional/extended data) poi point of interest name (iOS/string/optional) conn Internet connectivity status (route to host) when the message is created (iOS,Android/string/optional/extended data) w phone is connected to a WiFi connection (iOS,Android) o phone is offline (iOS,Android) m mobile data (iOS,Android) tag name of the tag (iOS/string/optional) topic (only in HTTP payloads) contains the original publish topic (e.g. owntracks/jane/phone ). (iOS,Android >= 2.4,string) inregions contains a list of regions the device is currently in (e.g. [\"Home\",\"Garage\"] ). Might be empty. (iOS,Android/list of strings/optional) inrids contains a list of region IDs the device is currently in (e.g. [\"6da9cf\",\"3defa7\"] ). Might be empty. (iOS,Android/list of strings/optional) SSID , if available, is the unique name of the WLAN. (iOS,string/optional) BSSID , if available, identifies the access point. (iOS,string/optional) created_at identifies the time at which the message is constructed (vs. tst which is the timestamp of the GPS fix) (iOS,Android) m identifies the monitoring mode at which the message is constructed ( significant = 1 , move = 2 ) (iOS/integer/optional)","title":"_type=location"},{"location":"tech/json/#notes","text":"The tst in a ping is a current timestamp , so that it doesn't look like a duplicate. The tid defaults to the last two characters of the topic A missing t element also indicates an automatic location update A publish of \"_type\": \"location\" with a \"b\" trigger is sent when an iOS device enters or leaves a beacon in addition to a \"_type\": \"transition\" : if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated. The acc , alt , cog , vac , vel elements are only added if they are not zero Some Android devices always return 0 for alt or vel Elements marked with extended data are only added if extendedData=true is configured","title":"Notes"},{"location":"tech/json/#greenwich","text":"The OwnTracks edition of the Choral Greenwich device reports the following additional elements in a _type=location message: { \"_type\": \"location\", elements } alt Altitude measured above sea level (integer/meters/optional) batt Device battery level (integer/percent/optional) cog Course over ground (integer/degree/optional) dist Distance travelled since the last location report (integer/meters/optional) trip Distance travelled since the last reboot (integer/meters/optional) vel velocity (integer/kmh/optional) t trigger for the location report (string/optional) f First publish after reboot m Manually requested locations (e.g. by publishing to /cmd ) t Time for location published because device is moving. T Time for location published because of time passed while device is stationary ( maxInterval ) k Transitioning from move to stationary (park) v Transitioning from stationary to move (mo-v-e) l Last known position when device lost GPS fix L Last known position before gracefull shutdown","title":"Greenwich"},{"location":"tech/json/#notes_1","text":"The device can be configured to produce or not produce fields marked as optional","title":"Notes"},{"location":"tech/json/#queclink","text":"OwnTracks works with a selection of trackers by Queclink , for which the protocol conversion is done via qtripp . Queclink devices report the following additional elements in a _type=location message: { \"_type\": \"location\", elements } t trigger for the location report (string/optional) o Corner M Mileage ! Tow or fake tow or sensor without ignition a motionless (aka park) i ignition on I ignition off e external power off E external power ON 1 Devices powered up 2 Battery stop charging 3 Battery start charging 9 Battery power low h harsh behavior s speed alarm odometer total distance of the device (float/kilometers/optional) hmc total hours of operation (float/seconds/optional) ubatt voltage of the battery (float/volts/optional) uext voltage of the external power source (float/volts/optional) vin vehicle identification number (string/optional) imei identification number (string/optional) name vehicle name (string/optional) don is duration since ignition on (float/seconds/optional) doff is duration since ignition off (float/seconds/optional) aiv is analog input voltage (float/volts/optional) rpm is engine rounds per minute (float/rounds per minute/optional) fcon is fuel consumption (float/L per 100km/optional) flvl is fuel level (float/percent/optional) anum is number of analog inputs (integer/optional) adid-xx is id of analog input number xx (string/optional) adty-xx is type of analog input number xx (string/optional) adda-xx is data of analog input number xx (string/optional) temp_c-xx is temperature of analog input number xx (float/celsius/optional) can is can data (string/optional) din1 is status of digital input 1 (boolean/optional) din2 is status of digital input 2 (boolean/optional) dout1 is status of digital output 1 (boolean/optional) dout2 is status of digital output 2 (boolean/optional) ign is status of ignition (boolean/optional) motion is motion status (boolean/optional) tow is status of tow sensor (boolean/optional) fake is status of fake tow sensor (boolean/optional) sens is status of motion sensor (boolean/optional) sent is epoch when message was sent (integer/epoch/optional) mcc is mobile country code (integer/optional) mnc is mobile network code (integer/optional) lac is location area code (string/optional) cid is cell id (string/optional) nmds is non movement detection status (boolean/optional) rit queclink record id and type (integer/optional) rty queclink record type (integer/optional) rid queclink record id (integer/optional) mst queclink motion state (integer/optional) count is counter of message (string/optional) raw_line raw data (string/optional) counter number of ignored positions (integer/optional) ignored indicates counter positions have been ignored (boolean/optional)","title":"Queclink"},{"location":"tech/json/#notes_2","text":"The device can be configured to produce or not produce fields marked as optional","title":"Notes"},{"location":"tech/json/#_typelwt","text":"A last will and testament is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this: { \"_type\":\"lwt\", elements } tst UNIX epoch timestamp at which the app first connected (iOS,Android/integer/epoch/required)","title":"_type=lwt"},{"location":"tech/json/#_typewaypoint","text":"Waypoints / regions denote specific geographical regions that you want to keep track of. You define a region in the OwnTracks app, and OwnTracks publishes this waypoint to the topic branch ../waypoint (singular). OwnTracks also monitors these waypoints and will publish {_type: \"transition\", ...} message when entering or leaving the region. A waypoint may also define a BLE Beacon instead of a geographical region. { \"_type\" : \"waypoint\", elements } desc Name of the waypoint that is included in the sent transition message, copied into the location message inregions array when a current position is within a region. (iOS,Android,string/required) lat Latitude (iOS,Android/float/meters/optional) lon Longitude (iOS,Android/float/meters/optional) rad Radius around the latitude and longitude coordinates (iOS,Android/integer/meters/optional) tst Timestamp of creation of region, copied into the wtst element of the transition message (iOS,Android/integer/epoch/required) uuid UUID of the BLE Beacon (iOS/string/optional) major Major number of the BLE Beacon (iOS/integer/optional) minor Minor number of the BLE Beacon_(iOS/integer/optional)_ rid region ID, created automatically, copied into the location payload inrids array (iOS/string)_","title":"_type=waypoint"},{"location":"tech/json/#notes_3","text":"In iOS version >= 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the desc element. If lat , lon and rad elements are present, transition messages are sent when entering and leaving the geographical region If uuid , major , minor elements are present, BLE becons with that specifications are monitored Beacons and Geographical regions can be defined together Waypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage. Waypoints are sent to the broker and transition messages contain a desc and event element.","title":"Notes"},{"location":"tech/json/#_typetransition","text":"A transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained. { \"_type\": \"transition\", elements } wtst Timestamp of waypoint creation (iOS,Android/integer/epoch/required) lat Latitude at which the event occured (iOS,Android/float/meters/optional) lon Longitue at which the event occured (iOS,Android/float/meters/optional) tst Timestamp at which the event occured (iOS,Android/integer/epoch/required) acc Accuracy of the geographical coordinates (iOS,Android/float/meters/required) tid Tracker ID of the waypoint (iOS/string/none/optional) event Event that triggered the transition (iOS,Android/string/required) enter The device entered the defined geographical region or BLE Beacon range (iOS) leave The device left the defined geographical region or BLE Beacon range (iOS) desc Name of the waypoint (iOS,Android/string/optional) tid TrackerID required in http mode. t Trigger of the event (iOS,Android/string/optional) c Circular geographical region (iOS, Android) b BLE Beacon (iOS) l Loction update (Android) rid Region ID (iOS/Android, after January 2021)","title":"_type=transition"},{"location":"tech/json/#_typeconfiguration","text":"The device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages. { \"_type\": \"configuration\", elements } allowRemoteLocation Respond to reportLocation cmd message (iOS/boolean) allowinvalidcerts disable TLS certificate checks insecure (iOS/boolean) auth Use username and password for endpoint authentication (iOS,Android/boolean) autostartOnBoot Autostart the app on device boot (Android/boolean) cleanSession MQTT endpoint clean session (iOS,Android/boolean) clientId client id to use for MQTT connect. Defaults to \" user deviceId \" (iOS,Android/string) clientpkcs Name of the client pkcs12 file (iOS/string) cmd Respond to cmd messages (iOS,Android/boolean) deviceId id of the device used for pubTopicBase and clientId construction. Defaults to the os name of the device (iOS,Android/string) downgrade battery level below which to downgrade monitoring from move mode (iOS/integer/percent/optional) extendedData Add extended data attributes to location messages (iOS,Android/boolean) host MQTT endpoint host (iOS,Android/string) ignoreInaccurateLocations Location accuracy below which reports are supressed (iOS,Android/integer/meters) ignoreStaleLocations Number of days after which location updates are assumed stale (iOS,Android/integer/days) keepalive MQTT endpoint keepalive (iOS,Android/integer/seconds) locatorDisplacement maximum distance between location source updates (iOS,Android/integer/meters) locatorInterval maximum interval between location source updates (iOS,Android/integer/seconds) locatorPriority source/power setting for location updates (Android/integer/) 0 NO_POWER / best accuracy possible with zero additional power consumption (Android) 1 LOW_POWER / city level accuracy (Android) 2 BALANCED_POWER / block level accuracy based on Wifi/Cell (Android) 3 HIGH_POWER / most accurate accuracy based on GPS (Android) locked Locks settings screen on device for editing (iOS/boolean) maxHistory Number of notifications to store historically. Zero (0) means no notifications are stored and history tab is hidden. Defaults to zero. (iOS/integer) mode Endpoint protocol mode (iOS,Android/integer) 0 Private MQTT (iOS, Android) 3 Private HTTP (iOS, Android) monitoring Location reporting mode (iOS,Android/integer) -1 Quiet 0 Manual 1 Significant 2 Move mqttProtocolLevel MQTT broker protocol level (iOS,Android/integer) 3 MQTT 3 (default) 4 MQTT 3.1.1 5 MQTT 5 (iOS only) notificationLocation Show last reported location in ongoing notification (Android/boolean) opencageApiKey API key for alternate Geocoding provider. See https://opencagedata.com/ for details. (Android/string) passphrase Passphrase of the client pkcs12 file (iOS/string) password Endpoint password (iOS,Android/string) ping Interval in which location messages of with t : p are reported (Android/integer) port MQTT endpoint port (iOS,Android/integer) positions Number of locations to keep and display (iOS/integer) pubTopicBase MQTT topic base to which the app publishes; %u is replaced by the user name, %d by device (iOS,Android/string) pubRetain MQTT retain flag for reported messages (iOS,Android/boolean) pubQos MQTT QoS level for reported messages (iOS,Android/integer) ranging Beacon ranging (iOS/boolean) remoteConfiguration Allow remote configuration by sending a setConfiguration cmd message (Android/boolean) servercer Blank separated list of certificate file names in DER format (iOS/string) sub subscribe to subTopic via MQTT (iOS,Android/boolean) subTopic A whitespace separated list of MQTT topics to which the app subscribes if sub is true (defaults see topics ) (iOS,Android/string) subQos (iOS,Android/boolean) tid Two digit Tracker ID used to display short name and default face of a user (iOS,Android/string) tls MQTT endpoint TLS connection (iOS,Android/boolean) tlsClientCrtPassword Passphrase of the client pkcs12 file (Android/string) url HTTP endpoint URL to which messages are POSTed (iOS,Android/string) username Endpoint username (iOS,Android/string) willRetain willTopic willQos ws use MQTT over Websocket, default false (iOS,Android/boolean) waypoints Array of waypoint messages (iOS,Android/array)","title":"_type=configuration"},{"location":"tech/json/#notes_4","text":"When importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a mode element, the mode is changed first and all remaining elements are imported for the new mode. In MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60). Afterwards, an lwt message will be send.","title":"Notes"},{"location":"tech/json/#_typebeacon","text":"These messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life. { \"_type\":\"beacon\", elements } desc name of the seen beacon (iOS/String) uuid UUID of the seen beacon (iOS/String) major Major number of the seen beacon (iOS/integer/epoch) minor Minor number of the seen beacon (iOS/integer/epoch) tst Timestamp at which the beacon was seen (iOS/integer/epoch) acc Accuracy of the proximity value (iOS/integer/meters) rssi Received signal strength of the beacon (iOS/integer/decibel) prox Relative distance to the beacon (iOS/integer) 0 Proximity of the beacon could not be determined 1 Beacon is in the immediate vicinity 2 Beacon is relatively close to the user 3 Beacon is far away","title":"_type=beacon"},{"location":"tech/json/#notes_5","text":"The theoretical relationship between RSSI and distance is RSSI[dbm] = \u2212(10n log10(d) \u2212 A) where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon.","title":"Notes"},{"location":"tech/json/#_typecmd","text":"{\"_type\":\"cmd\",\"action\":\"reportLocation\"} {\"_type\":\"cmd\",\"action\":\"reportSteps\"} {\"_type\":\"cmd\",\"action\":\"dump\"} {\"_type\":\"cmd\",\"action\":\"waypoints\"} {\"_type\":\"cmd\",\"action\":\"clearWaypoints\"} {\"_type\":\"cmd\",\"action\":\"setConfiguration\",\"configuration\":{\"_type\":\"configuration\",...} {\"_type\":\"cmd\",\"action\":\"setWaypoints\",\"waypoints\":{\"_type\":\"waypoints\",\"waypoints\":[...]} {\"_type\":\"cmd\",\"action\":\"action\",\"content\":\"Backend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org\"} {\"_type\":\"cmd\",\"action\":\"action\",\"content\":\"<a href='http://support.owntracks.org'>Backend Maintenance tonight</a>\"} {\"_type\":\"cmd\",\"action\":\"action\",\"url\":\"http://support.owntracks.org\"} {\"_type\":\"cmd\",\"action\":\"action\",\"notification\":\"Warning! Battery low\"} action action to be performed by the device (iOS,Android/string) action Inserts an additional Featured Content tab in the UI (iOS) dump Triggers the publish of a configuration message (iOS) reportSteps Triggers the report of a steps messages_(iOS)_ from Timestamp (iOS/epoch/optional) to Timestamp (iOS/epoch/optional) reportLocation Triggers the publish of a location messages (iOS,Android) Don\u2018t expect device to be online. Send with QoS>0. Device will receive and repond when activated next time. clearWaypoints deletes all waypoints/regions (iOS) setWaypoints Imports (merge) and activates new waypoints (iOS,Android) waypoints Array of waypoint messages to import (iOS,Android/array/required) setConfiguration Imports and activates new configuration values (iOS,Android) configuration Configuration message to import (iOS,Android/required) waypoints Triggers publish of a waypoints message (iOS,Android)","title":"_type=cmd"},{"location":"tech/json/#notes_6","text":"If url for the action cmd message is specified, the URL is opened in a full screen web view within the app If the optional extern boolean is true a click on the notification will launch an external browser instead If url is not specified the text of the content element is displayed. Links embedded in the text are operational. If the content consists of HTML, it is rendered The Featured Content tab can be removed with an action cmd message without content and without url element If the action cmd contains a notification element, the value of the element is shown in the app (iOS) On iOS, the array of waypoints to the setWaypoints command allows updates / removal; the key of the waypoint is its name ( desc ). If you specify an invalid lat or lon (invalid means out of range number value e.g. -1000000 , a string like \"foo\" will result in a 0 in app) the waypoint is deleted.","title":"Notes"},{"location":"tech/json/#_typesteps","text":"{ \"_type\":\"steps\", elements } tst Timestamp of the request (iOS/integer/epoch) steps Steps walked with the device in the specfied time period (iOS/integer/steps) from Effective start of time period (iOS/integer/epoch) to Effective end of time period (iOS/integer/epoch)","title":"_type=steps"},{"location":"tech/json/#notes_7","text":"steps is -1 if device does not support step counting or specified time period is invalid","title":"Notes"},{"location":"tech/json/#_typecard","text":"Apps read Card to display a name and icon for a user. { \"_type\": \"card\", elements } name Name to identify a user (iOS,Android/string/optional) face Base64 encoded PNG image that is displayed instead of the Tracker ID (iOS,Android/string/optional)","title":"_type=card"},{"location":"tech/json/#_typewaypoints","text":"The app can export a list of configured waypoints to the endpoint ../waypoints (plural). { \"_type\": \"waypoints\", elements } _creator Identification of what created the array. Ignored by the apps (iOS,Android/string/optional) waypoints Array of waypoint messages (iOS,Android/array/required)","title":"_type=waypoints"},{"location":"tech/json/#_typeencrypted","text":"Apps can optionally encrypt outgoing messages with a shared symmetric key. The encrypted message is contained in the data element. For security reasons, the encryption key is not exported with configuration messages and cannot be imported. { \"_type\": \"encrypted\", elements } data Encrypted and Base64 encoded original JSON message (iOS,Android/string/required)","title":"_type=encrypted"},{"location":"tech/mqtt/","text":"MQTT Keepalives MQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the keepalive interval which is set by the client. The server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec. From the spec: The actual value of the Keep Alive is application specific; typically this is a few minutes. The maximum value is 18 hours 12 minutes and 15 seconds. For example, mosquitto_sub uses a default of 60 sec. In addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand. Broker Below is a list of known configuration values that are required to connect to certain MQTT endpoints AWS IOT The OwnTracks apps are partially compatible to the AWS IOT broker in MQTT private mode. As AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. Before connecting, a so called thing has to be configured which represents the connecting client. The thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. The most basic policy allows all actions for the thing . { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:*\", \"Resource\": \"*\" } ] } The following settings are required to connect { \"_type\":\"configuration\", \"mode\":0, \"host\": \"ENDPOINT.amazonaws.com\", \"port\": 8883, \"subQos\":0, \"pubQos\":0, \"auth\":false, \"pubRetain\":false, \"cleanSession\":true, \"tls\":true \"clientId\":\"CLIENTID\", } The ENDPOINT can be obtained in the thing details under Interact . Additionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca. Before importing it into the app, you need to set a password to the client TLS certificate. Losant IoT Developer Platform The OwnTracks apps are partially compatible to the Losant IoT Developer Platform in MQTT private mode. As Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. The following settings are required to connect { \"_type\": \"configuration\", \"mode\":0, \"mqttProtocolLevel\": 4, \"host\":\"broker.losant.com\", \"port\":8883, \"tls\":true, \"pubRetain\": false, \"pubQos\": 0, \"subQos\":0, \"cleanSession\": true, \"clientId\":\"CLIENT_ID\", \"auth\":true, \"username\":\"ACCESS_KEY\", \"password\":\"ACCESS_SECRET\" } See the official documentation how to obtain the ACCESS_KEY and ACCESS_SECRET .","title":"MQTT"},{"location":"tech/mqtt/#mqtt","text":"","title":"MQTT"},{"location":"tech/mqtt/#keepalives","text":"MQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the keepalive interval which is set by the client. The server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec. From the spec: The actual value of the Keep Alive is application specific; typically this is a few minutes. The maximum value is 18 hours 12 minutes and 15 seconds. For example, mosquitto_sub uses a default of 60 sec. In addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand.","title":"Keepalives"},{"location":"tech/mqtt/#broker","text":"Below is a list of known configuration values that are required to connect to certain MQTT endpoints","title":"Broker"},{"location":"tech/mqtt/#aws-iot","text":"The OwnTracks apps are partially compatible to the AWS IOT broker in MQTT private mode. As AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. Before connecting, a so called thing has to be configured which represents the connecting client. The thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. The most basic policy allows all actions for the thing . { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:*\", \"Resource\": \"*\" } ] } The following settings are required to connect { \"_type\":\"configuration\", \"mode\":0, \"host\": \"ENDPOINT.amazonaws.com\", \"port\": 8883, \"subQos\":0, \"pubQos\":0, \"auth\":false, \"pubRetain\":false, \"cleanSession\":true, \"tls\":true \"clientId\":\"CLIENTID\", } The ENDPOINT can be obtained in the thing details under Interact . Additionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca. Before importing it into the app, you need to set a password to the client TLS certificate.","title":"AWS IOT"},{"location":"tech/mqtt/#losant-iot-developer-platform","text":"The OwnTracks apps are partially compatible to the Losant IoT Developer Platform in MQTT private mode. As Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. The following settings are required to connect { \"_type\": \"configuration\", \"mode\":0, \"mqttProtocolLevel\": 4, \"host\":\"broker.losant.com\", \"port\":8883, \"tls\":true, \"pubRetain\": false, \"pubQos\": 0, \"subQos\":0, \"cleanSession\": true, \"clientId\":\"CLIENT_ID\", \"auth\":true, \"username\":\"ACCESS_KEY\", \"password\":\"ACCESS_SECRET\" } See the official documentation how to obtain the ACCESS_KEY and ACCESS_SECRET .","title":"Losant IoT Developer Platform"},{"location":"tech/program/","text":"Programming We've shown you some clients which consume OwnTracks data , but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of Python together with the Paho Python client . Getting started: Paho Python We're assuming you have Python installed, which you can verify by attempting to invoke python -V ; if installed, it tells you the version number. We're also assuming you have pip installed (a Python package manager) which may be called pip2 or something on your machine. You may have to install setuptools via your distribution's package manager. Install the Paho Python module using pip install paho-mqtt Progress reports Assume we want to create a program which should report the location of our friends, as a simple list: TID = n4 is currently at 51.0343863, 9.4763712 TID = n7 is currently at 52.7343671, 7.8764431 TID = jp is currently at 53.134404655, 8.1063173 We need a small utility program which will subscribe to location publishes received by your broker by connecting to it on localhost and subscribing to owntracks/+/+ (a wild-card expression in which each + means anything at this level ). The Code For each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID ( TID ) as well as latitude, longitude coordinates. Keep a copy of our OwnTracks-JSON documentation handy and study the topic names of each possible publish by the apps. #!/usr/bin/env python import paho.mqtt.client as mqtt import json # The callback for when the client successfully connects to the broker def on_connect(client, userdata, rc): ''' We subscribe on_connect() so that if we lose the connection and reconnect, subscriptions will be renewed. ''' client.subscribe(\"owntracks/+/+\") # The callback for when a PUBLISH message is received from the broker def on_message(client, userdata, msg): topic = msg.topic try: data = json.loads(str(msg.payload)) print \"TID = {0} is currently at {1}, {2}\".format(data['tid'], data['lat'], data['lon']) except: print \"Cannot decode data on topic {0}\".format(topic) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"localhost\", 1883, 60) # Blocking call which processes all network traffic and dispatches # callbacks (see on_*() above). It also handles reconnecting. client.loop_forever() Micro Map Assume for a moment that you alter the program above in such a way as that it writes your current location in JSON format to a file called me.json which could look like this: { \"lat\": 48.858334, \"lon\" : 2.295134, \"tid\":\"JJ\" } We could then create a Web page which would load that JSON and display a marker on a map. index.html <!DOCTYPE html> <html> <head> <title>Micromap</title> <meta name=\"viewport\" content=\"width=device-width, height=device-height, user-scalable=no, initial-scale=1.0\" /> <meta name=\"mobile-web-app-capable\" content=\"yes\"> <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"> <style type=\"text/css\"> body { font-size: 80%; } td { border-bottom: 1px solid; border-right: 1px dotted;} #map-canvas { height: 100% } </style> <script src=\"https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false\"></script> <script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"></script> <script src=\"http://code.jquery.com/jquery-migrate-1.1.1.min.js\"></script> <script src=\"functions.js\"></script> </head> <body> <div> <div id=\"map-canvas\" style='width: 100%; height: 400px;'/></div> </div> </body> </html> functions.js function initialize() { var json = (function () { var json = null; $.ajax({ 'type' : 'GET', 'async': false, 'cache' : false, 'global': true, 'url' : 'me.json', // URI of JSON file we create 'dataType': \"json\", 'success': function (data) { json = data; return json; } }); return json; })(); var data = json; console.log(JSON.stringify(data)); var center = new google.maps.LatLng(data.lat, data.lon); mapOptions = { center: center, zoom: 12, mapTypeId: google.maps.MapTypeId.ROADMAP, scrollwheel: false, disableDefaultUI: false, panControl: false, scaleControl: false, streetViewControl: false, overviewMapControl: false, }; map = new google.maps.Map(document.getElementById(\"map-canvas\"), mapOptions); var LatLng = new google.maps.LatLng(data.lat, data.lon); var m = new google.maps.Marker({ position: LatLng, map: map, title: data.tid, }); } google.maps.event.addDomListener(window, 'load', initialize); would result in a map being displayed in your Web browser with a marker at the last location received by your MQTT broker. Note: the marker won't move; we leave that as an exercise to you, or just head over and look at some clients which do that for you. Testing Testing location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply: Use the publish now button in OwnTracks to fire a location update. The smart phone won't really move much of course, but it'll allow you to test your program a bit. Publish your own OwnTracks-JSON payload to the broker with mosquitto_pub or similar. Last words Consuming OwnTracks messages from your MQTT broker isn't particularly difficult, and people have built nice programs doing so.","title":"Code"},{"location":"tech/program/#programming","text":"We've shown you some clients which consume OwnTracks data , but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of Python together with the Paho Python client .","title":"Programming"},{"location":"tech/program/#getting-started-paho-python","text":"We're assuming you have Python installed, which you can verify by attempting to invoke python -V ; if installed, it tells you the version number. We're also assuming you have pip installed (a Python package manager) which may be called pip2 or something on your machine. You may have to install setuptools via your distribution's package manager. Install the Paho Python module using pip install paho-mqtt","title":"Getting started: Paho Python"},{"location":"tech/program/#progress-reports","text":"Assume we want to create a program which should report the location of our friends, as a simple list: TID = n4 is currently at 51.0343863, 9.4763712 TID = n7 is currently at 52.7343671, 7.8764431 TID = jp is currently at 53.134404655, 8.1063173 We need a small utility program which will subscribe to location publishes received by your broker by connecting to it on localhost and subscribing to owntracks/+/+ (a wild-card expression in which each + means anything at this level ).","title":"Progress reports"},{"location":"tech/program/#the-code","text":"For each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID ( TID ) as well as latitude, longitude coordinates. Keep a copy of our OwnTracks-JSON documentation handy and study the topic names of each possible publish by the apps. #!/usr/bin/env python import paho.mqtt.client as mqtt import json # The callback for when the client successfully connects to the broker def on_connect(client, userdata, rc): ''' We subscribe on_connect() so that if we lose the connection and reconnect, subscriptions will be renewed. ''' client.subscribe(\"owntracks/+/+\") # The callback for when a PUBLISH message is received from the broker def on_message(client, userdata, msg): topic = msg.topic try: data = json.loads(str(msg.payload)) print \"TID = {0} is currently at {1}, {2}\".format(data['tid'], data['lat'], data['lon']) except: print \"Cannot decode data on topic {0}\".format(topic) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"localhost\", 1883, 60) # Blocking call which processes all network traffic and dispatches # callbacks (see on_*() above). It also handles reconnecting. client.loop_forever()","title":"The Code"},{"location":"tech/program/#micro-map","text":"Assume for a moment that you alter the program above in such a way as that it writes your current location in JSON format to a file called me.json which could look like this: { \"lat\": 48.858334, \"lon\" : 2.295134, \"tid\":\"JJ\" } We could then create a Web page which would load that JSON and display a marker on a map.","title":"Micro Map"},{"location":"tech/program/#indexhtml","text":"<!DOCTYPE html> <html> <head> <title>Micromap</title> <meta name=\"viewport\" content=\"width=device-width, height=device-height, user-scalable=no, initial-scale=1.0\" /> <meta name=\"mobile-web-app-capable\" content=\"yes\"> <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"> <style type=\"text/css\"> body { font-size: 80%; } td { border-bottom: 1px solid; border-right: 1px dotted;} #map-canvas { height: 100% } </style> <script src=\"https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false\"></script> <script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"></script> <script src=\"http://code.jquery.com/jquery-migrate-1.1.1.min.js\"></script> <script src=\"functions.js\"></script> </head> <body> <div> <div id=\"map-canvas\" style='width: 100%; height: 400px;'/></div> </div> </body> </html>","title":"index.html"},{"location":"tech/program/#functionsjs","text":"function initialize() { var json = (function () { var json = null; $.ajax({ 'type' : 'GET', 'async': false, 'cache' : false, 'global': true, 'url' : 'me.json', // URI of JSON file we create 'dataType': \"json\", 'success': function (data) { json = data; return json; } }); return json; })(); var data = json; console.log(JSON.stringify(data)); var center = new google.maps.LatLng(data.lat, data.lon); mapOptions = { center: center, zoom: 12, mapTypeId: google.maps.MapTypeId.ROADMAP, scrollwheel: false, disableDefaultUI: false, panControl: false, scaleControl: false, streetViewControl: false, overviewMapControl: false, }; map = new google.maps.Map(document.getElementById(\"map-canvas\"), mapOptions); var LatLng = new google.maps.LatLng(data.lat, data.lon); var m = new google.maps.Marker({ position: LatLng, map: map, title: data.tid, }); } google.maps.event.addDomListener(window, 'load', initialize); would result in a map being displayed in your Web browser with a marker at the last location received by your MQTT broker. Note: the marker won't move; we leave that as an exercise to you, or just head over and look at some clients which do that for you.","title":"functions.js"},{"location":"tech/program/#testing","text":"Testing location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply: Use the publish now button in OwnTracks to fire a location update. The smart phone won't really move much of course, but it'll allow you to test your program a bit. Publish your own OwnTracks-JSON payload to the broker with mosquitto_pub or similar.","title":"Testing"},{"location":"tech/program/#last-words","text":"Consuming OwnTracks messages from your MQTT broker isn't particularly difficult, and people have built nice programs doing so.","title":"Last words"},{"location":"tech/qr/","text":"To configure OwnTracks (and especially iBeacons for the iOS app), you can use URIs or QR codes. The QR codes can opened via the camera app, the URIs via the Web browser, the email app, etc. QR codes can be prepared with a number of tools: there are online offerings, and there is a standalone C program by the name of qrencode which works very well: qrencode -l H -v 10 -d 300 -o mybeacon.png 'owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1' iBeacon QR URI scheme = owntracks host = <empty> path = /beacon query = rid=<rid>&name=<name>&uuid=<uuid>&major=<major>&minor=<minor> rid, major, and minor are optional Example: owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1 config QR URI See Features/Remoteconfig/URL config","title":"URIs and QR codes"},{"location":"tech/qr/#ibeacon-qr-uri","text":"scheme = owntracks host = <empty> path = /beacon query = rid=<rid>&name=<name>&uuid=<uuid>&major=<major>&minor=<minor> rid, major, and minor are optional Example: owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1","title":"iBeacon QR URI"},{"location":"tech/qr/#config-qr-uri","text":"See Features/Remoteconfig/URL config","title":"config QR URI"}]}