{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OwnTracks is an Open Source project which provides iOS and Android apps with which devices publish their current location to a server of your choice. While there are many smartphone apps available which can do that, OwnTracks is special in as much as you decide what happens to your data. To all of it. Whether you want your young child to know where you currently are, you want to keep track of where you spent your last vacation, or you and a group of friends want to see each other on a map, OwnTracks can do that. It consists of an app which runs on your smartphone (iOS & Android), and which periodically, publishes a small chunk of data which other OwnTracks users you authorize may see. The big deal here is which you authorize : we are extremely picky about the security and more importantly the privacy of OwnTracks. To be quite clear, you also run the backend in order to ensure that only you and the people you authorize have access to the data published by the apps. It might also be that you don't want to share your location data at all but desire a record of where you've been. That too is something OwnTracks can do for you. From this point onwards, it gets a bit complicated, but we'll try and ease your way into the world of OwnTracks so you may enjoy it. We think the best way to get started using OwnTracks is to follow this guide, chapter by chapter, but you certainly may fast-forward or even skip sections you're familiar with. Pressing Next on each page will guide you (pun!) through the guide. We'll now move on to explain what OwnTracks does and how it works .","title":"Intro"},{"location":"faq/","text":"Answers # This is a list of question we really get asked a lot and some answers to these questions. Q: Can I have OwnTracks not publish location for a specific period of time? A: Set mode to manual (iOS) or disable automatic location reporting (Android) Q: How can I restart OwnTracks? A: Swip away and start (iOS), Force close and start (Android) Q: Can you remove Google Play Services from the Android app? A: No Q: Can you remove Google Maps from the Android app? A: No Q: Since updating to Android 6 (or higher), background location reporting does not work as before A: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. Your best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection. Q: I've moved, but OwnTracks is not reporting my location A: Depending on the mode the apps report location changes only after significant changes. Q: How do I enable region monitoring? (Waypoints) Q: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that. Q: Why are transition events delayed? Q: How can I increase reporting frequency and does that have any negative impact? A: I have a question A: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the OwnTracks meta tracker . Q: How can I report an issue? A: If you think you've found a bug, please report it on our respective android or ios issue tracker on Github.","title":"Answers"},{"location":"faq/#answers","text":"This is a list of question we really get asked a lot and some answers to these questions. Q: Can I have OwnTracks not publish location for a specific period of time? A: Set mode to manual (iOS) or disable automatic location reporting (Android) Q: How can I restart OwnTracks? A: Swip away and start (iOS), Force close and start (Android) Q: Can you remove Google Play Services from the Android app? A: No Q: Can you remove Google Maps from the Android app? A: No Q: Since updating to Android 6 (or higher), background location reporting does not work as before A: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. Your best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection. Q: I've moved, but OwnTracks is not reporting my location A: Depending on the mode the apps report location changes only after significant changes. Q: How do I enable region monitoring? (Waypoints) Q: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that. Q: Why are transition events delayed? Q: How can I increase reporting frequency and does that have any negative impact? A: I have a question A: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the OwnTracks meta tracker . Q: How can I report an issue? A: If you think you've found a bug, please report it on our respective android or ios issue tracker on Github.","title":"Answers"},{"location":"ideas/","text":"Ideas # Over the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already. Allow KML, GPX export. This we do enable in the back-end. Publish charging alongside battery level. No. Add temperature to the JSON payload. No. Have the device track a route; we do this in the back-end. Feature to start a \"sequence\" which sets two custom attributes for transport mode (e.g. bicycle, walk, etc.) and/or a route name (e.g. drivehome2work_01032021) until manually turned off. If no sequence is started the attribute is just left empty. Makes querying the data much easier. Short term # Mid-term # Long-term # Add presence. Are my friends in the area? Needs friends/family on same broker Needs 'standardized' topic names (maybe with Twitter id in topic?) Add transportation info (e.g. trains) as friends Queue updates on device (with tst etc) to be PUBlished upon available connection NFC support, suggested by mrizvic Very-long term, a.k.a. \"Neat ideas\" # Publish incoming phone call (caller-id), submitted by @bordingnon . JPM: Also SMS? Have to force TLS then, at least. Requested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\" Generalized messaging app Indoors edition with iBeacons as requested in #296 Waypoints # JPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload: { \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\"<current>\", \"lon\":<current>\", \"text\":\"utf-8 text\" } Remote control # Maybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139) Interesting idea in #227 : device can change mode (e.g. silent , airplane mode , etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes. Add remote-control for setting waypoints via MQTT","title":"Ideas"},{"location":"ideas/#ideas","text":"Over the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already. Allow KML, GPX export. This we do enable in the back-end. Publish charging alongside battery level. No. Add temperature to the JSON payload. No. Have the device track a route; we do this in the back-end. Feature to start a \"sequence\" which sets two custom attributes for transport mode (e.g. bicycle, walk, etc.) and/or a route name (e.g. drivehome2work_01032021) until manually turned off. If no sequence is started the attribute is just left empty. Makes querying the data much easier.","title":"Ideas"},{"location":"ideas/#short-term","text":"","title":"Short term"},{"location":"ideas/#mid-term","text":"","title":"Mid-term"},{"location":"ideas/#long-term","text":"Add presence. Are my friends in the area? Needs friends/family on same broker Needs 'standardized' topic names (maybe with Twitter id in topic?) Add transportation info (e.g. trains) as friends Queue updates on device (with tst etc) to be PUBlished upon available connection NFC support, suggested by mrizvic","title":"Long-term"},{"location":"ideas/#very-long-term-aka-neat-ideas","text":"Publish incoming phone call (caller-id), submitted by @bordingnon . JPM: Also SMS? Have to force TLS then, at least. Requested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\" Generalized messaging app Indoors edition with iBeacons as requested in #296","title":"Very-long term, a.k.a. \"Neat ideas\""},{"location":"ideas/#waypoints","text":"JPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload: { \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\"<current>\", \"lon\":<current>\", \"text\":\"utf-8 text\" }","title":"Waypoints"},{"location":"ideas/#remote-control","text":"Maybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139) Interesting idea in #227 : device can change mode (e.g. silent , airplane mode , etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes. Add remote-control for setting waypoints via MQTT","title":"Remote control"},{"location":"people/","text":"People # Alexander Rust created the first proof-of-concept for the Android app which started out under the very geeky name MQTTitude , a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013. Andrew Rowson then took over and now maintains the Android app. Only a few days later, Christoph Krey implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out. Jan-Piet Mens had the original crazy idea of combining location updates and MQTT and tries to keep abreast on what Christoph and Alexander do. As Ben once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles. Incidentally, Ben Jones , who works closely with us, has given us loads of invaluable feedback and he's the chap who created the mqttitude binding for the wonderful openHAB Home Automation project. Linus Groh created the OwnTracks Frontend which you'll definitely want to use, and we install it by default during quicksetup . Contributors # Many fine people have assisted us, be it by testing, by contributing bits of code, documentation, or translations, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-) Brad Pillatsch wrote the initial implementation of PKCS#12 import for Android. brunkj for help in tracking down an address book crash. Matthew Bordignon for ideas and help with testing. Stefano Costa for bug reports. Mark Clark for bug reports. Adrian Brown originally suggested the idea for location-based services friesenkiwi contributed sundry large patches to Android and drove the LOST integration. Mikael Berthe initiated the idea for the _cp attribute (which we removed in May 2018). Peter Lindemann raised his hand for translating the iOS app into Dutch. Federico Hernandez contributed the Swedish translation of the iOS app.","title":"People"},{"location":"people/#people","text":"Alexander Rust created the first proof-of-concept for the Android app which started out under the very geeky name MQTTitude , a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013. Andrew Rowson then took over and now maintains the Android app. Only a few days later, Christoph Krey implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out. Jan-Piet Mens had the original crazy idea of combining location updates and MQTT and tries to keep abreast on what Christoph and Alexander do. As Ben once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles. Incidentally, Ben Jones , who works closely with us, has given us loads of invaluable feedback and he's the chap who created the mqttitude binding for the wonderful openHAB Home Automation project. Linus Groh created the OwnTracks Frontend which you'll definitely want to use, and we install it by default during quicksetup .","title":"People"},{"location":"people/#contributors","text":"Many fine people have assisted us, be it by testing, by contributing bits of code, documentation, or translations, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-) Brad Pillatsch wrote the initial implementation of PKCS#12 import for Android. brunkj for help in tracking down an address book crash. Matthew Bordignon for ideas and help with testing. Stefano Costa for bug reports. Mark Clark for bug reports. Adrian Brown originally suggested the idea for location-based services friesenkiwi contributed sundry large patches to Android and drove the LOST integration. Mikael Berthe initiated the idea for the _cp attribute (which we removed in May 2018). Peter Lindemann raised his hand for translating the iOS app into Dutch. Federico Hernandez contributed the Swedish translation of the iOS app.","title":"Contributors"},{"location":"press/","text":"Press # English # OwnTracks Poster @ eclipsecon Europe 2015 German # Anwesenheitserkennung reloaded ownTracks & Mosquitto \u2013 Google Latitude-Clon im Eigenbau Latitude im Eigenbau \u2013 volle Kontrolle openHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung mentions OwnTracks openHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts","title":"Press"},{"location":"press/#press","text":"","title":"Press"},{"location":"press/#english","text":"OwnTracks Poster @ eclipsecon Europe 2015","title":"English"},{"location":"press/#german","text":"Anwesenheitserkennung reloaded ownTracks & Mosquitto \u2013 Google Latitude-Clon im Eigenbau Latitude im Eigenbau \u2013 volle Kontrolle openHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung mentions OwnTracks openHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts","title":"German"},{"location":"privacy/","text":"It's your data! # Your data should be yours. OwnTracks does all it can to ensure that, and you decide where you store your data, how to process it, and for how long you store it (if at all). However, be advised, that if you're very concerned about privacy, you probably shouldn't be using a smartphone at all. OwnTracks uses your smartphone's location services to determine where it is. While you decide whether you want to enable or disable this feature (check your phone's documentation), there is no guarantee that the APIs used by OwnTracks won't submit your data to the vendor's servers. For example, it's quite possible that Apple or Google keep requests used for reverse geo-coding your location; there is pretty much nothing OwnTracks can do to avoid this. As one of the developers writes: We could, with great sacrifices to code complexity, battery efficiency and performance code around all native services offered by the platform in order to use third party maps and geo coders. In that case Google might not receive your geocoder requests but another third party that sells it. We could also work around the Play Services by handling all the location acquiring the old way by querying the GPS/WIFI/Cell positioning ourselves. I however doubt that these information isn't sent to Google in that case too. The thing is, if you don't want Google or Apple to collect your position you have to disable location services in which case you don't have to bother installing the app anyway. It's your choice. Privacy Policy # Website Visitors # Like most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website. OwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below. Gathering of Personally-Identifying Information # Certain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in ways that require OwnTracks to gather personally-identifying information. The amount and type of information that OwnTracks gathers depends on the nature of the interaction. Those who engage in transactions with OwnTracks are asked to provide additional information, including as necessary the personal and financial information required to process those transactions. In each case, OwnTracks collects such information only insofar as is necessary or appropriate to fulfill the purpose of the visitor\u2019s interaction with OwnTracks. OwnTracks does not disclose personally-identifying information other than as described below. And visitors can always refuse to supply personally-identifying information, with the caveat that it may prevent them from engaging in certain website-related activities. OwnTracks collects personally-identifying information in the form of location reports made by OwnTracks' apps which use OwnTracks servers. This information may be stored in order to make it available to OwnTracks' users. Aggregated Statistics # OwnTracks may collect statistics about the behavior of visitors to its websites. OwnTracks may display this information publicly or provide it to others. However, OwnTracks does not disclose personally-identifying information other than as described below. Protection of Certain Personally-Identifying Information # OwnTracks discloses potentially personally-identifying and personally-identifying information only to those of its employees, contractors and affiliated organizations that (i) need to know that information in order to process it on OwnTracks\u2019s behalf or to provide services available at OwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others. Some of those employees, contractors and affiliated organizations may be located outside of your home country; by using OwnTracks\u2019s websites and servers, you consent to the transfer of such information to them. OwnTracks will not rent or sell potentially personally-identifying and personally-identifying information to anyone. Other than to its employees, contractors and affiliated organizations, as described above, OwnTracks discloses potentially personally-identifying and personally-identifying information only in response to a subpoena, court order or other governmental request, or when OwnTracks believes in good faith that disclosure is reasonably necessary to protect the property or rights of OwnTracks, third parties or the public at large. If you are a registered user of an OwnTracks website or service and have supplied your email address, OwnTracks may occasionally send you an email to tell you about new features, solicit your feedback, or just keep you up to date with what\u2019s going on with OwnTracks and our products. We primarily use our various product blogs to communicate this type of information, so we expect to keep this type of email to a minimum. If you send us a request (for example via a support email or via one of our feedback mechanisms), we reserve the right to publish it in order to help us clarify or respond to your request or to help us support other users. OwnTracks takes all measures reasonably necessary to protect against the unauthorized access, use, alteration or destruction of potentially personally-identifying and personally-identifying information. Cookies # A cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies. Business Transfers # If OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy. Ads # Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers. Privacy Policy Changes # Although most changes are likely to be minor, OwnTracks may change its Privacy Policy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks encourages visitors to frequently check this page for any changes to its Privacy Policy. Your continued use of this site after any change in this Privacy Policy will constitute your acceptance of such change. This privacy policy was adapted from Automattic's Privacy Policy .","title":"Privacy"},{"location":"privacy/#its-your-data","text":"Your data should be yours. OwnTracks does all it can to ensure that, and you decide where you store your data, how to process it, and for how long you store it (if at all). However, be advised, that if you're very concerned about privacy, you probably shouldn't be using a smartphone at all. OwnTracks uses your smartphone's location services to determine where it is. While you decide whether you want to enable or disable this feature (check your phone's documentation), there is no guarantee that the APIs used by OwnTracks won't submit your data to the vendor's servers. For example, it's quite possible that Apple or Google keep requests used for reverse geo-coding your location; there is pretty much nothing OwnTracks can do to avoid this. As one of the developers writes: We could, with great sacrifices to code complexity, battery efficiency and performance code around all native services offered by the platform in order to use third party maps and geo coders. In that case Google might not receive your geocoder requests but another third party that sells it. We could also work around the Play Services by handling all the location acquiring the old way by querying the GPS/WIFI/Cell positioning ourselves. I however doubt that these information isn't sent to Google in that case too. The thing is, if you don't want Google or Apple to collect your position you have to disable location services in which case you don't have to bother installing the app anyway. It's your choice.","title":"It's your data!"},{"location":"privacy/#privacy-policy","text":"","title":"Privacy Policy"},{"location":"privacy/#website-visitors","text":"Like most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website. OwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below.","title":"Website Visitors"},{"location":"privacy/#gathering-of-personally-identifying-information","text":"Certain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in ways that require OwnTracks to gather personally-identifying information. The amount and type of information that OwnTracks gathers depends on the nature of the interaction. Those who engage in transactions with OwnTracks are asked to provide additional information, including as necessary the personal and financial information required to process those transactions. In each case, OwnTracks collects such information only insofar as is necessary or appropriate to fulfill the purpose of the visitor\u2019s interaction with OwnTracks. OwnTracks does not disclose personally-identifying information other than as described below. And visitors can always refuse to supply personally-identifying information, with the caveat that it may prevent them from engaging in certain website-related activities. OwnTracks collects personally-identifying information in the form of location reports made by OwnTracks' apps which use OwnTracks servers. This information may be stored in order to make it available to OwnTracks' users.","title":"Gathering of Personally-Identifying Information"},{"location":"privacy/#aggregated-statistics","text":"OwnTracks may collect statistics about the behavior of visitors to its websites. OwnTracks may display this information publicly or provide it to others. However, OwnTracks does not disclose personally-identifying information other than as described below.","title":"Aggregated Statistics"},{"location":"privacy/#protection-of-certain-personally-identifying-information","text":"OwnTracks discloses potentially personally-identifying and personally-identifying information only to those of its employees, contractors and affiliated organizations that (i) need to know that information in order to process it on OwnTracks\u2019s behalf or to provide services available at OwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others. Some of those employees, contractors and affiliated organizations may be located outside of your home country; by using OwnTracks\u2019s websites and servers, you consent to the transfer of such information to them. OwnTracks will not rent or sell potentially personally-identifying and personally-identifying information to anyone. Other than to its employees, contractors and affiliated organizations, as described above, OwnTracks discloses potentially personally-identifying and personally-identifying information only in response to a subpoena, court order or other governmental request, or when OwnTracks believes in good faith that disclosure is reasonably necessary to protect the property or rights of OwnTracks, third parties or the public at large. If you are a registered user of an OwnTracks website or service and have supplied your email address, OwnTracks may occasionally send you an email to tell you about new features, solicit your feedback, or just keep you up to date with what\u2019s going on with OwnTracks and our products. We primarily use our various product blogs to communicate this type of information, so we expect to keep this type of email to a minimum. If you send us a request (for example via a support email or via one of our feedback mechanisms), we reserve the right to publish it in order to help us clarify or respond to your request or to help us support other users. OwnTracks takes all measures reasonably necessary to protect against the unauthorized access, use, alteration or destruction of potentially personally-identifying and personally-identifying information.","title":"Protection of Certain Personally-Identifying Information"},{"location":"privacy/#cookies","text":"A cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies.","title":"Cookies"},{"location":"privacy/#business-transfers","text":"If OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy.","title":"Business Transfers"},{"location":"privacy/#ads","text":"Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers.","title":"Ads"},{"location":"privacy/#privacy-policy-changes","text":"Although most changes are likely to be minor, OwnTracks may change its Privacy Policy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks encourages visitors to frequently check this page for any changes to its Privacy Policy. Your continued use of this site after any change in this Privacy Policy will constitute your acceptance of such change. This privacy policy was adapted from Automattic's Privacy Policy .","title":"Privacy Policy Changes"},{"location":"terminology/","text":"Terminology # Some of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with. MQTT # MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers And what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of your friends ). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same MQTT broker . There are a number of clients which do that already, and we're even going to show you how you can create your own client for specific purposes. Pub/Sub # In MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so. broker # A MQTT broker is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message. publish # The act of sending a message to a broker. topic # Each message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to. subscribe # Clients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic owntracks/jane/iphone will, for example, not receive a message that is published to owntracks/john/nexus . QoS # QoS or Quality of Service , specifies how the app should attempt to publish messages to an MQTT broker. QoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged. QoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times. QoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer. Retain # When a message is published to a broker with the durable or retain flat set, it means that the MQTT broker will attempt to store the last published message on a particular topic. A client which subscribes to that topic will receive that last retained message once it connects to the broker. Geocoding # Reverse geocoding is the act of looking up the address for a pair of coordinates. Geofence or Region # A geofence or a region is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.","title":"Terminology"},{"location":"terminology/#terminology","text":"Some of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with.","title":"Terminology"},{"location":"terminology/#mqtt","text":"MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers And what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of your friends ). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same MQTT broker . There are a number of clients which do that already, and we're even going to show you how you can create your own client for specific purposes.","title":"MQTT"},{"location":"terminology/#pubsub","text":"In MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so.","title":"Pub/Sub"},{"location":"terminology/#broker","text":"A MQTT broker is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message.","title":"broker"},{"location":"terminology/#publish","text":"The act of sending a message to a broker.","title":"publish"},{"location":"terminology/#topic","text":"Each message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to.","title":"topic"},{"location":"terminology/#subscribe","text":"Clients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic owntracks/jane/iphone will, for example, not receive a message that is published to owntracks/john/nexus .","title":"subscribe"},{"location":"terminology/#qos","text":"QoS or Quality of Service , specifies how the app should attempt to publish messages to an MQTT broker. QoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged. QoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times. QoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer.","title":"QoS"},{"location":"terminology/#retain","text":"When a message is published to a broker with the durable or retain flat set, it means that the MQTT broker will attempt to store the last published message on a particular topic. A client which subscribes to that topic will receive that last retained message once it connects to the broker.","title":"Retain"},{"location":"terminology/#geocoding","text":"Reverse geocoding is the act of looking up the address for a pair of coordinates.","title":"Geocoding"},{"location":"terminology/#geofence-or-region","text":"A geofence or a region is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.","title":"Geofence or Region"},{"location":"clients/recorder/","text":"Recorder # The OwnTracks Recorder is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database. Docker # We have a multi-architecture Docker image which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. You pass environment variables into the container to configure it. This is documented on the docker-recorder repository. Recorder on Synology # After installing Docker on your compatible Synology DiskStation, click on Image and Add the Recorder image from the URL https://hub.docker.com/r/owntracks/recorder ; you do not have to specify a username/password. Select latest when prompted to choose a tag. In list of images you should then see one called owntracks/recorder:latest as shown below. Then, click on Launch in the same window, select a container name (or leave it as owntracks-recorder1 ) and click on Advanced Settings . Under Volume , add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the /store mount path. Under Port Settings , ensure Local Port 8083 is mapped to Container Port 8083 ; you will have to replace Auto by 8083 . Under Environment , add two variables: OTR_HOST with the address or host name of your MQTT broker and OTR_PORT with its port number (typically 1883 ). If you need authentication, check the Recorder documentation for further variables you can set to configure that. Just before running the container, you should see something like this with the settings you specified: When you launch the container, it will show up in the Container tab: You should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above. Upgrades to the container running on your Synology DiskStation are easily done from the command line: $ docker stop owntracks-recorder1 $ docker pull owntracks/recorder:latest $ docker start owntracks-recorder1","title":"Recorder"},{"location":"clients/recorder/#recorder","text":"The OwnTracks Recorder is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database.","title":"Recorder"},{"location":"clients/recorder/#docker","text":"We have a multi-architecture Docker image which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. You pass environment variables into the container to configure it. This is documented on the docker-recorder repository.","title":"Docker"},{"location":"clients/recorder/#recorder-on-synology","text":"After installing Docker on your compatible Synology DiskStation, click on Image and Add the Recorder image from the URL https://hub.docker.com/r/owntracks/recorder ; you do not have to specify a username/password. Select latest when prompted to choose a tag. In list of images you should then see one called owntracks/recorder:latest as shown below. Then, click on Launch in the same window, select a container name (or leave it as owntracks-recorder1 ) and click on Advanced Settings . Under Volume , add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the /store mount path. Under Port Settings , ensure Local Port 8083 is mapped to Container Port 8083 ; you will have to replace Auto by 8083 . Under Environment , add two variables: OTR_HOST with the address or host name of your MQTT broker and OTR_PORT with its port number (typically 1883 ). If you need authentication, check the Recorder documentation for further variables you can set to configure that. Just before running the container, you should see something like this with the settings you specified: When you launch the container, it will show up in the Container tab: You should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above. Upgrades to the container running on your Synology DiskStation are easily done from the command line: $ docker stop owntracks-recorder1 $ docker pull owntracks/recorder:latest $ docker start owntracks-recorder1","title":"Recorder on Synology"},{"location":"features/android/","text":"Android specifics # The broker connection works well with: No TLS (i.e. plain) TLS with Android system certificate authorities TLS with side-loaded user-provided self signed certificate authorities TLS with client certificates Username/password authentication to broker. Automatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is available. Display of a marker at which the app believes the user to be at (last known location) Reverse geo coding that displays the address of last known location Accuracy of last known location Button to manually publish last known (i.e. probably current) location General Restrictions on Android 6 and higher. # Since Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations. You may find HTTP mode more reliable on Android 6 and higher. The ongoing notification is required to run in the background. App standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings > Battery > Battery Optimization. Outgoing messages may only be sent in batched intervals. Location updates or event messages may be delayed. Incoming messages such as events might be delayed. When using MQTT, the broker connection is not guaranteed to be maintained permanently. A reconnect will be attempted regularly or when a message is sent. If the connection is established without the clean session flag, missed messages will be received once connected. Beacons are no long supported in OwnTracks for Android Vendor background restrictions # Certain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits. A list of vendors known to interfer with background apps and a number of workarounds can be found at Don\u2019t kill my app! . Google Play Services # Google Play Services are required to use OwnTracks that's distributed on the Google Play Store. They are used for: Battery efficient location access Scheduling of background jobs Resolving coordinates to addresses (an alterative Geocoding service can be configured) Displaying the map A separate \"flavour\" of OwnTracks called \"OSS\" aims to remove this dependency for people that can't or prefer not to use Google Play Services. This version will use other providers for maps, geocoding and location and is currently in development. The plan is to release this via the F-Droid app catalogue. Setup # In the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things. By default a TLS secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device. In recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system. In HTTP mode the url is required to connect. In MQTT mode the host and username and password is required to connect. Debug Log # Since Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app. To generate the logs, follow the next steps: Temporarily grant write access to local storage. Go to Android App Info > Permissions and enable the storage permission. Open the log viewer at Status > View Logs The most recent logs are displayed. To view debug log entries as well, select the Debug Logs option in the top right menu. The Share button (bottom right) allows the logs to be exported and shared, either to disk (via a suitable file manager app such as Total Commander ) or sent over email. Automation via Tasker, Automagic, etc. # Since Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined modes : Move , Significant location change , Manual , Quiet . To set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action. Do not put any text into the fields listed as [LEAVE FIELD BLANK] above. Tasker example: # To trigger Move mode in tasker, create a Send Intent action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Cat: None Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra(1): monitoring:2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Package: [LEAVE FIELD BLANK] Class: [LEAVE FIELD BLANK] Target: Service Mode Send This Extra Value Quiet monitoring:-1 Manual monitoring:0 Significant Changes monitoring:1 Move monitoring:2 Macrodroid example: # To trigger Move mode in tasker, create a Send Intent action and enter the following information: Target: Service Action: org.owntracks.android.CHANGE_MONITORING Package: org.owntracks.android Class: [LEAVE FIELD BLANK] Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra 1 parameter name: monitoring Extra 1 value: 2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Extra(4): [LEAVE FIELD BLANK] Mode Send This Extra Value Quiet -1 Manual 0 Significant Changes 1 Move 2 Automagic example: # To trigger Move mode in Automagic, create a Start Service action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Category List: [LEAVE FIELD BLANK] Data URI: [LEAVE FIELD BLANK] Data MIME Type: [LEAVE FIELD BLANK] Explicit Component: ticked Package Name: org.owntracks.android Class Name: [LEAVE FIELD BLANK] Flag List: [LEAVE FIELD BLANK] Extra: putInt(\"MONITORING\": 2) Mode Send This Extra Value Quiet putInt(\"monitoring\": -1) Manual putInt(\"monitoring\": 0) Significant Changes putInt(\"monitoring\": 1) Move putInt(\"monitoring\": 2) Other intents are, for instance: org.owntracks.android.SEND_LOCATION_USER sends a manual report (i.e. pushes a location) ADB example # It's possible to send an intent to OwnTracks using the am command on the device shell. You just need to call start-service with the correct action, and optionally the extra that you need to set the specific mode. E.g. to set move mode: am start-service -a org.owntracks.android.CHANGE_MONITORING --ei monitoring 2","title":"Android"},{"location":"features/android/#android-specifics","text":"The broker connection works well with: No TLS (i.e. plain) TLS with Android system certificate authorities TLS with side-loaded user-provided self signed certificate authorities TLS with client certificates Username/password authentication to broker. Automatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is available. Display of a marker at which the app believes the user to be at (last known location) Reverse geo coding that displays the address of last known location Accuracy of last known location Button to manually publish last known (i.e. probably current) location","title":"Android specifics"},{"location":"features/android/#general-restrictions-on-android-6-and-higher","text":"Since Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations. You may find HTTP mode more reliable on Android 6 and higher. The ongoing notification is required to run in the background. App standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings > Battery > Battery Optimization. Outgoing messages may only be sent in batched intervals. Location updates or event messages may be delayed. Incoming messages such as events might be delayed. When using MQTT, the broker connection is not guaranteed to be maintained permanently. A reconnect will be attempted regularly or when a message is sent. If the connection is established without the clean session flag, missed messages will be received once connected. Beacons are no long supported in OwnTracks for Android","title":"General Restrictions on Android 6 and higher."},{"location":"features/android/#vendor-background-restrictions","text":"Certain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits. A list of vendors known to interfer with background apps and a number of workarounds can be found at Don\u2019t kill my app! .","title":"Vendor background restrictions"},{"location":"features/android/#google-play-services","text":"Google Play Services are required to use OwnTracks that's distributed on the Google Play Store. They are used for: Battery efficient location access Scheduling of background jobs Resolving coordinates to addresses (an alterative Geocoding service can be configured) Displaying the map A separate \"flavour\" of OwnTracks called \"OSS\" aims to remove this dependency for people that can't or prefer not to use Google Play Services. This version will use other providers for maps, geocoding and location and is currently in development. The plan is to release this via the F-Droid app catalogue.","title":"Google Play Services"},{"location":"features/android/#setup","text":"In the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things. By default a TLS secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device. In recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system. In HTTP mode the url is required to connect. In MQTT mode the host and username and password is required to connect.","title":"Setup"},{"location":"features/android/#debug-log","text":"Since Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app. To generate the logs, follow the next steps: Temporarily grant write access to local storage. Go to Android App Info > Permissions and enable the storage permission. Open the log viewer at Status > View Logs The most recent logs are displayed. To view debug log entries as well, select the Debug Logs option in the top right menu. The Share button (bottom right) allows the logs to be exported and shared, either to disk (via a suitable file manager app such as Total Commander ) or sent over email.","title":"Debug Log"},{"location":"features/android/#automation-via-tasker-automagic-etc","text":"Since Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined modes : Move , Significant location change , Manual , Quiet . To set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action. Do not put any text into the fields listed as [LEAVE FIELD BLANK] above.","title":"Automation via Tasker, Automagic, etc."},{"location":"features/android/#tasker-example","text":"To trigger Move mode in tasker, create a Send Intent action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Cat: None Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra(1): monitoring:2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Package: [LEAVE FIELD BLANK] Class: [LEAVE FIELD BLANK] Target: Service Mode Send This Extra Value Quiet monitoring:-1 Manual monitoring:0 Significant Changes monitoring:1 Move monitoring:2","title":"Tasker example:"},{"location":"features/android/#macrodroid-example","text":"To trigger Move mode in tasker, create a Send Intent action and enter the following information: Target: Service Action: org.owntracks.android.CHANGE_MONITORING Package: org.owntracks.android Class: [LEAVE FIELD BLANK] Mime Type: [LEAVE FIELD BLANK] Data: [LEAVE FIELD BLANK] Extra 1 parameter name: monitoring Extra 1 value: 2 Extra(2): [LEAVE FIELD BLANK] Extra(3): [LEAVE FIELD BLANK] Extra(4): [LEAVE FIELD BLANK] Mode Send This Extra Value Quiet -1 Manual 0 Significant Changes 1 Move 2","title":"Macrodroid example:"},{"location":"features/android/#automagic-example","text":"To trigger Move mode in Automagic, create a Start Service action and enter the following information: Action: org.owntracks.android.CHANGE_MONITORING Category List: [LEAVE FIELD BLANK] Data URI: [LEAVE FIELD BLANK] Data MIME Type: [LEAVE FIELD BLANK] Explicit Component: ticked Package Name: org.owntracks.android Class Name: [LEAVE FIELD BLANK] Flag List: [LEAVE FIELD BLANK] Extra: putInt(\"MONITORING\": 2) Mode Send This Extra Value Quiet putInt(\"monitoring\": -1) Manual putInt(\"monitoring\": 0) Significant Changes putInt(\"monitoring\": 1) Move putInt(\"monitoring\": 2) Other intents are, for instance: org.owntracks.android.SEND_LOCATION_USER sends a manual report (i.e. pushes a location)","title":"Automagic example:"},{"location":"features/android/#adb-example","text":"It's possible to send an intent to OwnTracks using the am command on the device shell. You just need to call start-service with the correct action, and optionally the extra that you need to set the specific mode. E.g. to set move mode: am start-service -a org.owntracks.android.CHANGE_MONITORING --ei monitoring 2","title":"ADB example"},{"location":"features/beacons/","text":"iBeacons # If you want to monitor an iBeacon region rather than a circular region set the radius to zero ( 0 ) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers. Set the UUID of the beacon, and you can optionally specify the major and/or minor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor. Setting major or minor number to zero ( 0 ) means no major or minor number is specified. Note that you should probably not use major or minor number 0 , because the meaning of 0 is \"any\". If the UUID is valid, iBeacon monitoring will start. Examples: Name myBeacons UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 0 Minor 0 Name mySpecificBeacon UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 1 Minor 33000 In the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas in the second example, OwnTracks would monitor just that one specific beacon with the major number 1 and the minor number 33000 . Notes # The app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection. If you use a - as the first character in your Waypoint description e.g. -MyBeacon , the app will ignore short disruptions of the connection to the beacon (hold down). Setting the radius to a negative value (e.g. -1 ) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the share option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car. Example: office # Upon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question. Instead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive iBeacons can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably. Beacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined major and minor numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The major number can be used, say, to identify an office building, whereas you'd configure a beacon's minor number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same major and minor numbers. Let's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the major and minor numbers. (How a beacon gets it's UUID, major , and minor set depends on the product.) We define a UUID, say, DEADBEEF-ABBA-CAFE-AFFE-123456789012 which we assign to all beacons, and configure them accordingly. (The Blukii iBeacons we use have a utility with which we can configure them accordingly.) What we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose Main@WestWing here) by a colon. A beacon's major and minor are optionally concatenated to that string, also colon-separated. Instead of painstakingly configuring this on the device proper, I prepare a small file called office.otrw (the .otrw extension is important), with the following JSON payload: { \"waypoints\" : [ { \"tst\" : 1432817332, \"lat\" : 52.0, \"_type\" : \"waypoint\", \"lon\" : 6.0, \"rad\" : 0, \"desc\" : \"Main@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001\" } ], \"_type\" : \"waypoints\" } I then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured. From this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an enter or leave event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification. We publish these events as JSON via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please. { \"_type\": \"transition\", \"acc\": 65, \"desc\": \"Main@WestWing\", \"event\": \"enter\", \"lat\": 2.2222, \"lon\": 1.1111, \"tid\": \"jp\", \"tst\": 1433342520, \"wtst\": 1432817332 } For instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc. To summarize: OwnTracks can monitor beacons by configuring it either with: a UUID only, in which case the app would report any beacon with that UUID, irrespective of its major / minor numbers. a UUID with a major number: the app would report iBeacons with the specified UUID and exactly that major number all three: the UUID , the major and minor numbers, in which case the app reports events on precisely that beacon. More examples # Where exactly did I park my car?","title":"Beacons"},{"location":"features/beacons/#ibeacons","text":"If you want to monitor an iBeacon region rather than a circular region set the radius to zero ( 0 ) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers. Set the UUID of the beacon, and you can optionally specify the major and/or minor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor. Setting major or minor number to zero ( 0 ) means no major or minor number is specified. Note that you should probably not use major or minor number 0 , because the meaning of 0 is \"any\". If the UUID is valid, iBeacon monitoring will start. Examples: Name myBeacons UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 0 Minor 0 Name mySpecificBeacon UUID CA271EAE-5FA8-4E80-8F08-2A302A95A959 Major 1 Minor 33000 In the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas in the second example, OwnTracks would monitor just that one specific beacon with the major number 1 and the minor number 33000 .","title":"iBeacons"},{"location":"features/beacons/#notes","text":"The app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection. If you use a - as the first character in your Waypoint description e.g. -MyBeacon , the app will ignore short disruptions of the connection to the beacon (hold down). Setting the radius to a negative value (e.g. -1 ) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the share option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car.","title":"Notes"},{"location":"features/beacons/#example-office","text":"Upon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question. Instead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive iBeacons can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably. Beacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined major and minor numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The major number can be used, say, to identify an office building, whereas you'd configure a beacon's minor number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same major and minor numbers. Let's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the major and minor numbers. (How a beacon gets it's UUID, major , and minor set depends on the product.) We define a UUID, say, DEADBEEF-ABBA-CAFE-AFFE-123456789012 which we assign to all beacons, and configure them accordingly. (The Blukii iBeacons we use have a utility with which we can configure them accordingly.) What we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose Main@WestWing here) by a colon. A beacon's major and minor are optionally concatenated to that string, also colon-separated. Instead of painstakingly configuring this on the device proper, I prepare a small file called office.otrw (the .otrw extension is important), with the following JSON payload: { \"waypoints\" : [ { \"tst\" : 1432817332, \"lat\" : 52.0, \"_type\" : \"waypoint\", \"lon\" : 6.0, \"rad\" : 0, \"desc\" : \"Main@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001\" } ], \"_type\" : \"waypoints\" } I then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured. From this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an enter or leave event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification. We publish these events as JSON via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please. { \"_type\": \"transition\", \"acc\": 65, \"desc\": \"Main@WestWing\", \"event\": \"enter\", \"lat\": 2.2222, \"lon\": 1.1111, \"tid\": \"jp\", \"tst\": 1433342520, \"wtst\": 1432817332 } For instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc. To summarize: OwnTracks can monitor beacons by configuring it either with: a UUID only, in which case the app would report any beacon with that UUID, irrespective of its major / minor numbers. a UUID with a major number: the app would report iBeacons with the specified UUID and exactly that major number all three: the UUID , the major and minor numbers, in which case the app reports events on precisely that beacon.","title":"Example: office"},{"location":"features/beacons/#more-examples","text":"Where exactly did I park my car?","title":"More examples"},{"location":"features/card/","text":"Card # OwnTracks typically displays the TID of a friend on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name. We developed a new feature we call a card which you can use when in both MQTT mode and HTTP mode . A card is a retained message which contains a JSON payload which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device. { \"_type\": \"card\", \"name\": \"Jane Jolie\", \"face\": \"iV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg==\" } Creating a card # Cards can be created with shell scripts, say, or on iOS with the OwnTracks app itself. Shell Script # We provide several utilities for creating a card in the Recorder's repository : If you have an image file you want to use, use image2card.sh , passing image-filename and fullname . If you know a user has a Github profile with a name and an avatar, use github2card.py which takes a Github username as argument. If you know a user has a Gravatar, use gravatar2card.sh , passing email and fullname . Our quicksetup code contains an example which uses jo(1) . These utilities create a card on standard output, and you typically then publish the result as a retained message to your MQTT broker: ./github2card.py defunkt > my-card.json mosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r -q 2 Note the topic branch ending in info and note the use of the retain ( -r ) and qos ( -q ) flags. iOS OwnTracks # on iOS and iPadOS the Create Card option in Settings permits creating a card directly on device. The app permits entering a name for the card as well as use the on-device camera to take a photograph or select from the photo library to use for the face element of the card. Hitting Save in the app then publishes the card to the current user's topic. Generating the face image # We recommend formatting the face image as a 192x192 pixel image, encoded either as a JPEG or as a PNG. It is possible to use larger or smaller images, but 192x192 provides a good balance between image fidelity and data usage. Remember that this image will be transmitted many times over cellular data to all phones that use the app, so using very large images can be very costly. You should use JPEG encoding when the image depicts something complex, such as a photography of a real face. You should use PNG encoding when the image only contains simple flat colors, such as icons or drawings. We also recommend compressing the image to further save on data usage. A good app for this is Squoosh , but be warned that it uses Google trackers . For JPEG, the MozJPEG encoder with default settings is usually very good, and for PNG, the OxiPNG encoder with default settings is usually very good. Cards in Recorder in HTTP mode # Using HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in the following two paths, with the first found winning: <STORAGEDIR>/cards/<user>/<user>-<device>.json <STORAGEDIR>/cards/<user>/<user>.json So, if \"jane\" is a friend with a device \"s8\" , the Recorder will load Jane's JSON card from the path <STORAGEDIR>/cards/jane/jane-s8.json. If Jane's device-specific card doesn't exist, her card is loaded from <STORAGEDIR>/cards/jane.json and silently ignored if that doesn't exist. (Note that as usual in Recorder, usernames and device names are lowercased.) In contrib/faces/ of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the .json file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with jq . < file.json or python -mjson.tool file.json .)","title":"Card"},{"location":"features/card/#card","text":"OwnTracks typically displays the TID of a friend on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name. We developed a new feature we call a card which you can use when in both MQTT mode and HTTP mode . A card is a retained message which contains a JSON payload which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device. { \"_type\": \"card\", \"name\": \"Jane Jolie\", \"face\": \"iV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg==\" }","title":"Card"},{"location":"features/card/#creating-a-card","text":"Cards can be created with shell scripts, say, or on iOS with the OwnTracks app itself.","title":"Creating a card"},{"location":"features/card/#shell-script","text":"We provide several utilities for creating a card in the Recorder's repository : If you have an image file you want to use, use image2card.sh , passing image-filename and fullname . If you know a user has a Github profile with a name and an avatar, use github2card.py which takes a Github username as argument. If you know a user has a Gravatar, use gravatar2card.sh , passing email and fullname . Our quicksetup code contains an example which uses jo(1) . These utilities create a card on standard output, and you typically then publish the result as a retained message to your MQTT broker: ./github2card.py defunkt > my-card.json mosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r -q 2 Note the topic branch ending in info and note the use of the retain ( -r ) and qos ( -q ) flags.","title":"Shell Script"},{"location":"features/card/#ios-owntracks","text":"on iOS and iPadOS the Create Card option in Settings permits creating a card directly on device. The app permits entering a name for the card as well as use the on-device camera to take a photograph or select from the photo library to use for the face element of the card. Hitting Save in the app then publishes the card to the current user's topic.","title":"iOS OwnTracks"},{"location":"features/card/#generating-the-face-image","text":"We recommend formatting the face image as a 192x192 pixel image, encoded either as a JPEG or as a PNG. It is possible to use larger or smaller images, but 192x192 provides a good balance between image fidelity and data usage. Remember that this image will be transmitted many times over cellular data to all phones that use the app, so using very large images can be very costly. You should use JPEG encoding when the image depicts something complex, such as a photography of a real face. You should use PNG encoding when the image only contains simple flat colors, such as icons or drawings. We also recommend compressing the image to further save on data usage. A good app for this is Squoosh , but be warned that it uses Google trackers . For JPEG, the MozJPEG encoder with default settings is usually very good, and for PNG, the OxiPNG encoder with default settings is usually very good.","title":"Generating the face image"},{"location":"features/card/#cards-in-recorder-in-http-mode","text":"Using HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in the following two paths, with the first found winning: <STORAGEDIR>/cards/<user>/<user>-<device>.json <STORAGEDIR>/cards/<user>/<user>.json So, if \"jane\" is a friend with a device \"s8\" , the Recorder will load Jane's JSON card from the path <STORAGEDIR>/cards/jane/jane-s8.json. If Jane's device-specific card doesn't exist, her card is loaded from <STORAGEDIR>/cards/jane.json and silently ignored if that doesn't exist. (Note that as usual in Recorder, usernames and device names are lowercased.) In contrib/faces/ of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the .json file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with jq . < file.json or python -mjson.tool file.json .)","title":"Cards in Recorder in HTTP mode"},{"location":"features/comparison/","text":"iOS / Android compared # Our OwnTracks apps try to be on par in terms of features, but there are differences. This table lists the main features, and specifics for Android and iOS are documented. Feature iOS Android MQTT mode Y Y HTTP mode Y Y Location reporting Y Y TLS with system certificate Y Y Plain connections (no TLS) Y Y Username/password authentication Y Y Reconnection to broker Y Y Automatic PUB after move Y Y Automatic PUB after time Y Y Button for manual publish Y Y Move mode Y Y Map with TID markers Y Y Support for CARD on map Y Y Reverse geocoding on map Y Y Use of external geocoders ( OpenCage ) Y Accuracy of last-known loc Y Y Friends list Y Y Geofencing (a.k.a. Regions ) Y Y Transition events (enter / leave) Y Y Location data (payload) published as JSON Y Y iBeacons Y Step-counting, a.k.a pedometer Y Barometric pressure in location payloads Y Payload encryption Y Y Submit Points of Interest (POI) Y On-device Tour configuration Y Popup an info tab on command Y Debugging with on-device logs Y Y Supports POSTing to Traccar Y Y Configurable settings Y Y Configuration editor Y Remote and URL configuration Y Y Configuration via QR code Y","title":"Comparison"},{"location":"features/comparison/#ios-android-compared","text":"Our OwnTracks apps try to be on par in terms of features, but there are differences. This table lists the main features, and specifics for Android and iOS are documented. Feature iOS Android MQTT mode Y Y HTTP mode Y Y Location reporting Y Y TLS with system certificate Y Y Plain connections (no TLS) Y Y Username/password authentication Y Y Reconnection to broker Y Y Automatic PUB after move Y Y Automatic PUB after time Y Y Button for manual publish Y Y Move mode Y Y Map with TID markers Y Y Support for CARD on map Y Y Reverse geocoding on map Y Y Use of external geocoders ( OpenCage ) Y Accuracy of last-known loc Y Y Friends list Y Y Geofencing (a.k.a. Regions ) Y Y Transition events (enter / leave) Y Y Location data (payload) published as JSON Y Y iBeacons Y Step-counting, a.k.a pedometer Y Barometric pressure in location payloads Y Payload encryption Y Y Submit Points of Interest (POI) Y On-device Tour configuration Y Popup an info tab on command Y Debugging with on-device logs Y Y Supports POSTing to Traccar Y Y Configurable settings Y Y Configuration editor Y Remote and URL configuration Y Y Configuration via QR code Y","title":"iOS / Android compared"},{"location":"features/debug/","text":"Debugging # Designing mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest. Christoph and Alexander know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today. Be that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for. First and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory. Check whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so. Is your broker running and can it be reached by your device? We've given you tips on configuring your broker . Make liberal use of the Mosquitto clients to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.","title":"Debug"},{"location":"features/debug/#debugging","text":"Designing mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest. Christoph and Alexander know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today. Be that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for. First and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory. Check whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so. Is your broker running and can it be reached by your device? We've given you tips on configuring your broker . Make liberal use of the Mosquitto clients to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.","title":"Debugging"},{"location":"features/encrypt/","text":"Payload encryption # In addition to the transport encryption via TLS (over MQTT and HTTPS), the OwnTracks apps support payload encryption using libsodium , in particular secret-key authenticated encryption . We have also implemented support for payload encryption (i.e. decryption) in the OwnTracks Recorder . You configure a secret (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt outgoing JSON with this secret and transport the payload in a new JSON object which looks like this: { \"_type\": \"encrypted\", \"data\": \"1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg=\" } If you want to share location with a friend, both you and your friend need to share the same secret . A secret should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different secret keys. Encryption key # For the OwnTracks apps, the encryption key can be configured as follows: Android and iOS via the settings UI / configuration editor Android and iOS also via configuration file from the encryptionKey setting The key is a string of up to 32 characters in length which the apps pad with binary zeroes. Recorder # You can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder. Add a key by determining the username and the device name of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the username is jjolie and the device name is Phone , the result will be jjolie-phone . Load the key into the (running) Recorder: printf \"jjolie-phone mysecreTpass01\" | ocat --load=keys From this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of _type: encrypted . The Recorder will decrypt the payload and will store the result in plain text in its storage. You can check which decryption keys you have stored by running: ocat --dump=keys You can also delete entries for specific devices by replacing the encryption key with DELETE : printf \"jjolie-phone DELETE\" | ocat --load=keys Be aware that this is a very powerful command that can corrupt your database if you write it incorrectly! Configuring encryption in Quicksetup # Using quicksetup you can optionally configure payload encryption for a user: configure the friends array with an element secret for that user: friends: - { tid: j2, username: jjolie, devicename: Phone, secret: \"mysecreTpass01\" } if you prefer to not have the secret in that configuration, write it into a file on the file system and specify the path in lieu of the actual secret, i.e. secret: \"/path/to/.jjolie.key\" $ printf \"mysecreTpass01\" > .jjolie.key after rerunning the bootstrap program, the user's .otrc file will have the secret configured: $ grep encryption /usr/local/owntracks/userdata/jjolie.otrc \"encryptionKey\": \"mysecreTpass01\", the Recorder's key store will also have the key: $ ocat --dump=keys jjolie-phone mysecreTpass01 Note that the secret is in clear text in the configuration file, the key file, the Recorder's key store, and in the .otrc file! Notes # Payload encryption makes little sense for just one user on a shared installation. Assume Alice and Bob share a broker. Alice has configured payload encryption and her device publishes a location message. The Recorder receives that payload, decrypts it (assuming it too has Alice's key), and stores the result. Note that the Recorder will not automatically republish Alice's location, so Bob won't receive that data. In order to accomplish this, one would have to configure the Recorder to republish using Lua those messages with the _decrypted element in them. In an environment consisting of a group of people who wish to communicate securely, payload encryption might make sense.","title":"Encrypt"},{"location":"features/encrypt/#payload-encryption","text":"In addition to the transport encryption via TLS (over MQTT and HTTPS), the OwnTracks apps support payload encryption using libsodium , in particular secret-key authenticated encryption . We have also implemented support for payload encryption (i.e. decryption) in the OwnTracks Recorder . You configure a secret (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt outgoing JSON with this secret and transport the payload in a new JSON object which looks like this: { \"_type\": \"encrypted\", \"data\": \"1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg=\" } If you want to share location with a friend, both you and your friend need to share the same secret . A secret should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different secret keys.","title":"Payload encryption"},{"location":"features/encrypt/#encryption-key","text":"For the OwnTracks apps, the encryption key can be configured as follows: Android and iOS via the settings UI / configuration editor Android and iOS also via configuration file from the encryptionKey setting The key is a string of up to 32 characters in length which the apps pad with binary zeroes.","title":"Encryption key"},{"location":"features/encrypt/#recorder","text":"You can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder. Add a key by determining the username and the device name of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the username is jjolie and the device name is Phone , the result will be jjolie-phone . Load the key into the (running) Recorder: printf \"jjolie-phone mysecreTpass01\" | ocat --load=keys From this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of _type: encrypted . The Recorder will decrypt the payload and will store the result in plain text in its storage. You can check which decryption keys you have stored by running: ocat --dump=keys You can also delete entries for specific devices by replacing the encryption key with DELETE : printf \"jjolie-phone DELETE\" | ocat --load=keys Be aware that this is a very powerful command that can corrupt your database if you write it incorrectly!","title":"Recorder"},{"location":"features/encrypt/#configuring-encryption-in-quicksetup","text":"Using quicksetup you can optionally configure payload encryption for a user: configure the friends array with an element secret for that user: friends: - { tid: j2, username: jjolie, devicename: Phone, secret: \"mysecreTpass01\" } if you prefer to not have the secret in that configuration, write it into a file on the file system and specify the path in lieu of the actual secret, i.e. secret: \"/path/to/.jjolie.key\" $ printf \"mysecreTpass01\" > .jjolie.key after rerunning the bootstrap program, the user's .otrc file will have the secret configured: $ grep encryption /usr/local/owntracks/userdata/jjolie.otrc \"encryptionKey\": \"mysecreTpass01\", the Recorder's key store will also have the key: $ ocat --dump=keys jjolie-phone mysecreTpass01 Note that the secret is in clear text in the configuration file, the key file, the Recorder's key store, and in the .otrc file!","title":"Configuring encryption in Quicksetup"},{"location":"features/encrypt/#notes","text":"Payload encryption makes little sense for just one user on a shared installation. Assume Alice and Bob share a broker. Alice has configured payload encryption and her device publishes a location message. The Recorder receives that payload, decrypts it (assuming it too has Alice's key), and stores the result. Note that the Recorder will not automatically republish Alice's location, so Bob won't receive that data. In order to accomplish this, one would have to configure the Recorder to republish using Lua those messages with the _decrypted element in them. In an environment consisting of a group of people who wish to communicate securely, payload encryption might make sense.","title":"Notes"},{"location":"features/featured/","text":"Featured # The iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type cmd : {\"action\": \"action\", \"content\": \"hello there!\", \"_type\": \"cmd\"} You can use url instead of content in the payload, in which case the tab opens with the appropriate URL loaded. {\"action\": \"action\", \"url\": \"http://example.com\", \"_type\": \"cmd\"} The tab pops up silently, i.e. without notification, and selecting the tab displays it. The open tab silently disappears if content and url are omitted. See also: Switching lights with OwnTracks, iBeacons, and openHAB","title":"Featured"},{"location":"features/featured/#featured","text":"The iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type cmd : {\"action\": \"action\", \"content\": \"hello there!\", \"_type\": \"cmd\"} You can use url instead of content in the payload, in which case the tab opens with the appropriate URL loaded. {\"action\": \"action\", \"url\": \"http://example.com\", \"_type\": \"cmd\"} The tab pops up silently, i.e. without notification, and selecting the tab displays it. The open tab silently disappears if content and url are omitted. See also: Switching lights with OwnTracks, iBeacons, and openHAB","title":"Featured"},{"location":"features/friends/","text":"Friends # OwnTracks has a so-called Friends and Family capability which is enabled by default. The way this works is friends and/or family members who share a single MQTT broker can \"see\" eachother on the map, respectively on a list of friends held by the app. (This can be done either by configuring all apps to use the same broker or by what is called bridging .) Let's assume for a moment, that a user Jane (user name jjolie ) has an iPhone 4s (device name 4s ), and that she publishes location data to a topic at owntracks/jjolie/4s Let us further assume, that her friend John (user name john ) has an Android Nexus 4 (device name nex4 ) and he therefore publishes on the same broker to a topic called owntracks/john/nex4 Let us further assume that access control on the MQTT broker allows both users to subscribe to eachother's topics. Now, if both friends subscribe to a topic called owntracks/+/+ (which the apps do by default) their devices will effectively receive published location messages to either topic. So when either Jane or John publish their location, the other's device will receive it. What OwnTracks then does is to list these topic names (e.g. owntracks/jjolie/4s ) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh? Faces # It gets better. You probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that, using CARDS . Depending on the device you're using, the procedure differs slightly. Android # The app subscribes to a topic branch owntracks/+/+ on the broker per default to receive locations of other people connected to the same MQTT broker that publish to the default topic of owntracks/$username/$devicename . It then reads CARD s to find friends' names and faces. iOS # The app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is owntracks/+/+ . Select the Friends button to see a list of friends: Tapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location. Who is that? # (iOS only) It's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book: Select an entry then click on the bookmark icon on top right. The Address book opens. Select the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\"). When you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map. Voila!","title":"Friends"},{"location":"features/friends/#friends","text":"OwnTracks has a so-called Friends and Family capability which is enabled by default. The way this works is friends and/or family members who share a single MQTT broker can \"see\" eachother on the map, respectively on a list of friends held by the app. (This can be done either by configuring all apps to use the same broker or by what is called bridging .) Let's assume for a moment, that a user Jane (user name jjolie ) has an iPhone 4s (device name 4s ), and that she publishes location data to a topic at owntracks/jjolie/4s Let us further assume, that her friend John (user name john ) has an Android Nexus 4 (device name nex4 ) and he therefore publishes on the same broker to a topic called owntracks/john/nex4 Let us further assume that access control on the MQTT broker allows both users to subscribe to eachother's topics. Now, if both friends subscribe to a topic called owntracks/+/+ (which the apps do by default) their devices will effectively receive published location messages to either topic. So when either Jane or John publish their location, the other's device will receive it. What OwnTracks then does is to list these topic names (e.g. owntracks/jjolie/4s ) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh?","title":"Friends"},{"location":"features/friends/#faces","text":"It gets better. You probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that, using CARDS . Depending on the device you're using, the procedure differs slightly.","title":"Faces"},{"location":"features/friends/#android","text":"The app subscribes to a topic branch owntracks/+/+ on the broker per default to receive locations of other people connected to the same MQTT broker that publish to the default topic of owntracks/$username/$devicename . It then reads CARD s to find friends' names and faces.","title":"Android"},{"location":"features/friends/#ios","text":"The app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is owntracks/+/+ . Select the Friends button to see a list of friends: Tapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location.","title":"iOS"},{"location":"features/friends/#who-is-that","text":"(iOS only) It's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book: Select an entry then click on the bookmark icon on top right. The Address book opens. Select the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\"). When you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map. Voila!","title":"Who is that?"},{"location":"features/ios/","text":"iOS # Runs on iPhones and iPads as an iPhone app, and on Macs. Not tested on iPods. Monitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \"significant location changes\" (>500m)) or as described in Move Mode below. In addition version >= 5.3 supports circular region monitoring (aka geo fences). In addition version >= 7.7 supports iBeacon region monitoring and ranging. publishes this locations via MQTT to the configured server while in foreground and background. The current location can be sent (a.k.a. published) on request. Startup # After downloading and installing the iPhone/iPad app , start it up. The first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location. Settings # Access settings and the individual modes by pressing on the I on the top left. Friends # The Friends feature shows self and all Friends published by the server, their picture or OwnTracks default icon, and their last location. Tapping on the entry switches back to map centered on friend's last location. The first time you launch the app you'll also be asked whether it may access your contacts data, which you should allow. (If you change your mind later, Privacy in General settings allows you to disable the feature.) Tapping on an location entry centers the map on the selected location. No geo-coding is done automatically in the background to limit mobile data usage. Location indicators and friendly faces # The locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic. A red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds as good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h. A small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement) with the 12 o'clock position meaning North. If your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the Friends list, as soon as a location update for Jane is seen by the app. Region Monitoring and Waypoints # Regions can be created with a description and a radius. If the description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the coordinate. These regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns reddish. If the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' monitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant. Every time the devices enters or leaves a monitored region, an additional so-called transition message with an enter or leave event is published to the MQTT broker. Use cases: * Define a home region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. * Share your favorite places with your friends (\"Best Sushi in Town\"). * Keep a private note (\"Parked Car here\"). * Use iBeacons to accurately report enter/leave events for your home * Use iBeacons to publish enter/leave events for individual rooms/floors in your home See also Waypoints . Region monitoring (a.k.a. Geo Fences) # If the waypoint description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the specified coordinates. Regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. Every time the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker, specifying whether the device is entering or leaving said region. For example, you can define a home region to ensure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep a private note (\"Parked Car here\"). Region Monitoring with iBeacons # Rather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers to the description to start region monitoring using iBeacons. e.g. * 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE' reports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' reports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity Region Monitoring with +follow # Create a region with a name begining with a + character, e.g. +follow and set an initial radius to be greater than zero. From this moment onwards, lat and lon will be set dynamically at each location publish and radius will be the distance you've covered in 30 seconds, at least 50 meters. Available in version > 15.x.x: If the name of such a region starts with a number (e.g. +60follow ), the dynamically set new radius will be the distance you've covered in number seconds (minimum 50 meters). This follow -type region will not trigger enter/leave events or notifications, and location publishes will have a type setting of \"t\" : \"C\" . Region Monitoring with automatic monitoring mode change # Available in version > 16.x.x Create a region with a name ending with '|<monitoring mode on enter>|<monitoring mode on exit> . E.g. Home|1|2 will switch to monitoring mode 2 (Move Mode) when exiting the region Home and will switch back to monitoring mode 1 (Significant Mode) when entering the region Home . Please note automatic change to monitoring mode -1 (Quiet Mode) will stop all further region detection. As the automatic change to monitoring mode 2 (Move Mode) does not work reliably under all circumstances, we recommend to add a +follow region, which will trigger a wake up of the app when moving. Region Monitoring with automatic battery level controlled monitoring mode change # Available in version > 16.x.x A new Settings parameter \"downgrade\" indicates the percentage of battery level which is the threshold. If the phone is in Move Mode and the battery level drops below \"downgrade\" percent, the app will automatically switch from Move Mode to Significant Mode. If the phone did that automatic switch and detects the charges is connected, it will automatically switch back to Move Mode. This will happen when then next location update in Significant mode is processed. The fact the app is in \"downgraded\" mode is indicated in the UI by a trailing ! to the Significant mode (e.g. Significant! ). Remote configuration # You can help your friends customize their copy of OwnTracks with remote configuration . Why do location publishes sometimes seem to cease to work? # Here's what happens: If the app goes into Background, the connection is disconnected because the app cannot maintain the TCP connection in background. If you bring the app back into foreground, the app will re-connect. When a location change is recorded (no matter if manual, significant, move or region mode), a message is prepared and an attempt to connect to the broker is started. If there is an error, connect will be retried after 2, 4, 8, ..., 64, 64, .... seconds until it succeeds. BUT... If the application is in background or is sent to the background, retries are restarted eventually - depending on iOS' background execution model about every 10 minutes. With automatic modes switched off, even when bringing the app to foreground, no new location updates are generated.","title":"Ios"},{"location":"features/ios/#ios","text":"Runs on iPhones and iPads as an iPhone app, and on Macs. Not tested on iPods. Monitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \"significant location changes\" (>500m)) or as described in Move Mode below. In addition version >= 5.3 supports circular region monitoring (aka geo fences). In addition version >= 7.7 supports iBeacon region monitoring and ranging. publishes this locations via MQTT to the configured server while in foreground and background. The current location can be sent (a.k.a. published) on request.","title":"iOS"},{"location":"features/ios/#startup","text":"After downloading and installing the iPhone/iPad app , start it up. The first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location.","title":"Startup"},{"location":"features/ios/#settings","text":"Access settings and the individual modes by pressing on the I on the top left.","title":"Settings"},{"location":"features/ios/#friends","text":"The Friends feature shows self and all Friends published by the server, their picture or OwnTracks default icon, and their last location. Tapping on the entry switches back to map centered on friend's last location. The first time you launch the app you'll also be asked whether it may access your contacts data, which you should allow. (If you change your mind later, Privacy in General settings allows you to disable the feature.) Tapping on an location entry centers the map on the selected location. No geo-coding is done automatically in the background to limit mobile data usage.","title":"Friends"},{"location":"features/ios/#location-indicators-and-friendly-faces","text":"The locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic. A red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds as good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h. A small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement) with the 12 o'clock position meaning North. If your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the Friends list, as soon as a location update for Jane is seen by the app.","title":"Location indicators and friendly faces"},{"location":"features/ios/#region-monitoring-and-waypoints","text":"Regions can be created with a description and a radius. If the description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the coordinate. These regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns reddish. If the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' monitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant. Every time the devices enters or leaves a monitored region, an additional so-called transition message with an enter or leave event is published to the MQTT broker. Use cases: * Define a home region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. * Share your favorite places with your friends (\"Best Sushi in Town\"). * Keep a private note (\"Parked Car here\"). * Use iBeacons to accurately report enter/leave events for your home * Use iBeacons to publish enter/leave events for individual rooms/floors in your home See also Waypoints .","title":"Region Monitoring and Waypoints"},{"location":"features/ios/#region-monitoring-aka-geo-fences","text":"If the waypoint description is non-empty and a radius > 0 (meters) is set, the app starts monitoring the circular region around the specified coordinates. Regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish. Every time the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker, specifying whether the device is entering or leaving said region. For example, you can define a home region to ensure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep a private note (\"Parked Car here\").","title":"Region monitoring (a.k.a. Geo Fences)"},{"location":"features/ios/#region-monitoring-with-ibeacons","text":"Rather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers to the description to start region monitoring using iBeacons. e.g. * 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE' reports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959' reports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity","title":"Region Monitoring with iBeacons"},{"location":"features/ios/#region-monitoring-with-follow","text":"Create a region with a name begining with a + character, e.g. +follow and set an initial radius to be greater than zero. From this moment onwards, lat and lon will be set dynamically at each location publish and radius will be the distance you've covered in 30 seconds, at least 50 meters. Available in version > 15.x.x: If the name of such a region starts with a number (e.g. +60follow ), the dynamically set new radius will be the distance you've covered in number seconds (minimum 50 meters). This follow -type region will not trigger enter/leave events or notifications, and location publishes will have a type setting of \"t\" : \"C\" .","title":"Region Monitoring with +follow"},{"location":"features/ios/#region-monitoring-with-automatic-monitoring-mode-change","text":"Available in version > 16.x.x Create a region with a name ending with '|<monitoring mode on enter>|<monitoring mode on exit> . E.g. Home|1|2 will switch to monitoring mode 2 (Move Mode) when exiting the region Home and will switch back to monitoring mode 1 (Significant Mode) when entering the region Home . Please note automatic change to monitoring mode -1 (Quiet Mode) will stop all further region detection. As the automatic change to monitoring mode 2 (Move Mode) does not work reliably under all circumstances, we recommend to add a +follow region, which will trigger a wake up of the app when moving.","title":"Region Monitoring with automatic monitoring mode change"},{"location":"features/ios/#region-monitoring-with-automatic-battery-level-controlled-monitoring-mode-change","text":"Available in version > 16.x.x A new Settings parameter \"downgrade\" indicates the percentage of battery level which is the threshold. If the phone is in Move Mode and the battery level drops below \"downgrade\" percent, the app will automatically switch from Move Mode to Significant Mode. If the phone did that automatic switch and detects the charges is connected, it will automatically switch back to Move Mode. This will happen when then next location update in Significant mode is processed. The fact the app is in \"downgraded\" mode is indicated in the UI by a trailing ! to the Significant mode (e.g. Significant! ).","title":"Region Monitoring with automatic battery level controlled monitoring mode change"},{"location":"features/ios/#remote-configuration","text":"You can help your friends customize their copy of OwnTracks with remote configuration .","title":"Remote configuration"},{"location":"features/ios/#why-do-location-publishes-sometimes-seem-to-cease-to-work","text":"Here's what happens: If the app goes into Background, the connection is disconnected because the app cannot maintain the TCP connection in background. If you bring the app back into foreground, the app will re-connect. When a location change is recorded (no matter if manual, significant, move or region mode), a message is prepared and an attempt to connect to the broker is started. If there is an error, connect will be retried after 2, 4, 8, ..., 64, 64, .... seconds until it succeeds. BUT... If the application is in background or is sent to the background, retries are restarted eventually - depending on iOS' background execution model about every 10 minutes. With automatic modes switched off, even when bringing the app to foreground, no new location updates are generated.","title":"Why do location publishes sometimes seem to cease to work?"},{"location":"features/location/","text":"Location data # We support 4 distinct modes of location publication and region monitoring as pertains to data submitted to the MQTT broker by our apps: Quiet mode: Only manual location reports. Icon [] Manual mode: Manual location reports and automated reports with region monitoring. Icon || Significant location change mode: Standard tracking mode with automated location reports. Icon |> Move mode: Frequent location ||> All four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons . iOS # Move mode # In move mode, the app monitors location permanently and publishes a new location as soon as the device moves locatorDisplacement meters or after locatorInterval seconds, whatever happens first. locatorDisplacement and locatorInterval can be adjusted by the user in the systems settings for OwnTracks. The defaults are 100m and 300 seconds (5 minutes). The payoff is higher battery usage as high as in navigation or tracker app. So it is recommend to use move mode while charging or during moves only - hence the name. Please note, move mode is active when the app is active (a.k.a in foreground). Significant location change mode # iOS defines a Significant location change as traveling a distance of at least 500 meters in 5 minutes. This mode allows the app to run in background and minimize the power consumption. This standard tracking mode reports significant location changes only (>500m and at most once every 5 minutes). This is defined by Apple and is optimal with respect to battery usage. Examples: if you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a ping -type message once in a while.) if you move at least 500 meters, a new location will be published after 5 minutes if you move 10 kilometers in 5 minutes, only one location will be published Manual mode # The app doesn't monitor location changes in manual mode while in background. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence or Beacon regions are still published automatically whilst in Manual mode. Quiet mode # Same as Manual mode except that no region events are published. Region monitoring # The app user may mark a previously manually published or manually created location as a monitored circular region by specifying a monitoring radius in meters. (See Regions .) The app will publish the location additionally every time the device leaves or enters one of the regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently thereof. It is switched on when a region is setup with description and radius. To switch region monitoring off, all regions have to be unmarked (by setting their radius to 0). Regions are shown on the map display in transparent blue or red circles. Red indicates the device is is within the region. Tags and POI # On iOS, a user can set a point of interest (POI) during manual publish of a location or set a tag while for future location publishes. When tapping on \"publish location\" an action picker appears on which the user can choose to: Send location now. The current location is published, possibly enhanced with a previously set tag . Set POI. A user is asked to describe the POI (e.g. delicious seafood ) and the location is then transmitted with the poi added to the JSON payload. Set tag. Users can enter a tag (e.g. Spain 2023 ) which is added to the JSON of all subsequent location publishes, irrespective of the mode (i.e. this also works in significant changes mode, say), until the tag is removed. iBeacon monitoring # The app user may mark a previously manually published or manually created location as a monitored beacon region by appending a beacon UUID to the region's name. The app will publish the location additionally every time the device leaves or enters one of the beacon regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently. It is switched on when a region's name has a valid UUID appended to it. If the device is within a monitored beacon region, the the beacon indicator is shown in red, otherwise blue meaning device is not in any iBeacon region. There are 2 kinds of locations: an automatic location created when iOS detects a change of location a manual location created by the user A manual location with a non-zero length remark (description) is a waypoint . A waypoint 's attributes are published when the waypoint is created or changed. If a waypoint specifies a radius, a circular region is monitored for enter/leave events . If a waypoint is not a circular region and the waypoint's description contains a valid iBeacon specification, a beacon region is monitored for enter/leave events. If an enter/leave event occurs an event message is published with the type attribute set to c or b for ( circular region_or _beacon region ). The message contains an event attribute specifying either enter or leave . The description of the waypoint is added to the published event message. Automatic Description iBeacon Radius Event Message /w Description Waypoint Message Y n/a n/a n/a N N N N N n/a n/a N N N N Y N N N N Y N Y N Y c N N N Y N Y c Y Y N Y Y N b N N N Y Y N b Y Y N Y Y Y c N N N Y Y Y c Y Y Android # Move mode # In move mode, the app monitors device location permanently. It requests a location fix every 10s (by default, configurable in the settings through moveModeLocatorInterval ) in high power mode and publishes a new location as soon as it arrives. This mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage. It is recommend to use move mode while charging or during periods that require highly accurate tracking while moving quickly. The locatorDisplacement option is ignored in this mode. Significant location change mode # This standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives. This mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users. In addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw location request that is send to the Android location API. locatorInterval : The desired interval for active location updates. \"The location client will actively try to obtain location updates for your application at this interval, so it has a direct influence on the amount of power used by your application. Choose your interval wisely.\" moveModeLocatorInterval : The requested location interval in move mode. locatorDisplacement : The smallest displacement in meters the user must move between location updates. Defaults to 500 and is an and relationship with interval. Can be used to only receive updates when the device has moved. This means if the user has not moved by more than the displacement value, the location will not be reported at locatorInterval . Manual mode # In manual mode, the app monitors device location with a low power location request. It uses the same interval configured for significant mode to receive low accuracy updates to use minimal battery power. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in Manual mode. Remote reportLocation commands are ignored. Quiet mode # Same as Manual mode except that no region events are published.","title":"Location"},{"location":"features/location/#location-data","text":"We support 4 distinct modes of location publication and region monitoring as pertains to data submitted to the MQTT broker by our apps: Quiet mode: Only manual location reports. Icon [] Manual mode: Manual location reports and automated reports with region monitoring. Icon || Significant location change mode: Standard tracking mode with automated location reports. Icon |> Move mode: Frequent location ||> All four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons .","title":"Location data"},{"location":"features/location/#ios","text":"","title":"iOS"},{"location":"features/location/#move-mode","text":"In move mode, the app monitors location permanently and publishes a new location as soon as the device moves locatorDisplacement meters or after locatorInterval seconds, whatever happens first. locatorDisplacement and locatorInterval can be adjusted by the user in the systems settings for OwnTracks. The defaults are 100m and 300 seconds (5 minutes). The payoff is higher battery usage as high as in navigation or tracker app. So it is recommend to use move mode while charging or during moves only - hence the name. Please note, move mode is active when the app is active (a.k.a in foreground).","title":"Move mode"},{"location":"features/location/#significant-location-change-mode","text":"iOS defines a Significant location change as traveling a distance of at least 500 meters in 5 minutes. This mode allows the app to run in background and minimize the power consumption. This standard tracking mode reports significant location changes only (>500m and at most once every 5 minutes). This is defined by Apple and is optimal with respect to battery usage. Examples: if you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a ping -type message once in a while.) if you move at least 500 meters, a new location will be published after 5 minutes if you move 10 kilometers in 5 minutes, only one location will be published","title":"Significant location change mode"},{"location":"features/location/#manual-mode","text":"The app doesn't monitor location changes in manual mode while in background. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence or Beacon regions are still published automatically whilst in Manual mode.","title":"Manual mode"},{"location":"features/location/#quiet-mode","text":"Same as Manual mode except that no region events are published.","title":"Quiet mode"},{"location":"features/location/#region-monitoring","text":"The app user may mark a previously manually published or manually created location as a monitored circular region by specifying a monitoring radius in meters. (See Regions .) The app will publish the location additionally every time the device leaves or enters one of the regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently thereof. It is switched on when a region is setup with description and radius. To switch region monitoring off, all regions have to be unmarked (by setting their radius to 0). Regions are shown on the map display in transparent blue or red circles. Red indicates the device is is within the region.","title":"Region monitoring"},{"location":"features/location/#tags-and-poi","text":"On iOS, a user can set a point of interest (POI) during manual publish of a location or set a tag while for future location publishes. When tapping on \"publish location\" an action picker appears on which the user can choose to: Send location now. The current location is published, possibly enhanced with a previously set tag . Set POI. A user is asked to describe the POI (e.g. delicious seafood ) and the location is then transmitted with the poi added to the JSON payload. Set tag. Users can enter a tag (e.g. Spain 2023 ) which is added to the JSON of all subsequent location publishes, irrespective of the mode (i.e. this also works in significant changes mode, say), until the tag is removed.","title":"Tags and POI"},{"location":"features/location/#ibeacon-monitoring","text":"The app user may mark a previously manually published or manually created location as a monitored beacon region by appending a beacon UUID to the region's name. The app will publish the location additionally every time the device leaves or enters one of the beacon regions, and the published data contains an indication of whether the device is entering or leaving the region. Region monitoring is not related to one of the location publication modes and works independently. It is switched on when a region's name has a valid UUID appended to it. If the device is within a monitored beacon region, the the beacon indicator is shown in red, otherwise blue meaning device is not in any iBeacon region. There are 2 kinds of locations: an automatic location created when iOS detects a change of location a manual location created by the user A manual location with a non-zero length remark (description) is a waypoint . A waypoint 's attributes are published when the waypoint is created or changed. If a waypoint specifies a radius, a circular region is monitored for enter/leave events . If a waypoint is not a circular region and the waypoint's description contains a valid iBeacon specification, a beacon region is monitored for enter/leave events. If an enter/leave event occurs an event message is published with the type attribute set to c or b for ( circular region_or _beacon region ). The message contains an event attribute specifying either enter or leave . The description of the waypoint is added to the published event message. Automatic Description iBeacon Radius Event Message /w Description Waypoint Message Y n/a n/a n/a N N N N N n/a n/a N N N N Y N N N N Y N Y N Y c N N N Y N Y c Y Y N Y Y N b N N N Y Y N b Y Y N Y Y Y c N N N Y Y Y c Y Y","title":"iBeacon monitoring"},{"location":"features/location/#android","text":"","title":"Android"},{"location":"features/location/#move-mode_1","text":"In move mode, the app monitors device location permanently. It requests a location fix every 10s (by default, configurable in the settings through moveModeLocatorInterval ) in high power mode and publishes a new location as soon as it arrives. This mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage. It is recommend to use move mode while charging or during periods that require highly accurate tracking while moving quickly. The locatorDisplacement option is ignored in this mode.","title":"Move mode"},{"location":"features/location/#significant-location-change-mode_1","text":"This standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives. This mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users. In addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw location request that is send to the Android location API. locatorInterval : The desired interval for active location updates. \"The location client will actively try to obtain location updates for your application at this interval, so it has a direct influence on the amount of power used by your application. Choose your interval wisely.\" moveModeLocatorInterval : The requested location interval in move mode. locatorDisplacement : The smallest displacement in meters the user must move between location updates. Defaults to 500 and is an and relationship with interval. Can be used to only receive updates when the device has moved. This means if the user has not moved by more than the displacement value, the location will not be reported at locatorInterval .","title":"Significant location change mode"},{"location":"features/location/#manual-mode_1","text":"In manual mode, the app monitors device location with a low power location request. It uses the same interval configured for significant mode to receive low accuracy updates to use minimal battery power. The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in Manual mode. Remote reportLocation commands are ignored.","title":"Manual mode"},{"location":"features/location/#quiet-mode_1","text":"Same as Manual mode except that no region events are published.","title":"Quiet mode"},{"location":"features/pedometer/","text":"Pedometer # The iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only). The way this works is that the iPhone counts the steps you take, and OwnTracks can report these in a JSON payload upon request. Command # In order for the app to actually report the steps counted by the device, you send it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.) mosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{\"_type\" : \"cmd\", \"action\": \"reportSteps\"}' Note how we\u2019re using QoS=2 here: the message is published to the MQTT broker, and when the phone next wakes up, which happens every few hundred seconds, it will obtain the message, and publish a JSON payload with the counted steps back to your MQTT broker. { \"_type\": \"steps\", \"from\": 1400455130, \"steps\": 1234, \"to\": 1400458000, \"tst\": 1400455130 } Daily reports # We use the following small program to issue the JSON needed to request the steps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.) #!/usr/bin/env python import datetime import time import json import sys days = 0 def unix_epoch(t, delta): dt = t + delta # print dt return int(time.mktime(dt.timetuple())) now = datetime.datetime.today() f = now.replace(now.year, now.month, now.day, 0, 0, 1, 0) t = now.replace(now.year, now.month, now.day, 23, 59, 59, 0) delta = datetime.timedelta(days=days) payload = { '_type' : 'cmd', 'action' : 'reportSteps', 'from' : unix_epoch(f, delta), 'to' : unix_epoch(t, delta), } print json.dumps(payload) In the evening, a cron entry sends that off to our broker which will, eventually, deliver the message to the the phone. 50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l Daily reports with Openhab # With openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab. At first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg mqtt-retain.url=tcp://192.168.1.1:1884 mqtt-retain.qos=2 After that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents: rule \"MQTT_OWNTRACKS_STEPS\" when // every day at 23:59 Time cron \"0 59 23 * * ? *\" then val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000 val long to1 = (now.millis / 1000) publish(\"mqtt-retain\",\"owntracks/jj/5s/cmd\",'{\"action\": \"reportSteps\", \"to\": '+ to1 +', \"_type\": \"cmd\", \"from\": '+ from1 +'}') end For usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items Number Steps_Yesterday \"[%d]\" { mqtt=\"<[mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]\" } Now You can make use of yesterday's steps count.","title":"Pedometer"},{"location":"features/pedometer/#pedometer","text":"The iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only). The way this works is that the iPhone counts the steps you take, and OwnTracks can report these in a JSON payload upon request.","title":"Pedometer"},{"location":"features/pedometer/#command","text":"In order for the app to actually report the steps counted by the device, you send it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.) mosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{\"_type\" : \"cmd\", \"action\": \"reportSteps\"}' Note how we\u2019re using QoS=2 here: the message is published to the MQTT broker, and when the phone next wakes up, which happens every few hundred seconds, it will obtain the message, and publish a JSON payload with the counted steps back to your MQTT broker. { \"_type\": \"steps\", \"from\": 1400455130, \"steps\": 1234, \"to\": 1400458000, \"tst\": 1400455130 }","title":"Command"},{"location":"features/pedometer/#daily-reports","text":"We use the following small program to issue the JSON needed to request the steps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.) #!/usr/bin/env python import datetime import time import json import sys days = 0 def unix_epoch(t, delta): dt = t + delta # print dt return int(time.mktime(dt.timetuple())) now = datetime.datetime.today() f = now.replace(now.year, now.month, now.day, 0, 0, 1, 0) t = now.replace(now.year, now.month, now.day, 23, 59, 59, 0) delta = datetime.timedelta(days=days) payload = { '_type' : 'cmd', 'action' : 'reportSteps', 'from' : unix_epoch(f, delta), 'to' : unix_epoch(t, delta), } print json.dumps(payload) In the evening, a cron entry sends that off to our broker which will, eventually, deliver the message to the the phone. 50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l","title":"Daily reports"},{"location":"features/pedometer/#daily-reports-with-openhab","text":"With openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab. At first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg mqtt-retain.url=tcp://192.168.1.1:1884 mqtt-retain.qos=2 After that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents: rule \"MQTT_OWNTRACKS_STEPS\" when // every day at 23:59 Time cron \"0 59 23 * * ? *\" then val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000 val long to1 = (now.millis / 1000) publish(\"mqtt-retain\",\"owntracks/jj/5s/cmd\",'{\"action\": \"reportSteps\", \"to\": '+ to1 +', \"_type\": \"cmd\", \"from\": '+ from1 +'}') end For usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items Number Steps_Yesterday \"[%d]\" { mqtt=\"<[mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]\" } Now You can make use of yesterday's steps count.","title":"Daily reports with Openhab"},{"location":"features/poi/","text":"POI and tags # Currently iOS only. When manually publishing a location from the app, users have the possibility to set (or later clear) a tag. Setting a tag causes all future publishes (manual or automatic) to have their JSON payloads enhanced with a \"tag\" element until it is manually cleared in the UI. The value of a tag is added to the JSON as { \"_type\": \"location\", \"tag\" : \"<your tag>\", ... } Tags can be used to group locations pertaining to a particular event (e.g. a specific trip or vacation). Also when publishing a location a user can set a Point of Interest (POI) which is associated with the location being published. This POI is added once-only to the location message (contrary to a tag which is used until cleared): { \"_type\": \"location\", \"lat\": 17.065921, \"lon\": -96.717023, \"poi\": \"Oaxaca, hotel Los Pilares\", ... } iOS displays the Points of Interest as red bubbles on the map as shown above. The last POI and tags seen for a particular user are visible on the user's status page.","title":"Poi"},{"location":"features/poi/#poi-and-tags","text":"Currently iOS only. When manually publishing a location from the app, users have the possibility to set (or later clear) a tag. Setting a tag causes all future publishes (manual or automatic) to have their JSON payloads enhanced with a \"tag\" element until it is manually cleared in the UI. The value of a tag is added to the JSON as { \"_type\": \"location\", \"tag\" : \"<your tag>\", ... } Tags can be used to group locations pertaining to a particular event (e.g. a specific trip or vacation). Also when publishing a location a user can set a Point of Interest (POI) which is associated with the location being published. This POI is added once-only to the location message (contrary to a tag which is used until cleared): { \"_type\": \"location\", \"lat\": 17.065921, \"lon\": -96.717023, \"poi\": \"Oaxaca, hotel Los Pilares\", ... } iOS displays the Points of Interest as red bubbles on the map as shown above. The last POI and tags seen for a particular user are visible on the user's status page.","title":"POI and tags"},{"location":"features/qs-config/","text":"Additional Quicksetup Configuration # In Quicksetup we describe how it works and how you begin using configuration.yaml to easily bootstrap your OwnTracks platform. Friends list syntax # Friends are basically configured like this in the configuration.yaml file: friends: - { tid: JJ, username: jane, devicename: nokia } To be clear this is YAML, so you could also write it this way, if you prefer. The field names are the same, the order doesn't matter but note the leading hyphen ( - ) which denotes a new entry in the array. friends: - tid: JJ username: jane devicename: nokia The second friend's entry would again begin with a hyphen which must be placed under the first: friends: - tid: JJ username: jane devicename: nokia - tid: m1 username: another ... Friend-specific settings # There are a few settings a friend can have we've not mentioned yet, so here they are. our quicksetup configuration defaults to configuring the apps (via inline or .otrc in MQTT mode. Setting httpmode to True changes that to HTTP for this particular friend (e.g. httpmode: True ). different passwords are auto-generated during bootstrapping and result in distinct (per user) and random 20-character passwords. Should you wish to explicit configure a specific password, do so by setting password to a string of your choice (e.g. password: \"supersecr1t\" ). Note that this password will be visible in the configuration and in the *.pass files. Further note, that all entries for a specific user will re-use the first password (specified or randomly generated) set for said user. set up payload encryption for a particular friend by specifying a secret which is either the secret itself (e.g. secret: \"bla009\" ) or, if the value begins with a slash, the path to a filename which contains the secret (e.g. secret: \"/home/jane/.secret\" ). Friend-specific MQTT ACLs # During bootstrapping , Quicksetup configures a default set of access control lists (ACL) for the Mosquitto broker which basically allow all friends to \"see\" eachother, receive their enter/leave events, and see their cards . This will likely be the typical mode of operation you wish your OwnTracks Mosquitto broker to operate in. There might be situations, however, in which you wish to give a specific friend a particular ACL, maybe to restrict, say, whom that friend might see (e.g. your friend should see your location but not that of your spouse). To accomplish this, create a directory acl/ in the directory in which the bootstrap.sh program is located and add files named <username>.acl to that directory. For example, the user Anouk should have the following ACL: $ cat acl/anouk.acl user anouk topic readwrite owntracks/anouk/# topic read owntracks/jane/nokia topic read owntracks/jane/+/event topic read owntracks/jane/+/info Re-running ./bootstrap.sh will populate this specific ACL in the Mosquitto ACL file ( /etc/mosquitto/mosquitto.acl ) whereas for all other friends a built-in default will be used. Friend-specific Waypoints (Regions) # In order for, say, a family to share initial geofence configuration (e.g. \"Home\" , \"School\" , etc.) create a directory called waypoints/ relative to ./bootstrap.sh and populate files <username>.json which contain an array of waypoints you wish to add to a particular user's initial configuration. OTRW files and YAML files ( <username>.yaml ) are likewise accepted: the list of waypoints is read from <username>.otrw and merged with all the others. Android iOS For instance, we create a file waypoints/anouk.json with the following content: [ { \"_type\": \"waypoint\", \"tst\": 1361636517, \"rid\": \"blauw-utrecht-nl\", \"desc\": \"Restaurant Blauw\", \"rad\": 50, \"lat\": 52.08782, \"lon\": 5.119438 } ] These files must contain an array of valid waypoints, and must be valid JSON. Additionally, OTRW files must be of _type: waypoints and have a key waypoints . As a convenience, YAML files (which may be easier to edit) containing an array of waypoints are also supported: - _type: waypoint desc: \"Delaville Caf\u00e9\" rid: delaville-cafe tst: 1708879121 rad: 70 lat: 48.870737 lon: 2.3491583 During bootstrapping, the users' inline or .otrc configuration is adjusted accordingly. Global # with lua_script you configure the path to a Recorder Lua script which is written into /etc/defaults/ot-recorder for the next Recorder start. Use this only after testing your Lua script as the Recorder will fail to start on error.","title":"Qs config"},{"location":"features/qs-config/#additional-quicksetup-configuration","text":"In Quicksetup we describe how it works and how you begin using configuration.yaml to easily bootstrap your OwnTracks platform.","title":"Additional Quicksetup Configuration"},{"location":"features/qs-config/#friends-list-syntax","text":"Friends are basically configured like this in the configuration.yaml file: friends: - { tid: JJ, username: jane, devicename: nokia } To be clear this is YAML, so you could also write it this way, if you prefer. The field names are the same, the order doesn't matter but note the leading hyphen ( - ) which denotes a new entry in the array. friends: - tid: JJ username: jane devicename: nokia The second friend's entry would again begin with a hyphen which must be placed under the first: friends: - tid: JJ username: jane devicename: nokia - tid: m1 username: another ...","title":"Friends list syntax"},{"location":"features/qs-config/#friend-specific-settings","text":"There are a few settings a friend can have we've not mentioned yet, so here they are. our quicksetup configuration defaults to configuring the apps (via inline or .otrc in MQTT mode. Setting httpmode to True changes that to HTTP for this particular friend (e.g. httpmode: True ). different passwords are auto-generated during bootstrapping and result in distinct (per user) and random 20-character passwords. Should you wish to explicit configure a specific password, do so by setting password to a string of your choice (e.g. password: \"supersecr1t\" ). Note that this password will be visible in the configuration and in the *.pass files. Further note, that all entries for a specific user will re-use the first password (specified or randomly generated) set for said user. set up payload encryption for a particular friend by specifying a secret which is either the secret itself (e.g. secret: \"bla009\" ) or, if the value begins with a slash, the path to a filename which contains the secret (e.g. secret: \"/home/jane/.secret\" ).","title":"Friend-specific settings"},{"location":"features/qs-config/#friend-specific-mqtt-acls","text":"During bootstrapping , Quicksetup configures a default set of access control lists (ACL) for the Mosquitto broker which basically allow all friends to \"see\" eachother, receive their enter/leave events, and see their cards . This will likely be the typical mode of operation you wish your OwnTracks Mosquitto broker to operate in. There might be situations, however, in which you wish to give a specific friend a particular ACL, maybe to restrict, say, whom that friend might see (e.g. your friend should see your location but not that of your spouse). To accomplish this, create a directory acl/ in the directory in which the bootstrap.sh program is located and add files named <username>.acl to that directory. For example, the user Anouk should have the following ACL: $ cat acl/anouk.acl user anouk topic readwrite owntracks/anouk/# topic read owntracks/jane/nokia topic read owntracks/jane/+/event topic read owntracks/jane/+/info Re-running ./bootstrap.sh will populate this specific ACL in the Mosquitto ACL file ( /etc/mosquitto/mosquitto.acl ) whereas for all other friends a built-in default will be used.","title":"Friend-specific MQTT ACLs"},{"location":"features/qs-config/#friend-specific-waypoints-regions","text":"In order for, say, a family to share initial geofence configuration (e.g. \"Home\" , \"School\" , etc.) create a directory called waypoints/ relative to ./bootstrap.sh and populate files <username>.json which contain an array of waypoints you wish to add to a particular user's initial configuration. OTRW files and YAML files ( <username>.yaml ) are likewise accepted: the list of waypoints is read from <username>.otrw and merged with all the others. Android iOS For instance, we create a file waypoints/anouk.json with the following content: [ { \"_type\": \"waypoint\", \"tst\": 1361636517, \"rid\": \"blauw-utrecht-nl\", \"desc\": \"Restaurant Blauw\", \"rad\": 50, \"lat\": 52.08782, \"lon\": 5.119438 } ] These files must contain an array of valid waypoints, and must be valid JSON. Additionally, OTRW files must be of _type: waypoints and have a key waypoints . As a convenience, YAML files (which may be easier to edit) containing an array of waypoints are also supported: - _type: waypoint desc: \"Delaville Caf\u00e9\" rid: delaville-cafe tst: 1708879121 rad: 70 lat: 48.870737 lon: 2.3491583 During bootstrapping, the users' inline or .otrc configuration is adjusted accordingly.","title":"Friend-specific Waypoints (Regions)"},{"location":"features/qs-config/#global","text":"with lua_script you configure the path to a Recorder Lua script which is written into /etc/defaults/ot-recorder for the next Recorder start. Use this only after testing your Lua script as the Recorder will fail to start on error.","title":"Global"},{"location":"features/qs-extra/","text":"Quicksetup Extras # There are some additional features of Quicksetup we describe here. MQTT # During bootstrapping quicksetup creates a user for the MQTT broker with additional permissions. Specifically, the user _lr is permitted to publish in owntracks/# : the idea is that this user can, for instance, be used to clear other users' OwnTracks topics, etc. The password for this user is randomly generated and stored in a file in the userdata directory. The following invocation can be used from the command line: $ mosquitto_pub -u _lr -P \"$(cat /usr/local/owntracks/userdata/.lr.pw)\" ... Files # in /usr/local/owntracks/userdata .lr.pw is a file containing the password for the MQTT user _lr that is permitted to publish to owntracks/# htpasswd is a file containing hashed passwords for logging into your OwnTracks web site; each user has such a password which matches the random password generated for MQTT recorder.pw is a file containing a password with which the Recorder connects to your MQTT broker. *.pass are the generated (or set) passwords for users you configured in configuration.yaml *.otrc are the generated otrc files for users configured in configuration.yaml . in /usr/local/owntracks/lego are configuration files created / generated by lego , the Let's Encrypt enroller/renewer in /usr/local/owntracks/tls contain TLS keys and certificate for your configured dns_domain in /usr/local/owntracks/ansible is where bootstrap.sh installed Ansible, which is used by the bootstrapper","title":"Qs extra"},{"location":"features/qs-extra/#quicksetup-extras","text":"There are some additional features of Quicksetup we describe here.","title":"Quicksetup Extras"},{"location":"features/qs-extra/#mqtt","text":"During bootstrapping quicksetup creates a user for the MQTT broker with additional permissions. Specifically, the user _lr is permitted to publish in owntracks/# : the idea is that this user can, for instance, be used to clear other users' OwnTracks topics, etc. The password for this user is randomly generated and stored in a file in the userdata directory. The following invocation can be used from the command line: $ mosquitto_pub -u _lr -P \"$(cat /usr/local/owntracks/userdata/.lr.pw)\" ...","title":"MQTT"},{"location":"features/qs-extra/#files","text":"in /usr/local/owntracks/userdata .lr.pw is a file containing the password for the MQTT user _lr that is permitted to publish to owntracks/# htpasswd is a file containing hashed passwords for logging into your OwnTracks web site; each user has such a password which matches the random password generated for MQTT recorder.pw is a file containing a password with which the Recorder connects to your MQTT broker. *.pass are the generated (or set) passwords for users you configured in configuration.yaml *.otrc are the generated otrc files for users configured in configuration.yaml . in /usr/local/owntracks/lego are configuration files created / generated by lego , the Let's Encrypt enroller/renewer in /usr/local/owntracks/tls contain TLS keys and certificate for your configured dns_domain in /usr/local/owntracks/ansible is where bootstrap.sh installed Ansible, which is used by the bootstrapper","title":"Files"},{"location":"features/remoteconfig/","text":"Configuration file # The configuration can be sent to the device as a file that can by imported into the apps. This can be used to initially configure the device or change detailed settings later. Create a configuration file in JSON with an .otrc suffix (for OwnTracks Configuration) Ensure the JSON is valid with online JSON validator , jq or simply by running python3 -mjson.tool < your.otrc Send the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, use URL config (see below), etc. Have the OwnTracks app user open the file on their device; this should trigger an open with OwnTracks. Here is a sample configuration file which contains some of the possible settings. { \"_type\": \"configuration\", \"auth\": true, \"username\": \"jjolie\", \"password\": \"s1kr3t\", \"host\": \"mybroker.example.org\", \"port\": 8883 } The _type entry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described on the JSON page . URL config # Both iOS and Android apps can be configured by having the user click on an owntracks:///config?inline= URL containing a base64-encoded version of the content of an .otrc file. Say we have a file called j.otrc with the JSON _type: configuration shown above. We can use, say, the openssl utility to base64-encode encode the configuration into a single line: echo \"owntracks:///config?inline=$(openssl enc -a -A -in j.otrc)\" which results in this text: owntracks:///config?inline=ewogICJfdHlwZSI6ICJjb25maWd1cmF0aW9uIiwKICAiYXV0aCI6IHRydWUsCiAgInVzZXJuYW1lIjogImpqb2xpZSIsCiAgInBhc3N3b3JkIjogInMxa3IzdCIsCiAgImhvc3QiOiAibXlicm9rZXIuZXhhbXBsZS5vcmciLAogICJwb3J0IjogODg4Mwp9Cg== We can then paste that text into the @@ placeholder on an HTML like this: <html><body><p> <a href=\"@@\">Click to configure OwnTracks</a> </p></body></html> This link is then made available to click on after the user has installed the OwnTracks app for configuring it. By omitting, say, deviceID and tid it would be possible to \"mass configure\" a number of users' apps. setConfiguration # The configuration of a connected app can also be changed remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A _type: configuration as described on the JSON page can be send to the device. setWaypoints # Waypoints can be configured remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the tst timestamp, so overwriting an existing tst actually overwrites an existing waypoint.) { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"waypoints\": [ { \"desc\": \"Some place\", \"rad\": 8867, \"lon\": 10.428771973, \"lat\": 46.935260881, \"tst\": 1437552714, \"_type\": \"waypoint\" } ], \"_type\": \"waypoints\" } } Publishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints.","title":"Remoteconfig"},{"location":"features/remoteconfig/#configuration-file","text":"The configuration can be sent to the device as a file that can by imported into the apps. This can be used to initially configure the device or change detailed settings later. Create a configuration file in JSON with an .otrc suffix (for OwnTracks Configuration) Ensure the JSON is valid with online JSON validator , jq or simply by running python3 -mjson.tool < your.otrc Send the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, use URL config (see below), etc. Have the OwnTracks app user open the file on their device; this should trigger an open with OwnTracks. Here is a sample configuration file which contains some of the possible settings. { \"_type\": \"configuration\", \"auth\": true, \"username\": \"jjolie\", \"password\": \"s1kr3t\", \"host\": \"mybroker.example.org\", \"port\": 8883 } The _type entry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described on the JSON page .","title":"Configuration file"},{"location":"features/remoteconfig/#url-config","text":"Both iOS and Android apps can be configured by having the user click on an owntracks:///config?inline= URL containing a base64-encoded version of the content of an .otrc file. Say we have a file called j.otrc with the JSON _type: configuration shown above. We can use, say, the openssl utility to base64-encode encode the configuration into a single line: echo \"owntracks:///config?inline=$(openssl enc -a -A -in j.otrc)\" which results in this text: owntracks:///config?inline=ewogICJfdHlwZSI6ICJjb25maWd1cmF0aW9uIiwKICAiYXV0aCI6IHRydWUsCiAgInVzZXJuYW1lIjogImpqb2xpZSIsCiAgInBhc3N3b3JkIjogInMxa3IzdCIsCiAgImhvc3QiOiAibXlicm9rZXIuZXhhbXBsZS5vcmciLAogICJwb3J0IjogODg4Mwp9Cg== We can then paste that text into the @@ placeholder on an HTML like this: <html><body><p> <a href=\"@@\">Click to configure OwnTracks</a> </p></body></html> This link is then made available to click on after the user has installed the OwnTracks app for configuring it. By omitting, say, deviceID and tid it would be possible to \"mass configure\" a number of users' apps.","title":"URL config"},{"location":"features/remoteconfig/#setconfiguration","text":"The configuration of a connected app can also be changed remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A _type: configuration as described on the JSON page can be send to the device.","title":"setConfiguration"},{"location":"features/remoteconfig/#setwaypoints","text":"Waypoints can be configured remotely if Remote Commands is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the tst timestamp, so overwriting an existing tst actually overwrites an existing waypoint.) { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"waypoints\": [ { \"desc\": \"Some place\", \"rad\": 8867, \"lon\": 10.428771973, \"lat\": 46.935260881, \"tst\": 1437552714, \"_type\": \"waypoint\" } ], \"_type\": \"waypoints\" } } Publishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints.","title":"setWaypoints"},{"location":"features/security/","text":"Security # OwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your family members and friends is something only you respectively they should know about. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes. If your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over TLS when connecting to your broker. (We configure this and passwords automatically for you in quicksetup .) The apps support authenticating to the MQTT broker with username and password which can be as strong (or as convoluted) as your broker supports. In HTTP mode, the apps provide support for HTTP basic authentication with TLS. Credentials you configure (i.e. username and password ) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits. The apps support using TLS client certificates for authentication to the MQTT broker. The apps have optional support for payload encryption for privacy. The apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server). The apps do, however, perform reverse geo location lookups. For iOS these lookups are submitted to the Apple Maps infrastructure, and as reverse geo-coding is rate-limited on the iPhone we do not use it for all sent locations, but only when a location is displayed on user request, e.g. on the Friends page. On Android the requests are performed via Google Play services for the non OSS release. This configuration can be optionally changed by configuring Android to use OpenCage as reverse geo location provider. This functionality cannot be disabled.","title":"Security"},{"location":"features/security/#security","text":"OwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your family members and friends is something only you respectively they should know about. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes. If your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over TLS when connecting to your broker. (We configure this and passwords automatically for you in quicksetup .) The apps support authenticating to the MQTT broker with username and password which can be as strong (or as convoluted) as your broker supports. In HTTP mode, the apps provide support for HTTP basic authentication with TLS. Credentials you configure (i.e. username and password ) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits. The apps support using TLS client certificates for authentication to the MQTT broker. The apps have optional support for payload encryption for privacy. The apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server). The apps do, however, perform reverse geo location lookups. For iOS these lookups are submitted to the Apple Maps infrastructure, and as reverse geo-coding is rate-limited on the iPhone we do not use it for all sent locations, but only when a location is displayed on user request, e.g. on the Friends page. On Android the requests are performed via Google Play services for the non OSS release. This configuration can be optionally changed by configuring Android to use OpenCage as reverse geo location provider. This functionality cannot be disabled.","title":"Security"},{"location":"features/tid/","text":"TID # A TID is a tracker ID , a two-character identifier of your chosing, your initials, say. This TID is published in the JSON payload of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather long topic name . The TID of your friends is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained card published.","title":"Tid"},{"location":"features/tid/#tid","text":"A TID is a tracker ID , a two-character identifier of your chosing, your initials, say. This TID is published in the JSON payload of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather long topic name . The TID of your friends is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained card published.","title":"TID"},{"location":"features/tls/","text":"TLS # You want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using TLS . When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.) Configuring TLS ( Transport Layer Security ) for OwnTracks involves doing three things: Obtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one Configure TLS on the MQTT broker Configuring the app to use TLS You can share the certificate if you want to (though not many people will want it ...) It's so public, that it's perfectly OK to send yourself the file by, say, e-mail. Configure TLS on the Mosquitto broker # We'll first show you how to set up TLS on your Mosquitto broker . The basic configuration for TLS in mosquitto.conf is: listener 8883 cafile ............. certfile ............. keyfile ............. (see also: mosquitto-tls .) 8883 is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port. cafile is the path to the certificate authority file certfile points to your server's certificate in PEM format keyfile points to your server's secret key file (which you never divulge!) Configure the OwnTracks app to use TLS # We show you here how to set up your iOS or Android device with that kind of certificate. In both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a .crt extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment. In our example, the CA certificate is called MQTTitude-ca.crt . Android # Note that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below). So, here's your e-mail message with said attachment. Now click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen MQTTitude , of course. Then click OK. That's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. Note that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying). iOS # So, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself! You've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install. Read the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right. There you go! That's it: the certificate was installed. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. manual configuration on Android # From the, say, e-mail you got with the certificate, click \"save\" on the attached .crt file which is stored on your device's Download folder. In OwnTracks's settings, select TLS (Custom Certificate) Now comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is /storage/emulated/0/Download/MQTTitude.crt . Your mileage, etc; When you click Connect , it will try and use your certificate. Good luck! ;-) The nitty gritty # That CA certificate file we mentioned? The attachment called something.crt ? It looks like this, in fact, in what is called PEM format; but you don't really want to know that, but if you do, this is what it looks like: -----BEGIN CERTIFICATE----- MIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV BAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK ... pjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS cPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc= -----END CERTIFICATE----- That's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak: Certificate: Data: Version: 3 (0x2) Serial Number: e0:d7:9d:ed:b2:57:9d:73 Signature Algorithm: sha1WithRSAEncryption Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Validity Not Before: Aug 18 10:26:08 2013 GMT Not After : Aug 16 10:26:08 2023 GMT Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25: ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 X509v3 Authority Key Identifier: keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com serial:E0:D7:9D:ED:B2:57:9D:73 X509v3 Basic Constraints: CA:TRUE Signature Algorithm: sha1WithRSAEncryption 74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c: ... Better, huh? Well, at least parts of it are now readable. Hope you liked this. Obtain a certificate and key # The following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with Mosquitto . You can also create your own self-signed certificate. We provide the generate-CA.sh utility for doing this easily. startssl.com # If you have a key-pair issued by startssl.com , you'll be issued a key (in a *.key file), and a certificate (as *.pem or *.crt -- either contains a PEM-encoded certificate). Mosquitto will need the certificate chain for startssl.com , which you can find as ca-bundle.crt at www.startssl.com/certs/ . As far as TLS is concerned, you'll therefore set up your mosquitto.conf as follows, specifying corrrect paths to the files. listener 8883 cafile ca-bundle.crt certfile server.crt keyfile server.key Then download the startssl.com CA certificate ( ca.crt ) and install that on your device as described above. TLS client certificates # We also support using TLS client certificates","title":"Tls"},{"location":"features/tls/#tls","text":"You want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using TLS . When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.) Configuring TLS ( Transport Layer Security ) for OwnTracks involves doing three things: Obtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one Configure TLS on the MQTT broker Configuring the app to use TLS You can share the certificate if you want to (though not many people will want it ...) It's so public, that it's perfectly OK to send yourself the file by, say, e-mail.","title":"TLS"},{"location":"features/tls/#configure-tls-on-the-mosquitto-broker","text":"We'll first show you how to set up TLS on your Mosquitto broker . The basic configuration for TLS in mosquitto.conf is: listener 8883 cafile ............. certfile ............. keyfile ............. (see also: mosquitto-tls .) 8883 is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port. cafile is the path to the certificate authority file certfile points to your server's certificate in PEM format keyfile points to your server's secret key file (which you never divulge!)","title":"Configure TLS on the Mosquitto broker"},{"location":"features/tls/#configure-the-owntracks-app-to-use-tls","text":"We show you here how to set up your iOS or Android device with that kind of certificate. In both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a .crt extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment. In our example, the CA certificate is called MQTTitude-ca.crt .","title":"Configure the OwnTracks app to use TLS"},{"location":"features/tls/#android","text":"Note that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below). So, here's your e-mail message with said attachment. Now click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen MQTTitude , of course. Then click OK. That's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit. Note that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying).","title":"Android"},{"location":"features/tls/#ios","text":"So, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself! You've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install. Read the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right. There you go! That's it: the certificate was installed. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.","title":"iOS"},{"location":"features/tls/#manual-configuration-on-android","text":"From the, say, e-mail you got with the certificate, click \"save\" on the attached .crt file which is stored on your device's Download folder. In OwnTracks's settings, select TLS (Custom Certificate) Now comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is /storage/emulated/0/Download/MQTTitude.crt . Your mileage, etc; When you click Connect , it will try and use your certificate. Good luck! ;-)","title":"manual configuration on Android"},{"location":"features/tls/#the-nitty-gritty","text":"That CA certificate file we mentioned? The attachment called something.crt ? It looks like this, in fact, in what is called PEM format; but you don't really want to know that, but if you do, this is what it looks like: -----BEGIN CERTIFICATE----- MIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV BAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK ... pjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS cPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc= -----END CERTIFICATE----- That's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak: Certificate: Data: Version: 3 (0x2) Serial Number: e0:d7:9d:ed:b2:57:9d:73 Signature Algorithm: sha1WithRSAEncryption Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Validity Not Before: Aug 18 10:26:08 2013 GMT Not After : Aug 16 10:26:08 2023 GMT Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25: ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 X509v3 Authority Key Identifier: keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85 DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com serial:E0:D7:9D:ED:B2:57:9D:73 X509v3 Basic Constraints: CA:TRUE Signature Algorithm: sha1WithRSAEncryption 74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c: ... Better, huh? Well, at least parts of it are now readable. Hope you liked this.","title":"The nitty gritty"},{"location":"features/tls/#obtain-a-certificate-and-key","text":"The following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with Mosquitto . You can also create your own self-signed certificate. We provide the generate-CA.sh utility for doing this easily.","title":"Obtain a certificate and key"},{"location":"features/tls/#startsslcom","text":"If you have a key-pair issued by startssl.com , you'll be issued a key (in a *.key file), and a certificate (as *.pem or *.crt -- either contains a PEM-encoded certificate). Mosquitto will need the certificate chain for startssl.com , which you can find as ca-bundle.crt at www.startssl.com/certs/ . As far as TLS is concerned, you'll therefore set up your mosquitto.conf as follows, specifying corrrect paths to the files. listener 8883 cafile ca-bundle.crt certfile server.crt keyfile server.key Then download the startssl.com CA certificate ( ca.crt ) and install that on your device as described above.","title":"startssl.com"},{"location":"features/tls/#tls-client-certificates","text":"We also support using TLS client certificates","title":"TLS client certificates"},{"location":"features/tlscert/","text":"Client certificates # The OwnTracks iOS and Android clients can be configured to use TLS client certificates to authenticate against their MQTT broker. This is the next best thing to two-factor authentication, where the apps have a TLS key and a certificate which has to be presented to the broker for successful authentication. Mosquitto # When using the Mosquitto broker support for TLS certificates can be enabled as follows: require_certificate true use_identity_as_username true Client certs # To create a client certificate and key, you can use, say, generate-CA.sh from our tools repository . ./generate-CA.sh client jjolie This produces at least two files which are required on the OwnTracks devices: a .key file and a .crt file. PKCS#12 # In order to safely transport a user's key and certificate to the OwnTracks app, we make use of the PKCS#12 container format. OpenSSL's pkcs12 subcommand creates this container and protects it with a passphrase you specify. This passphrase we will later require in the app. openssl pkcs12 \\ -legacy \\ -export \\ -in jjolie.crt \\ -inkey jjolie.key \\ -name \"Jane's certificate/key\" \\ -out jjolie.p12 (Should you be using an older version of the openssl binary, omit the -legacy option.) You now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a .otrp extension so that it can be opened in OwnTracks. You also send the CA certificate to the device and install it there, as discussed in TLS Android # Save the certificate to your device in an easy accessible location Import the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser. The file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device. Specify the certificate password (certificates without password are not supported). iOS # We recommend you proceed as follows: Install the TLS CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.) Send the prepared PKCS#12 file (with an .otrp extension) to your device, and open it. It will be imported into OwnTracks Launch OwnTracks, select Settings and TLS. Select the otrp file you just imported as Client Certificate Filename, and below that, enter its passphrase. Leave Use Custom Security Policy disabled. Verify the connection to your broker. If need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button Use Custom Security Policy can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only. Mode None; do not use pinned certificates to validate servers Public Key; validate host (broker) certificates against the public keys of the pinned certificate Certificate; validate host certificates against pinned certificates Pinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled. Validate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled. Allow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates. Validate Domain Name; whether or not to validate the domain name in the certificate's CN field. Note: on iOS self-signed certificates require Custom Security Policy to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.) Client certificates are independent of the custom security policy settings. If you wish to use certificate pinning, you must provide a DER-encoded file with an .otre extension to the device containing the pinned certificate. openssl x509 \\ -in ca.crt \\ -out ca.otre \\ -outform DER","title":"Tlscert"},{"location":"features/tlscert/#client-certificates","text":"The OwnTracks iOS and Android clients can be configured to use TLS client certificates to authenticate against their MQTT broker. This is the next best thing to two-factor authentication, where the apps have a TLS key and a certificate which has to be presented to the broker for successful authentication.","title":"Client certificates"},{"location":"features/tlscert/#mosquitto","text":"When using the Mosquitto broker support for TLS certificates can be enabled as follows: require_certificate true use_identity_as_username true","title":"Mosquitto"},{"location":"features/tlscert/#client-certs","text":"To create a client certificate and key, you can use, say, generate-CA.sh from our tools repository . ./generate-CA.sh client jjolie This produces at least two files which are required on the OwnTracks devices: a .key file and a .crt file.","title":"Client certs"},{"location":"features/tlscert/#pkcs12","text":"In order to safely transport a user's key and certificate to the OwnTracks app, we make use of the PKCS#12 container format. OpenSSL's pkcs12 subcommand creates this container and protects it with a passphrase you specify. This passphrase we will later require in the app. openssl pkcs12 \\ -legacy \\ -export \\ -in jjolie.crt \\ -inkey jjolie.key \\ -name \"Jane's certificate/key\" \\ -out jjolie.p12 (Should you be using an older version of the openssl binary, omit the -legacy option.) You now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a .otrp extension so that it can be opened in OwnTracks. You also send the CA certificate to the device and install it there, as discussed in TLS","title":"PKCS#12"},{"location":"features/tlscert/#android","text":"Save the certificate to your device in an easy accessible location Import the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser. The file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device. Specify the certificate password (certificates without password are not supported).","title":"Android"},{"location":"features/tlscert/#ios","text":"We recommend you proceed as follows: Install the TLS CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.) Send the prepared PKCS#12 file (with an .otrp extension) to your device, and open it. It will be imported into OwnTracks Launch OwnTracks, select Settings and TLS. Select the otrp file you just imported as Client Certificate Filename, and below that, enter its passphrase. Leave Use Custom Security Policy disabled. Verify the connection to your broker. If need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button Use Custom Security Policy can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only. Mode None; do not use pinned certificates to validate servers Public Key; validate host (broker) certificates against the public keys of the pinned certificate Certificate; validate host certificates against pinned certificates Pinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled. Validate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled. Allow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates. Validate Domain Name; whether or not to validate the domain name in the certificate's CN field. Note: on iOS self-signed certificates require Custom Security Policy to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.) Client certificates are independent of the custom security policy settings. If you wish to use certificate pinning, you must provide a DER-encoded file with an .otre extension to the device containing the pinned certificate. openssl x509 \\ -in ca.crt \\ -out ca.otre \\ -outform DER","title":"iOS"},{"location":"features/tours/","text":"Tours: Location Sharing # Currently: iOS and Recorder only. Requires: enabled remote CMD on device. You might occasionally wish to share your location with somebody who doesn't have OwnTracks. For these situations you can set up what we call a Tour -- a time-limited view of your location which can be viewed from a Web browser. The OwnTracks Recorder gets a request for a Tour as a JSON published to the ../request subtopic or POSTed to the HTTP endpoint: { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\" } } The Recorder creates a View from this and returns a unique URL to this View which you can share with anybody you want to. { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tour\", \"status\": 200, \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\", \"url\": \"http://localhost:8085/view/7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\" } Your last location is marked on this View's map with a red dot and the track of your movements between the from and to times can be loaded. The important bit: the visitor of the unique URL will not see your location prior to the specified from time nor after the to time. It is also possible to completely delete the Tour in which case a user attempting to access it would get a 404 Not Found. Tours can outlive the to field if you want to, say, provide a historic map of where you once were (i.e. My 2019 vacation on Mallorca ). An authorized client may also request a list of current Tours with this JSON: { \"_type\": \"request\", \"request\": \"tours\" } whereupon an array of existing Tours and their unique URLs is returned: { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tours\", \"tours\": [ { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\", \"url\": \"http://localhost:8085/view/0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } ], \"ntours\": 1 } Only Tours which have been created by a user for their specific device will be enumerated in the Tours list. Tours can be \"un-toured\" (i.e. deleted) with this payload: { \"_type\": \"request\", \"request\": \"untour\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } For Tours to work, the Recorder needs to be compiled with support for HTTP and TOURS, and the following settings need defining: OTR_HTTPPREFIX must be configured to contain the URL to the Recorder as seen from \"outside\", i.e. from the Internet. This setting is used to construct the unique URL which will be returned for a Tour. So, if you have, say, a Recorder behind an NGINX proxy (as described in our README), then the setting would say console export OTR_HTTPPREFIX=\"https://example.net/owntracks\" on the other hand, if you're testing internally and your Recorder is listening on port 8085, you might do this: console export OTR_HTTPPREFIX=\"http://localhost:8085\" Furthermore, the Recorder needs to be able to PUBLISH tour data back to the broker, so an ACL such as the following will be required: topic write owntracks/+/+/cmd Initially we thought the term \"share\" would be good but then decided it's a too ambiguous word, and we didn't want to run into the mess we created with mixing terms (remember region and waypoint? :-) ). After a bit of pondering we think the word tour as in (\"I did a tour last year I want to show you\") or as in (\"I am now on tour\") is adequate.","title":"Tours"},{"location":"features/tours/#tours-location-sharing","text":"Currently: iOS and Recorder only. Requires: enabled remote CMD on device. You might occasionally wish to share your location with somebody who doesn't have OwnTracks. For these situations you can set up what we call a Tour -- a time-limited view of your location which can be viewed from a Web browser. The OwnTracks Recorder gets a request for a Tour as a JSON published to the ../request subtopic or POSTed to the HTTP endpoint: { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\" } } The Recorder creates a View from this and returns a unique URL to this View which you can share with anybody you want to. { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tour\", \"status\": 200, \"tour\": { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\", \"url\": \"http://localhost:8085/view/7fc09e95-0082-4f2e-b3ee-bd68e39a39fe\" } Your last location is marked on this View's map with a red dot and the track of your movements between the from and to times can be loaded. The important bit: the visitor of the unique URL will not see your location prior to the specified from time nor after the to time. It is also possible to completely delete the Tour in which case a user attempting to access it would get a 404 Not Found. Tours can outlive the to field if you want to, say, provide a historic map of where you once were (i.e. My 2019 vacation on Mallorca ). An authorized client may also request a list of current Tours with this JSON: { \"_type\": \"request\", \"request\": \"tours\" } whereupon an array of existing Tours and their unique URLs is returned: { \"_type\": \"cmd\", \"action\": \"response\", \"request\": \"tours\", \"tours\": [ { \"label\": \"Meeting with C. in Essen\", \"from\": \"2022-08-01T05:35:58\", \"to\": \"2022-08-02T15:00:58\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\", \"url\": \"http://localhost:8085/view/0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } ], \"ntours\": 1 } Only Tours which have been created by a user for their specific device will be enumerated in the Tours list. Tours can be \"un-toured\" (i.e. deleted) with this payload: { \"_type\": \"request\", \"request\": \"untour\", \"uuid\": \"0a721022-c54a-49a4-9f5a-f1a76dd92e9e\" } For Tours to work, the Recorder needs to be compiled with support for HTTP and TOURS, and the following settings need defining: OTR_HTTPPREFIX must be configured to contain the URL to the Recorder as seen from \"outside\", i.e. from the Internet. This setting is used to construct the unique URL which will be returned for a Tour. So, if you have, say, a Recorder behind an NGINX proxy (as described in our README), then the setting would say console export OTR_HTTPPREFIX=\"https://example.net/owntracks\" on the other hand, if you're testing internally and your Recorder is listening on port 8085, you might do this: console export OTR_HTTPPREFIX=\"http://localhost:8085\" Furthermore, the Recorder needs to be able to PUBLISH tour data back to the broker, so an ACL such as the following will be required: topic write owntracks/+/+/cmd Initially we thought the term \"share\" would be good but then decided it's a too ambiguous word, and we didn't want to run into the mess we created with mixing terms (remember region and waypoint? :-) ). After a bit of pondering we think the word tour as in (\"I did a tour last year I want to show you\") or as in (\"I am now on tour\") is adequate.","title":"Tours: Location Sharing"},{"location":"features/traccar/","text":"Traccar # Traccar is a free and open source GPS tracking system for which there exists an OwnTracks protocol decoder (called owntracks ) which is, by default, configured on TCP port 5144 on the Traccar server: <entry key='owntracks.port'>5144</entry> Thus you need to configure OwnTracks clients in HTTP mode to connect to your Traccar server at this port, using a URL such as http://traccar.example.net:5144 To make Traccar accept a connection from an owntracks client, you set a matching identifier . This identifier is per default the tid of your device. If you have configured a topic for your device, owntracks will identify using the topic instead of the tid (currently iOS only). An example of a configuration using a topic of owntracks/jane/phone to identify against the Traccar server. Notes # Neither encryption nor friends are supported in Traccar. If you see a 400 error in the Traccar log, this can mean the identifier you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one, tid or topic . HTTP Payloads # HTTP POST payloads shall contain at least the elements lat , lon , _type:location , tst , and either or both of tid and topic . If topic is contained in the payload, that will be used as Traccar's identifier (in which case tid will be added to attributes), else tid . {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"tst\":1497476456, \"tid\":\"JJ\"} {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"topic\":\"owntracks/jane/phone\", \"tid\": \"JJ\"} The following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes: vel , alt , cog , acc , t , batt , so with an HTTP payload that an OwnTracks app produces like { \"cog\": 271, \"batt\": 41, \"lon\": 2.29513, \"acc\": 5, \"vel\": 61, \"vac\": 21, \"lat\": 48.85833, \"t\": \"u\", \"tst\": 1497508651, \"alt\": 167, \"_type\": \"location\", \"topic\": \"owntracks/jane/iphone\", \"p\": 71, \"tid\": \"JJ\" } a query on the Traccar API could produce something like this: [ { \"id\": 475, \"attributes\": { \"t\": \"u\", \"battery\": 41, \"tid\": \"JJ\", \"ip\": \"127.0.0.1\", \"distance\": 0, \"totalDistance\": 0 }, \"deviceId\": 4, \"type\": null, \"protocol\": \"owntracks\", \"serverTime\": \"2017-06-15T06:37:32.000+0000\", \"deviceTime\": \"2017-06-15T06:37:31.000+0000\", \"fixTime\": \"2017-06-15T06:37:31.000+0000\", \"outdated\": false, \"valid\": true, \"latitude\": 48.85833, \"longitude\": 2.29513, \"altitude\": 167, \"speed\": 1.18575, \"course\": 271, \"address\": \"9 Avenue Anatole France, Paris, \u00cele-de-France, FR\", \"accuracy\": 5, \"network\": null } ]","title":"Traccar"},{"location":"features/traccar/#traccar","text":"Traccar is a free and open source GPS tracking system for which there exists an OwnTracks protocol decoder (called owntracks ) which is, by default, configured on TCP port 5144 on the Traccar server: <entry key='owntracks.port'>5144</entry> Thus you need to configure OwnTracks clients in HTTP mode to connect to your Traccar server at this port, using a URL such as http://traccar.example.net:5144 To make Traccar accept a connection from an owntracks client, you set a matching identifier . This identifier is per default the tid of your device. If you have configured a topic for your device, owntracks will identify using the topic instead of the tid (currently iOS only). An example of a configuration using a topic of owntracks/jane/phone to identify against the Traccar server.","title":"Traccar"},{"location":"features/traccar/#notes","text":"Neither encryption nor friends are supported in Traccar. If you see a 400 error in the Traccar log, this can mean the identifier you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one, tid or topic .","title":"Notes"},{"location":"features/traccar/#http-payloads","text":"HTTP POST payloads shall contain at least the elements lat , lon , _type:location , tst , and either or both of tid and topic . If topic is contained in the payload, that will be used as Traccar's identifier (in which case tid will be added to attributes), else tid . {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"tst\":1497476456, \"tid\":\"JJ\"} {\"lon\":2.29513,\"lat\":48.85833,\"_type\":\"location\",\"topic\":\"owntracks/jane/phone\", \"tid\": \"JJ\"} The following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes: vel , alt , cog , acc , t , batt , so with an HTTP payload that an OwnTracks app produces like { \"cog\": 271, \"batt\": 41, \"lon\": 2.29513, \"acc\": 5, \"vel\": 61, \"vac\": 21, \"lat\": 48.85833, \"t\": \"u\", \"tst\": 1497508651, \"alt\": 167, \"_type\": \"location\", \"topic\": \"owntracks/jane/iphone\", \"p\": 71, \"tid\": \"JJ\" } a query on the Traccar API could produce something like this: [ { \"id\": 475, \"attributes\": { \"t\": \"u\", \"battery\": 41, \"tid\": \"JJ\", \"ip\": \"127.0.0.1\", \"distance\": 0, \"totalDistance\": 0 }, \"deviceId\": 4, \"type\": null, \"protocol\": \"owntracks\", \"serverTime\": \"2017-06-15T06:37:32.000+0000\", \"deviceTime\": \"2017-06-15T06:37:31.000+0000\", \"fixTime\": \"2017-06-15T06:37:31.000+0000\", \"outdated\": false, \"valid\": true, \"latitude\": 48.85833, \"longitude\": 2.29513, \"altitude\": 167, \"speed\": 1.18575, \"course\": 271, \"address\": \"9 Avenue Anatole France, Paris, \u00cele-de-France, FR\", \"accuracy\": 5, \"network\": null } ]","title":"HTTP Payloads"},{"location":"features/waypoints/","text":"Regions (Waypoints) # A region , geofence , or waypoint (sadly we've used these terms interchangeably) is a circular area you configure in the UI on your OwnTracks device. The device then begins monitoring whether the area is being entered or left and it will publish what we call a transition event accordingly. The base topic for publishes from the OwnTracks apps is what you've configured it to be in the apps' preferences / settings. This base topic is used for publishes of type location (see JSON ). All messages published to this base topic are retained if you have configured the app to retain them. So upon entering or leaving a region, the device publishes a transition event which contains: element meaning desc description with the name you set for the waypoint event \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. rid the region ID of the region lat , lon where the region was detected (entering respectively leaving) tid trackerID tst timestamp when the event was published wtst the time stamp of when the region was created For example, this JSON might be published when entering a region: { \"_type\": \"transition\", \"desc\": \"My favorite coffee shop (Delaville)\", \"event\": \"enter\", \"lat\": 48.87069, \"lon\": 2.34916, \"rid\": \"f7676c\", \"tid\": \"j1\", \"tst\": 1707057574, \"wtst\": 1610104395 } If you set up a region (or waypoint or geo-fence, you get the drift), the app publishes that region (with retain=0 irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . Entering or leaving a waypoint will be published as a transition message and will contain a wtst (for historical purposes) with the timestamp of when the region was originally defined. (Note that that branch is /waypoint -- singular.) For example, If Jane configures a region on her iPhone, the app could publish the following payload to owntracks/jane/phone/waypoint : { \"_type\": \"waypoint\", \"desc\": \"My favorite coffee shop (Delaville)\", \"lat\": 48.87069, \"lon\": 2.34916, \"rad\": \"50\", \"tst\": \"1385997757\", \"rid\": \"f7676c\", \"wtst\": 1610104395 } When you set up a region (with a desc ription and a rad ius), this new region is published to the broker with the current time stamp. If you update the region definition on the device at a later stage, the region is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius and lat itude / lon gitude, but with the same rid . To be precise, the rid (region ID) is used as an identifier of the region even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting regions by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location , transition , and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of regions, e.g. for displaying to users. In regions # When the apps publish a _type = location message, they add to that an array called inregions (and as from January 2021 an array called inrids ) with the names of the regions and their respective rid s. The inregions array might be consumed by humans whereas the inrids array would be consumed by developers who will wish to associate the region IDs ( rid ) with the values in inrids . Adding on iOS # On iOS you can navigate to the place where you want to place a region, Tap long and edit the Region. The region gets a default name ( Here .. ) which you will want to change to something meaningful. With a bit of practice, you can then drag the region to it's final destination on the map or, and this may be easier, edit the region and specify its exact coordinates. Adding on Android # On Android, regions can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker. Remote loading of regions # Instead of configuring multiple regions on the device, they can be loaded remotely with the setWaypoints cmd message if remote configuration is enabled on the device. You can use this to import individual regions or groups of pre-configured regions which are merged into the existing regions definition on the device. Recall, however, that the rid element is like a key which uniquely identifies each region / waypoint; leave it unchanged when modifying and resubmitting a waypoint. { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"_type\": \"waypoints\", \"waypoints\": [ { \"_type\": \"waypoint\", \"tst\": 1708625557, \"rid\": \"my-region-id-1\", \"desc\": \"home\", \"rad\": 100, \"lat\": 30.0, \"lon\": 40.0 }, { \"_type\": \"waypoint\", \"tst\": 1708625558, \"rid\": \"my-region-id-2\", \"desc\": \"work\", \"rad\": 100, \"lat\": 30.1, \"lon\": 40.1 } ] } } Assuming the above is in a file named wp.json , a user can publish that to themselves (or an authorized user to any other) as follows (note the use of jq -c which ensures a single line of JSON and the benefit that jq verifies for valid JSON): $ jq -c . wp.json | mosquitto_pub -u username -P 'password' -t owntracks/jane/nokia/cmd -q 1 -l Deleting regions # On iOS a region can be deleted by swiping it away. On Android, a long press is required. Note that deleting a region on the device does not publish anything to the MQTT broker or HTTP server. Beacons Ranging # In addition to circular regions, the iOS app can monitor its proximity to BLE Beacons .","title":"Waypoints"},{"location":"features/waypoints/#regions-waypoints","text":"A region , geofence , or waypoint (sadly we've used these terms interchangeably) is a circular area you configure in the UI on your OwnTracks device. The device then begins monitoring whether the area is being entered or left and it will publish what we call a transition event accordingly. The base topic for publishes from the OwnTracks apps is what you've configured it to be in the apps' preferences / settings. This base topic is used for publishes of type location (see JSON ). All messages published to this base topic are retained if you have configured the app to retain them. So upon entering or leaving a region, the device publishes a transition event which contains: element meaning desc description with the name you set for the waypoint event \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. rid the region ID of the region lat , lon where the region was detected (entering respectively leaving) tid trackerID tst timestamp when the event was published wtst the time stamp of when the region was created For example, this JSON might be published when entering a region: { \"_type\": \"transition\", \"desc\": \"My favorite coffee shop (Delaville)\", \"event\": \"enter\", \"lat\": 48.87069, \"lon\": 2.34916, \"rid\": \"f7676c\", \"tid\": \"j1\", \"tst\": 1707057574, \"wtst\": 1610104395 } If you set up a region (or waypoint or geo-fence, you get the drift), the app publishes that region (with retain=0 irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . Entering or leaving a waypoint will be published as a transition message and will contain a wtst (for historical purposes) with the timestamp of when the region was originally defined. (Note that that branch is /waypoint -- singular.) For example, If Jane configures a region on her iPhone, the app could publish the following payload to owntracks/jane/phone/waypoint : { \"_type\": \"waypoint\", \"desc\": \"My favorite coffee shop (Delaville)\", \"lat\": 48.87069, \"lon\": 2.34916, \"rad\": \"50\", \"tst\": \"1385997757\", \"rid\": \"f7676c\", \"wtst\": 1610104395 } When you set up a region (with a desc ription and a rad ius), this new region is published to the broker with the current time stamp. If you update the region definition on the device at a later stage, the region is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius and lat itude / lon gitude, but with the same rid . To be precise, the rid (region ID) is used as an identifier of the region even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting regions by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location , transition , and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of regions, e.g. for displaying to users.","title":"Regions (Waypoints)"},{"location":"features/waypoints/#in-regions","text":"When the apps publish a _type = location message, they add to that an array called inregions (and as from January 2021 an array called inrids ) with the names of the regions and their respective rid s. The inregions array might be consumed by humans whereas the inrids array would be consumed by developers who will wish to associate the region IDs ( rid ) with the values in inrids .","title":"In regions"},{"location":"features/waypoints/#adding-on-ios","text":"On iOS you can navigate to the place where you want to place a region, Tap long and edit the Region. The region gets a default name ( Here .. ) which you will want to change to something meaningful. With a bit of practice, you can then drag the region to it's final destination on the map or, and this may be easier, edit the region and specify its exact coordinates.","title":"Adding on iOS"},{"location":"features/waypoints/#adding-on-android","text":"On Android, regions can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker.","title":"Adding on Android"},{"location":"features/waypoints/#remote-loading-of-regions","text":"Instead of configuring multiple regions on the device, they can be loaded remotely with the setWaypoints cmd message if remote configuration is enabled on the device. You can use this to import individual regions or groups of pre-configured regions which are merged into the existing regions definition on the device. Recall, however, that the rid element is like a key which uniquely identifies each region / waypoint; leave it unchanged when modifying and resubmitting a waypoint. { \"_type\": \"cmd\", \"action\": \"setWaypoints\", \"waypoints\": { \"_type\": \"waypoints\", \"waypoints\": [ { \"_type\": \"waypoint\", \"tst\": 1708625557, \"rid\": \"my-region-id-1\", \"desc\": \"home\", \"rad\": 100, \"lat\": 30.0, \"lon\": 40.0 }, { \"_type\": \"waypoint\", \"tst\": 1708625558, \"rid\": \"my-region-id-2\", \"desc\": \"work\", \"rad\": 100, \"lat\": 30.1, \"lon\": 40.1 } ] } } Assuming the above is in a file named wp.json , a user can publish that to themselves (or an authorized user to any other) as follows (note the use of jq -c which ensures a single line of JSON and the benefit that jq verifies for valid JSON): $ jq -c . wp.json | mosquitto_pub -u username -P 'password' -t owntracks/jane/nokia/cmd -q 1 -l","title":"Remote loading of regions"},{"location":"features/waypoints/#deleting-regions","text":"On iOS a region can be deleted by swiping it away. On Android, a long press is required. Note that deleting a region on the device does not publish anything to the MQTT broker or HTTP server.","title":"Deleting regions"},{"location":"features/waypoints/#beacons-ranging","text":"In addition to circular regions, the iOS app can monitor its proximity to BLE Beacons .","title":"Beacons Ranging"},{"location":"guide/apps/","text":"OwnTracks apps # The OwnTracks apps operate in one of two modes (discussed in scenarios ), and you tell the app in which mode you want to use it. In MQTT mode, you configure our iOS and Android app to access your broker, and in HTTP mode you do similarly but with an HTTP endpoint. iOS Android configure the Android app FIXME: configure the iOS app Further clients # As soon as you feel comfortable using OwnTracks you might with to look at further clients and what they can do for you.","title":"Apps"},{"location":"guide/apps/#owntracks-apps","text":"The OwnTracks apps operate in one of two modes (discussed in scenarios ), and you tell the app in which mode you want to use it. In MQTT mode, you configure our iOS and Android app to access your broker, and in HTTP mode you do similarly but with an HTTP endpoint. iOS Android configure the Android app FIXME: configure the iOS app","title":"OwnTracks apps"},{"location":"guide/apps/#further-clients","text":"As soon as you feel comfortable using OwnTracks you might with to look at further clients and what they can do for you.","title":"Further clients"},{"location":"guide/beacons/","text":"iBeacons # What is an iBeacon? # An iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement. If you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received. What you can do with iBeacons in OwnTracks # This data is detected by your OwnTracks iOS device and can be used for region monitoring. Use an iBeacon to get your exact location Position an iBeacon in your study and get enter- and leave-events from that room. Use an iBeacon to connect yourself with a vehicle Equip your car with an iBeacon and monitor how much time you spend commuting. Always see where you parked your car. Use an iBeacon to track a valuable accessory Fit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind. Full feature set is here .","title":"Beacons"},{"location":"guide/beacons/#ibeacons","text":"","title":"iBeacons"},{"location":"guide/beacons/#what-is-an-ibeacon","text":"An iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement. If you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received.","title":"What is an iBeacon?"},{"location":"guide/beacons/#what-you-can-do-with-ibeacons-in-owntracks","text":"This data is detected by your OwnTracks iOS device and can be used for region monitoring. Use an iBeacon to get your exact location Position an iBeacon in your study and get enter- and leave-events from that room. Use an iBeacon to connect yourself with a vehicle Equip your car with an iBeacon and monitor how much time you spend commuting. Always see where you parked your car. Use an iBeacon to track a valuable accessory Fit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind. Full feature set is here .","title":"What you can do with iBeacons in OwnTracks"},{"location":"guide/bridge/","text":"Bridging # In order to profit from the Friends feature in OwnTracks, all contacts you want to be able to track on your your device must share a broker, but that can be difficult if both you and your friend (henceforce \"Jane\" in the examples that follow) also use your brokers for other purposes. Mosquitto (and some other MQTT brokers) have a feature called bridging which basically lets you connect two (or more) brokers together. Let's assume that you and Jane want to see each other's location updates while maintaining a connection from your devices to your respective MQTT brokers at home. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those. What will happen? # Setting up a bridge is not difficult, but there are some things we have to keep in mind. In this example, we'll assume the following: Your broker will initiate a connection to Jane's broker You'll be using TLS to protect credentials and data in transit Jane has given you (e.g. via e-mail) a copy of her TLS CA certificate Jane has set up an ACL on her Mosquitto broker to ensure you have access only to her OwnTracks location data and nothing else. Jane has a username and password for your broker to use when connecting to her broker, and she's given you both. Jane has a device called nexus7 and she publishes location updates to her broker at owntracks/jane/nexus7 . You have an iPhone and want to share your location data with Jane. You publish (on your broker) to owntracks/john/iphone . Here's what you configure on your broker 's mosquitto.conf : # Bridge to Jane connection br-me-to-jane bridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt bridge_insecure false address jane.example.org:8883 cleansession false clientid br-john-jane start_type automatic username john password s3cr1t notifications false try_private true topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic iphone out 2 owntracks/john/ owntracks/john/ These last two lines define which topic branches will be published ( out ) and which will be subscribed to ( in ) from the point of view of your broker. There are a lot of things you can tweak in this configuration, but this is should get you started. Publishes # When your device publishes location data to your broker, it will publish the single topic owntracks/john/iphone to Jane's broker. Conversely, as your broker is now subscribed to Jane's at owntracks/jane/nexus7 , it will receive Jane's location data and re-publish that to your connected device. Events # OwnTracks uses more than just a single topic per user as documented . This means we must add more topic statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location now ). Assuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes in to our broker. The second line is new: it bridges Jane's nexus7 events into our broker. topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/ CMD # Tapping on OwnTrack's request location update publishes a cmd to the destination device, so we bridge that topic out towards Jane's broker: topic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/ MQTTitude # Let's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration: topic # in 2 owntracks/ mqttitude/ What this does is: your bridge subscribes to the remote topic mqttitude/# and all received messages will be republished at owntracks/ on your broker (note the in direction). Neat, eh? Consult the manual page for mosquitto.conf for more details.","title":"Bridge"},{"location":"guide/bridge/#bridging","text":"In order to profit from the Friends feature in OwnTracks, all contacts you want to be able to track on your your device must share a broker, but that can be difficult if both you and your friend (henceforce \"Jane\" in the examples that follow) also use your brokers for other purposes. Mosquitto (and some other MQTT brokers) have a feature called bridging which basically lets you connect two (or more) brokers together. Let's assume that you and Jane want to see each other's location updates while maintaining a connection from your devices to your respective MQTT brokers at home. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those.","title":"Bridging"},{"location":"guide/bridge/#what-will-happen","text":"Setting up a bridge is not difficult, but there are some things we have to keep in mind. In this example, we'll assume the following: Your broker will initiate a connection to Jane's broker You'll be using TLS to protect credentials and data in transit Jane has given you (e.g. via e-mail) a copy of her TLS CA certificate Jane has set up an ACL on her Mosquitto broker to ensure you have access only to her OwnTracks location data and nothing else. Jane has a username and password for your broker to use when connecting to her broker, and she's given you both. Jane has a device called nexus7 and she publishes location updates to her broker at owntracks/jane/nexus7 . You have an iPhone and want to share your location data with Jane. You publish (on your broker) to owntracks/john/iphone . Here's what you configure on your broker 's mosquitto.conf : # Bridge to Jane connection br-me-to-jane bridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt bridge_insecure false address jane.example.org:8883 cleansession false clientid br-john-jane start_type automatic username john password s3cr1t notifications false try_private true topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic iphone out 2 owntracks/john/ owntracks/john/ These last two lines define which topic branches will be published ( out ) and which will be subscribed to ( in ) from the point of view of your broker. There are a lot of things you can tweak in this configuration, but this is should get you started.","title":"What will happen?"},{"location":"guide/bridge/#publishes","text":"When your device publishes location data to your broker, it will publish the single topic owntracks/john/iphone to Jane's broker. Conversely, as your broker is now subscribed to Jane's at owntracks/jane/nexus7 , it will receive Jane's location data and re-publish that to your connected device.","title":"Publishes"},{"location":"guide/bridge/#events","text":"OwnTracks uses more than just a single topic per user as documented . This means we must add more topic statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location now ). Assuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes in to our broker. The second line is new: it bridges Jane's nexus7 events into our broker. topic nexus7 in 2 owntracks/jane/ owntracks/jane/ topic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/","title":"Events"},{"location":"guide/bridge/#cmd","text":"Tapping on OwnTrack's request location update publishes a cmd to the destination device, so we bridge that topic out towards Jane's broker: topic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/","title":"CMD"},{"location":"guide/bridge/#mqttitude","text":"Let's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration: topic # in 2 owntracks/ mqttitude/ What this does is: your bridge subscribes to the remote topic mqttitude/# and all received messages will be republished at owntracks/ on your broker (note the in direction). Neat, eh? Consult the manual page for mosquitto.conf for more details.","title":"MQTTitude"},{"location":"guide/broker/","text":"MQTT broker # An MQTT broker is a service to which MQTT clients connect. These clients publish data to specific topics and they can subscribe to one or more topics to receive messages. A topic is like an \"address\" for a particular message. For example, a topic for a device that publishes a temperature reading of your living room may be temperature/indoors/living , whereas a device which publishes weather data could do so to weather/germany/frankfurt . In the particular case of OwnTracks, we use a topic branch called owntracks/username/device , but you can override that name if you prefer to. The reason we've chosen that structure is to accomodate friends and family on a single broker, taking into consideration that a particular user might have more than one device. Private broker # You set up a private broker under your control. This sounds more difficult than it actually is, and there are some very nice brokers you can use free of charge on your own infrastructure. As an example, we've written up how to install Mosquitto on a Raspberry Pi. RasPi # The hardest bit is installing an OS, say, Raspbian Wheezy , onto an SD card, but there are many tutorials on how to do that. A basic install will suffice, and after logging in with Raspbian's default username and password, we're going to suggest you use our quicksetup to configure most of what you need automatically. Bridging # If you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up how you can bridge brokers . Logging # Before doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening. Mosquitto typically logs via syslog , and syslog 's configuration defines where the log messages are actually written to. Your syslog may be called syslog , rsyslog , syslog-ng , or anything else for that matter. In case of doubt, check the files in /var/log ; one of them ought to have what you're looking for (e..g messages , syslog , localmessages , or even debugmessages ), very likely /var/log/mosquitto/mosquitto.log . Mosquitto typically logs each connection request, a publish, a subscribe request, etc. A successful publish of an OwnTracks location could look somewhat like this: mosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes)) mosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7) mosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7) mosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7) OwnTracks # So, you've configured your broker and you are familiar with the mosquitto command-line clients, so now it's time to see if you can get OwnTracks to speak to your broker .","title":"Broker"},{"location":"guide/broker/#mqtt-broker","text":"An MQTT broker is a service to which MQTT clients connect. These clients publish data to specific topics and they can subscribe to one or more topics to receive messages. A topic is like an \"address\" for a particular message. For example, a topic for a device that publishes a temperature reading of your living room may be temperature/indoors/living , whereas a device which publishes weather data could do so to weather/germany/frankfurt . In the particular case of OwnTracks, we use a topic branch called owntracks/username/device , but you can override that name if you prefer to. The reason we've chosen that structure is to accomodate friends and family on a single broker, taking into consideration that a particular user might have more than one device.","title":"MQTT broker"},{"location":"guide/broker/#private-broker","text":"You set up a private broker under your control. This sounds more difficult than it actually is, and there are some very nice brokers you can use free of charge on your own infrastructure. As an example, we've written up how to install Mosquitto on a Raspberry Pi.","title":"Private broker"},{"location":"guide/broker/#raspi","text":"The hardest bit is installing an OS, say, Raspbian Wheezy , onto an SD card, but there are many tutorials on how to do that. A basic install will suffice, and after logging in with Raspbian's default username and password, we're going to suggest you use our quicksetup to configure most of what you need automatically.","title":"RasPi"},{"location":"guide/broker/#bridging","text":"If you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up how you can bridge brokers .","title":"Bridging"},{"location":"guide/broker/#logging","text":"Before doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening. Mosquitto typically logs via syslog , and syslog 's configuration defines where the log messages are actually written to. Your syslog may be called syslog , rsyslog , syslog-ng , or anything else for that matter. In case of doubt, check the files in /var/log ; one of them ought to have what you're looking for (e..g messages , syslog , localmessages , or even debugmessages ), very likely /var/log/mosquitto/mosquitto.log . Mosquitto typically logs each connection request, a publish, a subscribe request, etc. A successful publish of an OwnTracks location could look somewhat like this: mosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes)) mosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7) mosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7) mosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7)","title":"Logging"},{"location":"guide/broker/#owntracks","text":"So, you've configured your broker and you are familiar with the mosquitto command-line clients, so now it's time to see if you can get OwnTracks to speak to your broker .","title":"OwnTracks"},{"location":"guide/clients/","text":"Clients # Using our OwnTracks app is cool, but what do you do with the location data the apps send (i.e. publish ) to the MQTT broker? We have some suggestions. You know that OwnTracks publishes location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called JSON , and this is what it looks like . When you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that. mosquitto_sub # mosquitto_sub is a very basic command-line client provided by the Mosquitto project . However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with stdout pointing to a file. In it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in. (If you've used our quicksetup you just need the -t 'owntracks/# option as we've configured the rest for you.) mosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#' mosquitto_sub and it's counterpart, mosquitto_pub for publishing to a broker, support a slew of options. It'll be worth your while to study their manual page . Recorder # We recommend our very own OwnTracks Recorder because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind. And the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well. Here again, if you used quicksetup , you already have a correctly configured Recorder. Read more about the Recorder . mqttwarn # You will recall the discussion on MQTT , and the analogy with the cauldron. On this matter, mqttwarn , while not specific to OwnTracks, is another client you can connect to your MQTT broker . We think it is worth mentioning, and both Ben and JP -- the creators -- are quite pleased with what it does. mqttwarn lets you do things like submitting a tweet each time OwnTracks reports a location (but do consider whether you really want that ;]), send an e-mail when a loved one enters a particular region, or use ntfy.sh to deliver a notification to your mobile phone, just to name a few examples of what is possible. Think of a self-hosted IFTTT or Zapier, but all that running on your premises, and a bit less enterprise. Technically speaking, mqttwarn is a highly configurable MQTT message router, where the routing targets are notification plugins, written in Python. mqttwarn currently supports well over 90 different notification services or providers. A picture says a thousand words. Enjoy exploring the mqttwarn documentation . openHAB # Presence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action. This is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal MQTT broker where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in all your data is yours and yours alone - there is no cloud service collecting, storing and potentially mining your data. Read more about openHAB and OwnTracks . Home Assistant # Another home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal MQTT broker . It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4. See the demo for an example of the map with OwnTracks devices or read more about how Home Assistant connects to your private MQTT broker , how to enable OwnTracks support in Home Assistant and how to configure automations based on zones . Roll your own # If you feel really brave, you can write your own program which subscribes to OwnTracks data, but don't forget to tell us about it! Related # Here are some projects we know of which use and/or integrate OwnTracks and/or which are useful when using MQTT in general or OwnTracks in particular. MQTT Inspector for iOS , written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT. the thing system ( code ) A Clojure webapp that aims to manage information gathered from OwnTracks; clojure-mqttitude-backend An OwnTracks flow by Giovanni @juzam Angoli for Node-RED which publishes messages to pushover.net upon entering or leaving a geo-fence. MyMQTT is an app for Android which enables you to subscribe and publish to an MQTT broker. Matthew Bordignon made a small Web page which uses Websockets to display the barometer reading published by OwnTracks for iOS. ( Screenshot .) PHP front & backend for OwnTracks payloads Orion, an alternative to OwnTracks Recorder with powerful visualization features ( server , web client , demo ) OwntracksOSM is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches ( screenshots ). From OwnTracks to QGIS , a solution to import OwnTracks data into QGIS. Magic Mirror module for displaying results from OpenTracks Prometheus OwnTracks Exporter hauk-snitch bridges OwnTracks and Hauk and makes it easy to share your current live location with other people for a given period of time. Just send them a link, all they need is a browser. mqottrace , written by Michael Staats is a Perl program which collects OwnTracks locations and stores them in an SQLite3 database; it also includes a tool to convert this data to GPX format.","title":"Clients"},{"location":"guide/clients/#clients","text":"Using our OwnTracks app is cool, but what do you do with the location data the apps send (i.e. publish ) to the MQTT broker? We have some suggestions. You know that OwnTracks publishes location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called JSON , and this is what it looks like . When you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that.","title":"Clients"},{"location":"guide/clients/#mosquitto_sub","text":"mosquitto_sub is a very basic command-line client provided by the Mosquitto project . However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with stdout pointing to a file. In it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in. (If you've used our quicksetup you just need the -t 'owntracks/# option as we've configured the rest for you.) mosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#' mosquitto_sub and it's counterpart, mosquitto_pub for publishing to a broker, support a slew of options. It'll be worth your while to study their manual page .","title":"mosquitto_sub"},{"location":"guide/clients/#recorder","text":"We recommend our very own OwnTracks Recorder because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind. And the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well. Here again, if you used quicksetup , you already have a correctly configured Recorder. Read more about the Recorder .","title":"Recorder"},{"location":"guide/clients/#mqttwarn","text":"You will recall the discussion on MQTT , and the analogy with the cauldron. On this matter, mqttwarn , while not specific to OwnTracks, is another client you can connect to your MQTT broker . We think it is worth mentioning, and both Ben and JP -- the creators -- are quite pleased with what it does. mqttwarn lets you do things like submitting a tweet each time OwnTracks reports a location (but do consider whether you really want that ;]), send an e-mail when a loved one enters a particular region, or use ntfy.sh to deliver a notification to your mobile phone, just to name a few examples of what is possible. Think of a self-hosted IFTTT or Zapier, but all that running on your premises, and a bit less enterprise. Technically speaking, mqttwarn is a highly configurable MQTT message router, where the routing targets are notification plugins, written in Python. mqttwarn currently supports well over 90 different notification services or providers. A picture says a thousand words. Enjoy exploring the mqttwarn documentation .","title":"mqttwarn"},{"location":"guide/clients/#openhab","text":"Presence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action. This is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal MQTT broker where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in all your data is yours and yours alone - there is no cloud service collecting, storing and potentially mining your data. Read more about openHAB and OwnTracks .","title":"openHAB"},{"location":"guide/clients/#home-assistant","text":"Another home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal MQTT broker . It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4. See the demo for an example of the map with OwnTracks devices or read more about how Home Assistant connects to your private MQTT broker , how to enable OwnTracks support in Home Assistant and how to configure automations based on zones .","title":"Home Assistant"},{"location":"guide/clients/#roll-your-own","text":"If you feel really brave, you can write your own program which subscribes to OwnTracks data, but don't forget to tell us about it!","title":"Roll your own"},{"location":"guide/clients/#related","text":"Here are some projects we know of which use and/or integrate OwnTracks and/or which are useful when using MQTT in general or OwnTracks in particular. MQTT Inspector for iOS , written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT. the thing system ( code ) A Clojure webapp that aims to manage information gathered from OwnTracks; clojure-mqttitude-backend An OwnTracks flow by Giovanni @juzam Angoli for Node-RED which publishes messages to pushover.net upon entering or leaving a geo-fence. MyMQTT is an app for Android which enables you to subscribe and publish to an MQTT broker. Matthew Bordignon made a small Web page which uses Websockets to display the barometer reading published by OwnTracks for iOS. ( Screenshot .) PHP front & backend for OwnTracks payloads Orion, an alternative to OwnTracks Recorder with powerful visualization features ( server , web client , demo ) OwntracksOSM is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches ( screenshots ). From OwnTracks to QGIS , a solution to import OwnTracks data into QGIS. Magic Mirror module for displaying results from OpenTracks Prometheus OwnTracks Exporter hauk-snitch bridges OwnTracks and Hauk and makes it easy to share your current live location with other people for a given period of time. Just send them a link, all they need is a browser. mqottrace , written by Michael Staats is a Perl program which collects OwnTracks locations and stores them in an SQLite3 database; it also includes a tool to convert this data to GPX format.","title":"Related"},{"location":"guide/quicksetup/","text":"Get started quickly # Using OwnTracks means having to set up and configure your own server, which can be non-trivial. For this reason we have created what we call quicksetup , a set of tools which will hopefully get your OwnTracks environment set up as effortlessly as possible. To get started you'll need roughly an hour of time and a bit of love of a Linux command line. You'll also need the following: a small dedicated Linux-capable device (e.g. a Raspberry Pi or equivalent) or a dedicated Linux VPS (Virtual Private Server), either at your home or from one of the many VPS providers. some offerings are free of charge, though you'll need patience to wade through their lingo. (Oracle cloud, Good Cloud, and possibly a few others have a free tier.) we've had very good experience with the likes of DigitalOcean; at the time of this writing they have a 512MB Debian 12 VPS which serves us very well. But there are many others: Linode, Server4you, Hetzner, Netcup, ... look around and compare we've tested this setup on Ubuntu 22.04 ( jammy ) and on Debian/Raspbian 12 ( bookworm ); anything older or different might well cause issues, but we'll gladly help if we can a DNS domain, something like owntracks.example , which will be associated with your VPS. Some VPS providers offer one in a package with the VPS. Be that as it may, the technical jargon is you let that DNS domain and associate the IPv4 and/or IPv6 address of your VPS with owntracks.example . if your Linux machine is at home, say, you'll need to open a few TCP ports in your router: port 80 for Let's Encrypt enrollment and renewals only port 443 (optional) if you wish to permit authenticated access to your OwnTracks Web interface from \"outside\" port 8883 the MQTT port Before continuing, make sure you can login to your VPS, either as root or as an unprivileged user, but you will need to escalate privileges using sudo . after logging in, the following program invocation should produce output similar to that shown: $ sudo id uid=0(root) gid=0(root) groups=0(root) if you are prompted for a password, it will be your user password. After entering it you ought to see the output as above. also make sure the DNS domain you chose is associated with your VPS. You can probably test this by using the ping utility from your laptop. The machine might not actually be reachable, but you should see its IP address: $ ping owntracks.example ... You should now be ready to proceed. What you can expect # Let's briefly describe what quicksetup will actually attempt to accomplish so that you can follow along. we'll attempt to enroll your VPS with Let's Encrypt on your behalf in order to have an SSL (TLS) certificate issued with which the Web server and the MQTT broker on your VPS will be protected. This ensures that all communication via HTTP (to the Web server) and via MQTT (to the broker) will be encrypted. We also install a cron job with which the Let's Encrypt certificate will automatically be renewed when required. we install an nginx Web server so that you can login to use our Frontend and other Web-based tools. We generate random passwords with which you login, and you will later find these passwords on the system in files called /usr/local/owntracks/userdata/*.pass . we install a Mosquitto MQTT broker in order for our Android or iOS apps to be able to publish location data to your OwnTracks VPS. As mentioned earlier, communication between the apps and the broker is encrypted via SSL/TLS. We also create automatic configuration files so you can auto-configure the OwnTracks apps using our *.otrc files or a magic link on a Web page. The broker is configured to permit access only to users you specify with the same passwords we create randomly for the Web server. we install and configure our Recorder. This is a program which subscribes to MQTT (on your VPS) and receives location publishes when your OwnTracks apps change location. The data is stored and can later be viewed with Frontend. you will be able to specify any number of Friends during the configuration below. Each of these friends can use the MQTT broker, use the Web server, login with their username and different random password. So, if everything works the way we hope it will, this ought to be a plug-and-play experience. Fingers crossed, let us begin. Launching quicksetup # You are logged into your VPS either as root or as an unprivileged user. Three steps will get the installer going: ensure you are running a supported operating system (e.g. bookworm ) by running $ hostnamectl ... Operating System: Debian GNU/Linux 12 (bookworm) ... obtain our quicksetup installer; we can't do this for you, but it's easy: you clone our repository. $ sudo apt install -y git # not required on Ubuntu $ git clone --depth=1 https://github.com/owntracks/quicksetup $ cd quicksetup you now have all the files on your system, so feel free to look around. If you just want to continue, make a copy of the configuration and edit it with an editor. The file's content ought to be self-explanatory, but do ask us if it isn't. $ cp configuration.yaml.example configuration.yaml $ nano configuration.yaml the configuration file requires the following settings: dns_domain is the DNS name of your system as reacheable from the Internet. You will set this to, say, owntracks.example . Make sure you replace this value by the correct name for your installation. email is the email address which we will use when enrolling a Let's Encrypt certificate on your behalf. We don't use this for anything else, and Let's Encrypt will send you mail only when your certificate is about to expire. we strongly recommend you sign up for the free reverse geo service at OpenCage . It's free of charge, and they provide you with an API key you add to opencage_apikey . This is used in determining address information for locations (example below), and we configure your OwnTracks Android app to use it. It's so much nicer when you can see the addresses of locations you've visited in our maps. friends is an array of users who will be supported on your system. It will typically contain just yourself, but you might wish to have family members, relatives, or friends use OwnTracks on your system. friends: - { tid: JJ, username: jane, devicename: nokia } - { tid: ip, username: jip, devicename: iPad } - { tid: j2, username: jjolie, devicename: Phone } each line describes a friend , and you should be on the first line (we'll divulge later why that is). There are three fields on each line, all three are strings which may be enclosed in quotes. The tid is displayed by default on the phone and must not be longer than two characters. The username (with which you also login) and the devicename form the topic to which your devices will publish location data. once you've edited the configuration file with the settings you wish, launch the installer which will install packages and configure services. Did you remember to open the TCP ports in your router? $ sudo ./bootstrap.sh This last step will install a program which will begin the actual installation. The program is called Ansible and it uses a file provided by quicksetup to begin configuring all the services as described above. PLAY [OwnTracks Quick Setup] ******************************************************** TASK [Gathering Facts] ************************************************************** ok: [localhost] TASK [system: template out sys.info] ************************************************ changed: [localhost] TASK [verify some requirements] ***************************************************** ok: [localhost] => { \"changed\": false, \"msg\": \"All assertions passed\" } TASK [detect: acme] ***************************************************************** ok: [localhost] TASK [system: install OwnTracks repository key] ************************************* changed: [localhost] TASK [system: install OwnTracks repository] ***************************************** changed: [localhost] TASK [system: install required packages] ... If all goes well you ought to see green and/or yellow lines only; no red diagnostics. Red means error, and the installer would halt. Some of the steps will take longer than others, for instance we install several software packages which takes a bit. Should you wish to, say, add a friend at a later stage, edit configuration.yaml , and re-run ./bootstrap.sh as you did earlier. As often as you wish. Initial testing # Assuming the installer was successful, you can verify if the services are working as we intended them to: install OwnTracks on your Android or iOS device and configure it, either by sending yourself one of the files from /usr/local/owntracks/userdata/*.otrc visiting https://owntracks.example/owntracks/ and logging with your username (from the friends list in configuration.yaml ) and the corresponding password from /usr/local/owntracks/userdata/<username>.pass . At the bottom of the page is a link you can click on from your Android/iOS device to automatically configure the app. in the app on the smartphone, click on the publish up arrow Android iOS back on your VPS, use the following pre-configured utility to subscribe to your MQTT broker; by pre-configured we mean you won't need to specify username, password, hosts, etc: $ mosquitto_sub -v -t 'owntracks/#' on the console you should see some output from mosquitto_sub which looks a bit like this: owntracks/jane/nokia {\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"created_at\":1706856299,\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706856298,\"vel\":0} the output on your system will differ. The first part before the first space, is called the topic name. This is a kind of \"address\" to which your app publishes data, and each user on your system has a unique topic which has three parts: the constant owntracks , followed by the username, and the device name. After the initial space comes the actual location data your phone published. Let's format that neatly: you see the data includes a time stamp ( tst ), latitude and longitude ( lat , lon ), and a whole bunch of other values you can look up if you wish. { \"_type\": \"location\", \"SSID\": \"mywifi\", \"alt\": 154, \"batt\": 53, \"conn\": \"w\", \"created_at\": 1706858149, \"lat\": 48.856826, \"lon\": 2.292713, \"tid\": \"j1\", \"tst\": 1706858149, \"vel\": 0 } still on the console, let's verify whether the Recorder has successfully saved the published location data. Note how the path name contains the user and device names used for publishing; the rest of the filename is a YYYY-MM date stamp: $ tail /var/spool/owntracks/recorder/store/rec/jane/nokia/2024-02.rec 2024-02-02T07:15:49Z * {\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706858149,\"vel\":0} let's use a Web browser to access our site, where you'll be prompted for username and password as already mentioned: live map. The icon on the right of the info panel is what we call a CARD Frontend (below) is our primary data viewer which shows current locations (click on a bubble to find more details about a position) in Frontend users can select users and devices to see, tracks to view, etc. back on the command line of your VPS, you can explore the data submitted by your devices using the ocat utility, say: $ ocat --user jane --device nokia | jq { \"count\": 1, \"locations\": [ { \"_type\": \"location\", \"SSID\": \"mywifi\", \"alt\": 154, \"batt\": 53, \"conn\": \"w\", \"lat\": 48.856826, \"lon\": 2.292713, \"tid\": \"j1\", \"tst\": 1706858149, \"vel\": 0, \"ghash\": \"u09tunj\", \"cc\": \"FR\", \"addr\": \"11 Av de Suffren, 75007 Paris, France\", \"locality\": \"Paris\", \"tzname\": \"Europe/Paris\", \"isorcv\": \"2024-02-02T07:15:49Z\", \"isotst\": \"2024-02-02T07:15:49Z\", \"isolocal\": \"2024-02-02T08:15:49+0100\" \"disptst\": \"2024-02-02 07:15:49\" } ] } Notice how the data has been enriched by the name of the time zone ( tzname ) at the location and the local time there ( isolocal ). In addition, OwnTracks has stored the address ( addr ) of the location, the locality or city if know, and the country code ( cc ) of the published location. This data is available because we've signed up for an account and configured our system to use OpenCage . If you're curious about the geohash ( ghash ), it's a convenient way of expressing a location using a short string . the data you obtain locally from our Recorder is also available via its API $ curl -u jane -sSf 'https://owntracks.example/owntracks/api/0/locations' \\ -d user=jane -d device=nokia Enter host password for user 'jane': {\"count\":1,\"data\":[{\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706858149,\"vel\":0,\"ghash\":\"u09tunj\",\"cc\":\"FR\",\"addr\":\"11 Av de Suffren, 75007 Paris, France\",\"locality\":\"Paris\",\"isorcv\":\"2024-02-02T07:15:49Z\",\"isotst\":\"2024-02-02T07:15:49Z\",\"disptst\":\"2024-02-02 07:15:49\"}],\"status\":200} Debugging # There's quite a bit going on in the background, so we want to give you some tips on how to go about debugging or finding out what's actually going on. Verify the required services are running: $ systemctl status ot-recorder $ systemctl status mosquitto $ systemctl status nginx The MQTT broker logs information on incoming requests: $ tail -f /var/log/mosquitto/mosquitto.log You'll likely also want to see the payloads the MQTT broker is getting; do so by subscribing to all topics: $ mosquitto_sub -v -t '#' The OwnTracks Recorder prints diagnostics to its console, but that console is typically not visible as it's a background service. Use journalctl or syslog on Ubuntu $ journalctl -u ot-recorder -f $ tail -f /var/log/syslog | grep ot-recorder When jane has successfully published a location from her device (here: nokia ), verify it's actually arrived at your recorder: $ tail /var/spool/owntracks/recorder/store/jane/nokia/YYYY-MM.rec If you need more help, we'll gladly help you if we can. Even if all you've found is a glitch in our documentation, we consider that a bug so please report it . You might want to keep a copy of the file sys.info handy which should have been created by bootstrapping process in the directory from which you launched it: $ cat sys.info Last bootstrap: 2024-02-08T13:18:43Z Ansible version: 2.14.3 OS distro: Debian / 12 4 OS distribution: bookworm Where to go from here # There's a lot you can do with OwnTracks and its backend, so you might want to read up on some of the features: Learn about geofences or waypoints and Points of Interest Explore Friends and learn how to configure Cards On iOS you can configure Tours you share with other people, and even utilize its pedometer data Compare our apps on Android and iOS MQTT broker bridging is useful for connecting two backends together, yours and a friend's, say. Learn what you can do with OwnTracks data with some programming and with Lua hooks . See which other settings you can use in configuration.yaml . Learn about extra features of quicksetup .","title":"Quicksetup"},{"location":"guide/quicksetup/#get-started-quickly","text":"Using OwnTracks means having to set up and configure your own server, which can be non-trivial. For this reason we have created what we call quicksetup , a set of tools which will hopefully get your OwnTracks environment set up as effortlessly as possible. To get started you'll need roughly an hour of time and a bit of love of a Linux command line. You'll also need the following: a small dedicated Linux-capable device (e.g. a Raspberry Pi or equivalent) or a dedicated Linux VPS (Virtual Private Server), either at your home or from one of the many VPS providers. some offerings are free of charge, though you'll need patience to wade through their lingo. (Oracle cloud, Good Cloud, and possibly a few others have a free tier.) we've had very good experience with the likes of DigitalOcean; at the time of this writing they have a 512MB Debian 12 VPS which serves us very well. But there are many others: Linode, Server4you, Hetzner, Netcup, ... look around and compare we've tested this setup on Ubuntu 22.04 ( jammy ) and on Debian/Raspbian 12 ( bookworm ); anything older or different might well cause issues, but we'll gladly help if we can a DNS domain, something like owntracks.example , which will be associated with your VPS. Some VPS providers offer one in a package with the VPS. Be that as it may, the technical jargon is you let that DNS domain and associate the IPv4 and/or IPv6 address of your VPS with owntracks.example . if your Linux machine is at home, say, you'll need to open a few TCP ports in your router: port 80 for Let's Encrypt enrollment and renewals only port 443 (optional) if you wish to permit authenticated access to your OwnTracks Web interface from \"outside\" port 8883 the MQTT port Before continuing, make sure you can login to your VPS, either as root or as an unprivileged user, but you will need to escalate privileges using sudo . after logging in, the following program invocation should produce output similar to that shown: $ sudo id uid=0(root) gid=0(root) groups=0(root) if you are prompted for a password, it will be your user password. After entering it you ought to see the output as above. also make sure the DNS domain you chose is associated with your VPS. You can probably test this by using the ping utility from your laptop. The machine might not actually be reachable, but you should see its IP address: $ ping owntracks.example ... You should now be ready to proceed.","title":"Get started quickly"},{"location":"guide/quicksetup/#what-you-can-expect","text":"Let's briefly describe what quicksetup will actually attempt to accomplish so that you can follow along. we'll attempt to enroll your VPS with Let's Encrypt on your behalf in order to have an SSL (TLS) certificate issued with which the Web server and the MQTT broker on your VPS will be protected. This ensures that all communication via HTTP (to the Web server) and via MQTT (to the broker) will be encrypted. We also install a cron job with which the Let's Encrypt certificate will automatically be renewed when required. we install an nginx Web server so that you can login to use our Frontend and other Web-based tools. We generate random passwords with which you login, and you will later find these passwords on the system in files called /usr/local/owntracks/userdata/*.pass . we install a Mosquitto MQTT broker in order for our Android or iOS apps to be able to publish location data to your OwnTracks VPS. As mentioned earlier, communication between the apps and the broker is encrypted via SSL/TLS. We also create automatic configuration files so you can auto-configure the OwnTracks apps using our *.otrc files or a magic link on a Web page. The broker is configured to permit access only to users you specify with the same passwords we create randomly for the Web server. we install and configure our Recorder. This is a program which subscribes to MQTT (on your VPS) and receives location publishes when your OwnTracks apps change location. The data is stored and can later be viewed with Frontend. you will be able to specify any number of Friends during the configuration below. Each of these friends can use the MQTT broker, use the Web server, login with their username and different random password. So, if everything works the way we hope it will, this ought to be a plug-and-play experience. Fingers crossed, let us begin.","title":"What you can expect"},{"location":"guide/quicksetup/#launching-quicksetup","text":"You are logged into your VPS either as root or as an unprivileged user. Three steps will get the installer going: ensure you are running a supported operating system (e.g. bookworm ) by running $ hostnamectl ... Operating System: Debian GNU/Linux 12 (bookworm) ... obtain our quicksetup installer; we can't do this for you, but it's easy: you clone our repository. $ sudo apt install -y git # not required on Ubuntu $ git clone --depth=1 https://github.com/owntracks/quicksetup $ cd quicksetup you now have all the files on your system, so feel free to look around. If you just want to continue, make a copy of the configuration and edit it with an editor. The file's content ought to be self-explanatory, but do ask us if it isn't. $ cp configuration.yaml.example configuration.yaml $ nano configuration.yaml the configuration file requires the following settings: dns_domain is the DNS name of your system as reacheable from the Internet. You will set this to, say, owntracks.example . Make sure you replace this value by the correct name for your installation. email is the email address which we will use when enrolling a Let's Encrypt certificate on your behalf. We don't use this for anything else, and Let's Encrypt will send you mail only when your certificate is about to expire. we strongly recommend you sign up for the free reverse geo service at OpenCage . It's free of charge, and they provide you with an API key you add to opencage_apikey . This is used in determining address information for locations (example below), and we configure your OwnTracks Android app to use it. It's so much nicer when you can see the addresses of locations you've visited in our maps. friends is an array of users who will be supported on your system. It will typically contain just yourself, but you might wish to have family members, relatives, or friends use OwnTracks on your system. friends: - { tid: JJ, username: jane, devicename: nokia } - { tid: ip, username: jip, devicename: iPad } - { tid: j2, username: jjolie, devicename: Phone } each line describes a friend , and you should be on the first line (we'll divulge later why that is). There are three fields on each line, all three are strings which may be enclosed in quotes. The tid is displayed by default on the phone and must not be longer than two characters. The username (with which you also login) and the devicename form the topic to which your devices will publish location data. once you've edited the configuration file with the settings you wish, launch the installer which will install packages and configure services. Did you remember to open the TCP ports in your router? $ sudo ./bootstrap.sh This last step will install a program which will begin the actual installation. The program is called Ansible and it uses a file provided by quicksetup to begin configuring all the services as described above. PLAY [OwnTracks Quick Setup] ******************************************************** TASK [Gathering Facts] ************************************************************** ok: [localhost] TASK [system: template out sys.info] ************************************************ changed: [localhost] TASK [verify some requirements] ***************************************************** ok: [localhost] => { \"changed\": false, \"msg\": \"All assertions passed\" } TASK [detect: acme] ***************************************************************** ok: [localhost] TASK [system: install OwnTracks repository key] ************************************* changed: [localhost] TASK [system: install OwnTracks repository] ***************************************** changed: [localhost] TASK [system: install required packages] ... If all goes well you ought to see green and/or yellow lines only; no red diagnostics. Red means error, and the installer would halt. Some of the steps will take longer than others, for instance we install several software packages which takes a bit. Should you wish to, say, add a friend at a later stage, edit configuration.yaml , and re-run ./bootstrap.sh as you did earlier. As often as you wish.","title":"Launching quicksetup"},{"location":"guide/quicksetup/#initial-testing","text":"Assuming the installer was successful, you can verify if the services are working as we intended them to: install OwnTracks on your Android or iOS device and configure it, either by sending yourself one of the files from /usr/local/owntracks/userdata/*.otrc visiting https://owntracks.example/owntracks/ and logging with your username (from the friends list in configuration.yaml ) and the corresponding password from /usr/local/owntracks/userdata/<username>.pass . At the bottom of the page is a link you can click on from your Android/iOS device to automatically configure the app. in the app on the smartphone, click on the publish up arrow Android iOS back on your VPS, use the following pre-configured utility to subscribe to your MQTT broker; by pre-configured we mean you won't need to specify username, password, hosts, etc: $ mosquitto_sub -v -t 'owntracks/#' on the console you should see some output from mosquitto_sub which looks a bit like this: owntracks/jane/nokia {\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"created_at\":1706856299,\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706856298,\"vel\":0} the output on your system will differ. The first part before the first space, is called the topic name. This is a kind of \"address\" to which your app publishes data, and each user on your system has a unique topic which has three parts: the constant owntracks , followed by the username, and the device name. After the initial space comes the actual location data your phone published. Let's format that neatly: you see the data includes a time stamp ( tst ), latitude and longitude ( lat , lon ), and a whole bunch of other values you can look up if you wish. { \"_type\": \"location\", \"SSID\": \"mywifi\", \"alt\": 154, \"batt\": 53, \"conn\": \"w\", \"created_at\": 1706858149, \"lat\": 48.856826, \"lon\": 2.292713, \"tid\": \"j1\", \"tst\": 1706858149, \"vel\": 0 } still on the console, let's verify whether the Recorder has successfully saved the published location data. Note how the path name contains the user and device names used for publishing; the rest of the filename is a YYYY-MM date stamp: $ tail /var/spool/owntracks/recorder/store/rec/jane/nokia/2024-02.rec 2024-02-02T07:15:49Z * {\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706858149,\"vel\":0} let's use a Web browser to access our site, where you'll be prompted for username and password as already mentioned: live map. The icon on the right of the info panel is what we call a CARD Frontend (below) is our primary data viewer which shows current locations (click on a bubble to find more details about a position) in Frontend users can select users and devices to see, tracks to view, etc. back on the command line of your VPS, you can explore the data submitted by your devices using the ocat utility, say: $ ocat --user jane --device nokia | jq { \"count\": 1, \"locations\": [ { \"_type\": \"location\", \"SSID\": \"mywifi\", \"alt\": 154, \"batt\": 53, \"conn\": \"w\", \"lat\": 48.856826, \"lon\": 2.292713, \"tid\": \"j1\", \"tst\": 1706858149, \"vel\": 0, \"ghash\": \"u09tunj\", \"cc\": \"FR\", \"addr\": \"11 Av de Suffren, 75007 Paris, France\", \"locality\": \"Paris\", \"tzname\": \"Europe/Paris\", \"isorcv\": \"2024-02-02T07:15:49Z\", \"isotst\": \"2024-02-02T07:15:49Z\", \"isolocal\": \"2024-02-02T08:15:49+0100\" \"disptst\": \"2024-02-02 07:15:49\" } ] } Notice how the data has been enriched by the name of the time zone ( tzname ) at the location and the local time there ( isolocal ). In addition, OwnTracks has stored the address ( addr ) of the location, the locality or city if know, and the country code ( cc ) of the published location. This data is available because we've signed up for an account and configured our system to use OpenCage . If you're curious about the geohash ( ghash ), it's a convenient way of expressing a location using a short string . the data you obtain locally from our Recorder is also available via its API $ curl -u jane -sSf 'https://owntracks.example/owntracks/api/0/locations' \\ -d user=jane -d device=nokia Enter host password for user 'jane': {\"count\":1,\"data\":[{\"_type\":\"location\",\"SSID\":\"mywifi\",\"alt\":154,\"batt\":53,\"conn\":\"w\",\"lat\":48.856826,\"lon\":2.292713,\"tid\":\"j1\",\"tst\":1706858149,\"vel\":0,\"ghash\":\"u09tunj\",\"cc\":\"FR\",\"addr\":\"11 Av de Suffren, 75007 Paris, France\",\"locality\":\"Paris\",\"isorcv\":\"2024-02-02T07:15:49Z\",\"isotst\":\"2024-02-02T07:15:49Z\",\"disptst\":\"2024-02-02 07:15:49\"}],\"status\":200}","title":"Initial testing"},{"location":"guide/quicksetup/#debugging","text":"There's quite a bit going on in the background, so we want to give you some tips on how to go about debugging or finding out what's actually going on. Verify the required services are running: $ systemctl status ot-recorder $ systemctl status mosquitto $ systemctl status nginx The MQTT broker logs information on incoming requests: $ tail -f /var/log/mosquitto/mosquitto.log You'll likely also want to see the payloads the MQTT broker is getting; do so by subscribing to all topics: $ mosquitto_sub -v -t '#' The OwnTracks Recorder prints diagnostics to its console, but that console is typically not visible as it's a background service. Use journalctl or syslog on Ubuntu $ journalctl -u ot-recorder -f $ tail -f /var/log/syslog | grep ot-recorder When jane has successfully published a location from her device (here: nokia ), verify it's actually arrived at your recorder: $ tail /var/spool/owntracks/recorder/store/jane/nokia/YYYY-MM.rec If you need more help, we'll gladly help you if we can. Even if all you've found is a glitch in our documentation, we consider that a bug so please report it . You might want to keep a copy of the file sys.info handy which should have been created by bootstrapping process in the directory from which you launched it: $ cat sys.info Last bootstrap: 2024-02-08T13:18:43Z Ansible version: 2.14.3 OS distro: Debian / 12 4 OS distribution: bookworm","title":"Debugging"},{"location":"guide/quicksetup/#where-to-go-from-here","text":"There's a lot you can do with OwnTracks and its backend, so you might want to read up on some of the features: Learn about geofences or waypoints and Points of Interest Explore Friends and learn how to configure Cards On iOS you can configure Tours you share with other people, and even utilize its pedometer data Compare our apps on Android and iOS MQTT broker bridging is useful for connecting two backends together, yours and a friend's, say. Learn what you can do with OwnTracks data with some programming and with Lua hooks . See which other settings you can use in configuration.yaml . Learn about extra features of quicksetup .","title":"Where to go from here"},{"location":"guide/scenarios/","text":"Scenarios # There are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the technical terminology handy. There is a bit of stuff you have to learn about in order to use OwnTracks: MQTT brokers , topics , but the upside is that you get to use many of the neat features MQTT mode or HTTP mode come with. For example, you can set up friends . HTTP mode # If you don't want to go to the trouble of hosting your own MQTT setup, you can use HTTP mode to publish location data to a HTTP server of your chosing , and you can also use our Recorder for doing so. MQTT mode # In MQTT mode you set up and configure your MQTT broker , you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up. We've said it before: using quicksetup is likely the easiest way to accomplish this. What you basically have to do is to set up an MQTT broker Optionally use existing clients to consume OwnTracks data Possibly dig in and write your own client and do really cool stuff! We urge you to resist the temptation of using MQTT mode with one of the many public brokers hosted by different organizations. While it is an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy. You will now want to configure a client with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not write your own client ? MQTT vs. HTTP # Which should it be? We invented OwnTracks backed by MQTT so we have preference for that, and using MQTT with, say, our Recorder is easier than with HTTP. implementing support for Friends is easier with MQTT as the apps do this themselves. In HTTP mode, the backend (Recorder) needs to know about Friends and send the information back to the apps. The software has support for this, but configuration is tedious. MQTT connections are more lightweight than HTTP, or rather the overhead is lower. for both MQTT and HTTP, connections are re-established when required. on iOS # In the iOS client there is no functional difference between MQTT and HTTP. The main difference is the backend. MQTT brokers queue messages from devices to other devices ( transition events especially). In iOS, the track of friends is recorded, which obviously only makes sense if locations sent by other devices are queued by the backend. HTTP works with friends only if the backend takes responsibility to retrieve friend's positions when a new location arrives. (Our recorder does, Home Assistant seems to do it partially, and what other systems do we likely don't know.) Re-transmission of off-line locations from an MQTT client is much more efficient and is faster than with HTTP. In iOS MQTT connections are deliberately shut down when the app goes into background. On the other hand there is no permanent HTTP connection, so HTTP connections are established when a new location/event is POSTed. Now it's time to discuss topics .","title":"Scenarios"},{"location":"guide/scenarios/#scenarios","text":"There are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the technical terminology handy. There is a bit of stuff you have to learn about in order to use OwnTracks: MQTT brokers , topics , but the upside is that you get to use many of the neat features MQTT mode or HTTP mode come with. For example, you can set up friends .","title":"Scenarios"},{"location":"guide/scenarios/#http-mode","text":"If you don't want to go to the trouble of hosting your own MQTT setup, you can use HTTP mode to publish location data to a HTTP server of your chosing , and you can also use our Recorder for doing so.","title":"HTTP mode"},{"location":"guide/scenarios/#mqtt-mode","text":"In MQTT mode you set up and configure your MQTT broker , you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up. We've said it before: using quicksetup is likely the easiest way to accomplish this. What you basically have to do is to set up an MQTT broker Optionally use existing clients to consume OwnTracks data Possibly dig in and write your own client and do really cool stuff! We urge you to resist the temptation of using MQTT mode with one of the many public brokers hosted by different organizations. While it is an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy. You will now want to configure a client with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not write your own client ?","title":"MQTT mode"},{"location":"guide/scenarios/#mqtt-vs-http","text":"Which should it be? We invented OwnTracks backed by MQTT so we have preference for that, and using MQTT with, say, our Recorder is easier than with HTTP. implementing support for Friends is easier with MQTT as the apps do this themselves. In HTTP mode, the backend (Recorder) needs to know about Friends and send the information back to the apps. The software has support for this, but configuration is tedious. MQTT connections are more lightweight than HTTP, or rather the overhead is lower. for both MQTT and HTTP, connections are re-established when required.","title":"MQTT vs. HTTP"},{"location":"guide/scenarios/#on-ios","text":"In the iOS client there is no functional difference between MQTT and HTTP. The main difference is the backend. MQTT brokers queue messages from devices to other devices ( transition events especially). In iOS, the track of friends is recorded, which obviously only makes sense if locations sent by other devices are queued by the backend. HTTP works with friends only if the backend takes responsibility to retrieve friend's positions when a new location arrives. (Our recorder does, Home Assistant seems to do it partially, and what other systems do we likely don't know.) Re-transmission of off-line locations from an MQTT client is much more efficient and is faster than with HTTP. In iOS MQTT connections are deliberately shut down when the app goes into background. On the other hand there is no permanent HTTP connection, so HTTP connections are established when a new location/event is POSTed. Now it's time to discuss topics .","title":"on iOS"},{"location":"guide/topics/","text":"Topics # If you use HTTP mode skip this section. You now know that MQTT is a messaging protocol, and that it uses topic names to label messages. topic names can be structured into multiple topic levels by separating them with a forward slash ( / ). topic levels are UTF-8 text strings, and almost any character is valid except / , * , and + . The last two are used to address sets of topic names. The principles during the design of the OwnTracks topic-naming scheme were human readability traffic minimization granular access control topic name Root # Typically an MQTT broker hosts multiple applications. To create a separate name space for OwnTracks we use a topic name root as the beginning of a topic name. Per default this is owntracks/ , but you may choose any other root (e.g. peters/locations/ ) or, if you prefer, the empty string. In order to change the default behaviour of owntracks/ create a personalized configuration from scratch or, export your current configuration, edit that and re-import to your device. On Android you trigger the import function by opening the .otrc file in a file manager; on iOS by, say, opening the file in Mail, Dropbox or similar app. The settings which have to be changed are pubTopicBase subTopic Device name # Locations are captured in OwnTracks by devices (e.g. your Smartphone). The device name forms the second component of the topic name. In order to avoid clashes in naming and to simplify subscription and authorization we decided to use two topic levels The user name or identifier (e.g. peter ) The device name (e.g. iPhone ) A typical topic name for a device would therefore be peter/iPhone . Other device naming schemes are possible and transparent to OwnTracks (e.g. using just one level peters-iPhone or multiple levels aFamily/father/iPhone ), but under any one OwnTracks name root the number of levels used for device names have to be the same. We reccomend you keep the device name generic: something like myphone might be preferable to siemens-x67 so that you don't feel the need to change the device name (and hence the topic) if you move to a different device and vendor. Base topic name # Combining the topic name root and the device name result in what we call base topic name for each device (e.g. owntracks/peter/iPhone ). The devices label their location messages with the base topic name when publishing to the MQTT broker. Subscribing to location Messages # Given the structure explained above, the topic filter you can use to subscribe to the location messages of all devices is owntracks/+/+ (the topic name root plus a so-called wild card ( + ) for each level of the device name. Additional topic names # For additional communication from and to devices, OwnTracks uses topic names relative to the base topic name. Devices listen to the relative topic name cmd for commands you can publish to OwnTracks devices (i.e. owntracks/peter/iPhone/cmd ). For example, if authorized, you could request a location update from a friend's device by publishing an appropriate payload to said topic. The output of specific OwnTracks commands is published by the device to the relative topic names step , dump , etc. In addition, devices subscribe to the relative topic name info for information about other devices. Messages published with the relative topic name info (e.g. owntracks/peter/iPhone/info ) contain a card payload -- the name and avatar of a user with which authorized users can identify, say, Peter within their OwnTracks app. Devices publish their waypoints to the relative topic name waypoint and the corresponding events the transition into or out of a waypoint triggers, to the relative topic name event . Summary # A device (named peter/iPhone in this example) is connected to an MQTT Broker with the OwnTracks name Root owntracks . It publishes location messages labeled with the topic name owntracks/peter/iPhone . The same device publishes waypoints labeled as owntracks/peter/iPhone/waypoint and publishes to owntracks/peter/iPhone/event when entering or leaving a waypoint (i.e. a monitored region). The same device subscribes to owntracks/+/+ to receive location messages of all other devices it is authorized for which are connected to the same MQTT broker. In addition, the device may listen to owntracks/+/+/event if the user of the devices wants to be informed about other users entering or leaving monitored regions. Subscribing to owntracks/+/+/info gives the device access to additional information about the other devices. If a device's owner allows other users to ad-hoc request messages from his device, the device will subscribe to owntracks/peter/iPhone/cmd as well, and it will listen for OwnTracks commands; responses to these commands will be published and labeled owntracks/peter/iPhone/dump , owntracks/peter/iPhone/step , etc. A full set of supported topic names and expected payloads is documented in our JSON API . Terms used # topic name OwnTracks topic name root OwnTracks device name OwnTracks base topic name relative topic names OwnTracks device OwnTracks user OwnTracks command","title":"Topics"},{"location":"guide/topics/#topics","text":"If you use HTTP mode skip this section. You now know that MQTT is a messaging protocol, and that it uses topic names to label messages. topic names can be structured into multiple topic levels by separating them with a forward slash ( / ). topic levels are UTF-8 text strings, and almost any character is valid except / , * , and + . The last two are used to address sets of topic names. The principles during the design of the OwnTracks topic-naming scheme were human readability traffic minimization granular access control","title":"Topics"},{"location":"guide/topics/#topic-name-root","text":"Typically an MQTT broker hosts multiple applications. To create a separate name space for OwnTracks we use a topic name root as the beginning of a topic name. Per default this is owntracks/ , but you may choose any other root (e.g. peters/locations/ ) or, if you prefer, the empty string. In order to change the default behaviour of owntracks/ create a personalized configuration from scratch or, export your current configuration, edit that and re-import to your device. On Android you trigger the import function by opening the .otrc file in a file manager; on iOS by, say, opening the file in Mail, Dropbox or similar app. The settings which have to be changed are pubTopicBase subTopic","title":"topic name Root"},{"location":"guide/topics/#device-name","text":"Locations are captured in OwnTracks by devices (e.g. your Smartphone). The device name forms the second component of the topic name. In order to avoid clashes in naming and to simplify subscription and authorization we decided to use two topic levels The user name or identifier (e.g. peter ) The device name (e.g. iPhone ) A typical topic name for a device would therefore be peter/iPhone . Other device naming schemes are possible and transparent to OwnTracks (e.g. using just one level peters-iPhone or multiple levels aFamily/father/iPhone ), but under any one OwnTracks name root the number of levels used for device names have to be the same. We reccomend you keep the device name generic: something like myphone might be preferable to siemens-x67 so that you don't feel the need to change the device name (and hence the topic) if you move to a different device and vendor.","title":"Device name"},{"location":"guide/topics/#base-topic-name","text":"Combining the topic name root and the device name result in what we call base topic name for each device (e.g. owntracks/peter/iPhone ). The devices label their location messages with the base topic name when publishing to the MQTT broker.","title":"Base topic name"},{"location":"guide/topics/#subscribing-to-location-messages","text":"Given the structure explained above, the topic filter you can use to subscribe to the location messages of all devices is owntracks/+/+ (the topic name root plus a so-called wild card ( + ) for each level of the device name.","title":"Subscribing to location Messages"},{"location":"guide/topics/#additional-topic-names","text":"For additional communication from and to devices, OwnTracks uses topic names relative to the base topic name. Devices listen to the relative topic name cmd for commands you can publish to OwnTracks devices (i.e. owntracks/peter/iPhone/cmd ). For example, if authorized, you could request a location update from a friend's device by publishing an appropriate payload to said topic. The output of specific OwnTracks commands is published by the device to the relative topic names step , dump , etc. In addition, devices subscribe to the relative topic name info for information about other devices. Messages published with the relative topic name info (e.g. owntracks/peter/iPhone/info ) contain a card payload -- the name and avatar of a user with which authorized users can identify, say, Peter within their OwnTracks app. Devices publish their waypoints to the relative topic name waypoint and the corresponding events the transition into or out of a waypoint triggers, to the relative topic name event .","title":"Additional topic names"},{"location":"guide/topics/#summary","text":"A device (named peter/iPhone in this example) is connected to an MQTT Broker with the OwnTracks name Root owntracks . It publishes location messages labeled with the topic name owntracks/peter/iPhone . The same device publishes waypoints labeled as owntracks/peter/iPhone/waypoint and publishes to owntracks/peter/iPhone/event when entering or leaving a waypoint (i.e. a monitored region). The same device subscribes to owntracks/+/+ to receive location messages of all other devices it is authorized for which are connected to the same MQTT broker. In addition, the device may listen to owntracks/+/+/event if the user of the devices wants to be informed about other users entering or leaving monitored regions. Subscribing to owntracks/+/+/info gives the device access to additional information about the other devices. If a device's owner allows other users to ad-hoc request messages from his device, the device will subscribe to owntracks/peter/iPhone/cmd as well, and it will listen for OwnTracks commands; responses to these commands will be published and labeled owntracks/peter/iPhone/dump , owntracks/peter/iPhone/step , etc. A full set of supported topic names and expected payloads is documented in our JSON API .","title":"Summary"},{"location":"guide/topics/#terms-used","text":"topic name OwnTracks topic name root OwnTracks device name OwnTracks base topic name relative topic names OwnTracks device OwnTracks user OwnTracks command","title":"Terms used"},{"location":"guide/waypoints/","text":"Waypoints # If you've configured a geo-fence, a location message will contain the elements: rad ius (if its value is greater than 0): unit: meters desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. If you set up a waypoint, the app publishes that waypoint (without the retain flag, irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . When you set up a waypoint (with a desc ription and a rad ius), this waypoint is published to the broker with the current time stamp. If you update the waypoint definition on the device at a later stage, the waypoint is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius. To be precise, the tst timestamp is used as an identifier of the waypoint even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting waypoints by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.","title":"Waypoints"},{"location":"guide/waypoints/#waypoints","text":"If you've configured a geo-fence, a location message will contain the elements: rad ius (if its value is greater than 0): unit: meters desc ription with the name you set for the waypoint event with a value of \"enter\" or \"leave\" , depending on whether the device is entering or leaving a configured region, respectively. If you set up a waypoint, the app publishes that waypoint (without the retain flag, irrespective of your general preference) to the base topic with /waypoint tacked onto the topic (e.g. owntracks/<user>/<device>/waypoint ) with the payload for _type=waypoint as specified in the JSON page . When you set up a waypoint (with a desc ription and a rad ius), this waypoint is published to the broker with the current time stamp. If you update the waypoint definition on the device at a later stage, the waypoint is re-published, with the original timestamp, but with possibly new desc ription and/or rad ius. To be precise, the tst timestamp is used as an identifier of the waypoint even if it is later modified on the device. Subscribers to the broker (our apps and any other program) can avoid getting waypoints by subscribing to, say, owntracks/+/+ ; also broker ACLs can prohibit access to owntracks/+/+/waypoint for particular users if so desired. Conversely, all messages published by the apps ( location and waypoint ) are available with a subscription to owntracks/# . The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.","title":"Waypoints"},{"location":"guide/whathow/","text":"What OwnTracks does # The OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other details we'll discuss in a moment, but these screenshots might whet your appetite). | | | | We'd like you to read this bit again: waits for the smart phone to tell it that the device has moved . It is very important to understand that OwnTracks has to wait for the device's operating system to inform it of movement; only then can OwnTracks react and do something. To make matters even more complicated 1 , OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing. That's basically all OwnTracks does. More # That last sentence isn't true. Strike it. OwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and that of your friends on a map. Ah: better. It can also detect when you enter or leave a particular region for which you set a so-called geofence . People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.) OwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.) And finally, though for us this is very important, OwnTracks does all this securely. How OwnTracks works # The OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's moved a significant distance 2 , it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \" hey, I'm here \", whereby \" here \" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server (see: scenarios . This last server is called a broker and the contact is made with an open, lightweight, standardized protocol called MQTT . (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called publish in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is something you provide. Instead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server. Above: the general architecture of OwnTracks The broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend, to a program which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later. The important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's yours . Before installing one of our apps on your smartphone, you need some place the app will actually connect to. We'll try to get you started quickly . and believe us, they are complicated \u21a9 This is a relative amount, but you can tune it a bit. \u21a9","title":"What it does"},{"location":"guide/whathow/#what-owntracks-does","text":"The OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other details we'll discuss in a moment, but these screenshots might whet your appetite). | | | | We'd like you to read this bit again: waits for the smart phone to tell it that the device has moved . It is very important to understand that OwnTracks has to wait for the device's operating system to inform it of movement; only then can OwnTracks react and do something. To make matters even more complicated 1 , OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing. That's basically all OwnTracks does.","title":"What OwnTracks does"},{"location":"guide/whathow/#more","text":"That last sentence isn't true. Strike it. OwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and that of your friends on a map. Ah: better. It can also detect when you enter or leave a particular region for which you set a so-called geofence . People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.) OwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.) And finally, though for us this is very important, OwnTracks does all this securely.","title":"More"},{"location":"guide/whathow/#how-owntracks-works","text":"The OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's moved a significant distance 2 , it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \" hey, I'm here \", whereby \" here \" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server (see: scenarios . This last server is called a broker and the contact is made with an open, lightweight, standardized protocol called MQTT . (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called publish in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is something you provide. Instead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server. Above: the general architecture of OwnTracks The broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend, to a program which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later. The important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's yours . Before installing one of our apps on your smartphone, you need some place the app will actually connect to. We'll try to get you started quickly . and believe us, they are complicated \u21a9 This is a relative amount, but you can tune it a bit. \u21a9","title":"How OwnTracks works"},{"location":"guide/app/android/","text":"Android app setup # Welcome screens are shown when you first launch the app, and the app requests permission to determine your location (which is pretty obvious if you think about it, as the app is supposed to do just that). After the preliminaries are complete, you will configure the app to connect to your broker. (Use the inline configuration we show you below when using Quicksetup .) Correctly configured, you should then see a map. Clicking the \"play\" button on the top will bring up the monitoring mode panel which defaults to Significant Changes . Click on the hamburger to access the menu Using inline configuration with Quicksetup, access your OwnTracks site, the one you set up with Quicksetup, and login with your username and password . The, click on the configure it with a click link which will download a ready-made configuration and launch it in OwnTracks. Clicking the checkmark on the top right will cause OwnTracks for Android to configure itself accordingly. If several Friends are using your server, you might see them on the map. Sliding the bottom sheet up will reveal details of their location. Here are some specifics on our Android app","title":"Android"},{"location":"guide/app/android/#android-app-setup","text":"Welcome screens are shown when you first launch the app, and the app requests permission to determine your location (which is pretty obvious if you think about it, as the app is supposed to do just that). After the preliminaries are complete, you will configure the app to connect to your broker. (Use the inline configuration we show you below when using Quicksetup .) Correctly configured, you should then see a map. Clicking the \"play\" button on the top will bring up the monitoring mode panel which defaults to Significant Changes . Click on the hamburger to access the menu Using inline configuration with Quicksetup, access your OwnTracks site, the one you set up with Quicksetup, and login with your username and password . The, click on the configure it with a click link which will download a ready-made configuration and launch it in OwnTracks. Clicking the checkmark on the top right will cause OwnTracks for Android to configure itself accordingly. If several Friends are using your server, you might see them on the map. Sliding the bottom sheet up will reveal details of their location. Here are some specifics on our Android app","title":"Android app setup"},{"location":"other/opencage/","text":"OpenCage # We've had excellent experience using the OpenCage Geocoding API as reverse geo-coding provider: their pricing is attractive and they currently offer a free tier that allows up to 2,500 requests per day, which should be more than sufficient for our purposes. After signing up and obtaining your API key, configure the OpenCage API in Recorder by: setting OTR_GEOKEY=\"opencage:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" in the defaults file or by exporting it into the environment invoking Recorder with the --geokey \"opencage:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" option If you configured your OpenCage geocoding API key in quicksetup , the Recorder is automatically configured during bootstrapping. Be aware that the Recorder queries the service with no_record=1&limit=1 . OpenCage documents the first as meaning it will not log the request, and that protects your privacy ( see details ). (Without the substring opencage: the Recorder falls back to using Google in order to maintain backwards-compatibility.)","title":"Opencage"},{"location":"other/opencage/#opencage","text":"We've had excellent experience using the OpenCage Geocoding API as reverse geo-coding provider: their pricing is attractive and they currently offer a free tier that allows up to 2,500 requests per day, which should be more than sufficient for our purposes. After signing up and obtaining your API key, configure the OpenCage API in Recorder by: setting OTR_GEOKEY=\"opencage:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" in the defaults file or by exporting it into the environment invoking Recorder with the --geokey \"opencage:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" option If you configured your OpenCage geocoding API key in quicksetup , the Recorder is automatically configured during bootstrapping. Be aware that the Recorder queries the service with no_record=1&limit=1 . OpenCage documents the first as meaning it will not log the request, and that protects your privacy ( see details ). (Without the substring opencage: the Recorder falls back to using Google in order to maintain backwards-compatibility.)","title":"OpenCage"},{"location":"tech/http/","text":"HTTP # An optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all JSON payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads. The URL you enter in the setting for HTTP mode has the following syntax: http[s]://[user[:password]@]host[:port]/path Authentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS ( https:// scheme). The encryption feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself. The Recorder supports HTTP mode out of the box at the /pub end point, as long as it is built with HTTP support and a --http-port is configured. When using Recorder in this mode, set the URL to: http[s]://recorder_host[:port]/pub The username and password for HTTP Basic authentication can be configured in application settings, under Identification . Device name and tracker name can also be configured there. Username and device name are required when using the Recorder. Parameters for username and devicename can also be included in the URL ( ?u=user&d=device ), or alternatively using the X-Limit-U and X-Limit-D headers respectively. You can also force username using a proxy as described in the Recorder's documentation. All publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same JSON payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.) If the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code ( 2xx ) is returned the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time. If the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array [] . It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid _type as described in JSON . Support for the following _type is implemented: _type iOS Android Usage location Y Y Can return friend location objects. cmd Y Y with action set to dump , reportLocation , reportSteps , action , and setWaypoints card Y Y Can return card objects for self and friends transition Y Y Obtain friends' transition events. Distinguishing payloads # When a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from: On iOS, a new topic key is added to the payload if the payload is unencrypted. If the payload is encrypted, the topic key is only available in the decrypted payload. Both the Android and iOS apps (iOS after #560 is implemented) include headers to identify the user ( X-Limit-U ) and the device ( X-Limit-D ) if the user has entered this information in the \"Identification\" section of the connection settings. Content-Type: application/json X-Limit-U: jjolie X-Limit-D: myphone PHP example # Using a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table: mysql> select * from locations; +---------------------+------+-----------+----------+ | dt | tid | lat | lon | +---------------------+------+-----------+----------+ | 2016-02-20 09:16:05 | JJ | 48.858330 | 2.295130 | | 2016-02-20 09:19:49 | JJ | 48.860430 | 2.294010 | +---------------------+------+-----------+----------+ For the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a tst timestamp when the event actually occurred. <?php # Obtain the JSON payload from an OwnTracks app POSTed via HTTP # and insert into database table. header(\"Content-type: application/json\"); $payload = file_get_contents(\"php://input\"); $data = @json_decode($payload, true); if ($data['_type'] == 'location') { # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6)); $mysqli = new mysqli(\"127.0.0.1\", \"user\", \"password\", \"database\"); $tst = $data['tst']; $lat = $data['lat']; $lon = $data['lon']; $tid = $data['tid']; # Convert timestamp to a format suitable for mysql $dt = date('Y-m-d H:i:s', $tst); $sql = \"INSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?)\"; $stmt = $mysqli->prepare($sql); # bind parameters (s = string, i = integer, d = double, b = blob) $stmt->bind_param('ssdd', $dt, $tid, $lat, $lon); $stmt->execute(); $stmt->close(); } $response = array(); # optionally add objects to return to the app (e.g. # friends or cards) print json_encode($response); ?> Assuming the Web server hosting this example is called example.com , and assuming the above script is in Jane's home directory's public_html saved as loc.php , the URL you configure in the OwnTracks app would be http://example.com/~jane/loc.php . We urge you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of https://user:password@example.com/~jane/loc.php . There's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you study the API documentation . Testing your HTTP endpoint # An simple example for testing a HTTP endpoint you set up: #!/bin/sh user=jane device=phone payload=$(jo _type=location \\ t=u \\ batt=11 \\ lat=48.856826 \\ lon=2.292713 \\ tid=JJ \\ tst=$(date +%s) \\ topic=\"owntracks/$user/$device\") curl --data \"${payload}\" http://127.0.0.1:8085/pub?u=${user}&d=${device} see also: Traccar","title":"HTTP"},{"location":"tech/http/#http","text":"An optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all JSON payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads. The URL you enter in the setting for HTTP mode has the following syntax: http[s]://[user[:password]@]host[:port]/path Authentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS ( https:// scheme). The encryption feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself. The Recorder supports HTTP mode out of the box at the /pub end point, as long as it is built with HTTP support and a --http-port is configured. When using Recorder in this mode, set the URL to: http[s]://recorder_host[:port]/pub The username and password for HTTP Basic authentication can be configured in application settings, under Identification . Device name and tracker name can also be configured there. Username and device name are required when using the Recorder. Parameters for username and devicename can also be included in the URL ( ?u=user&d=device ), or alternatively using the X-Limit-U and X-Limit-D headers respectively. You can also force username using a proxy as described in the Recorder's documentation. All publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same JSON payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.) If the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code ( 2xx ) is returned the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time. If the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array [] . It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid _type as described in JSON . Support for the following _type is implemented: _type iOS Android Usage location Y Y Can return friend location objects. cmd Y Y with action set to dump , reportLocation , reportSteps , action , and setWaypoints card Y Y Can return card objects for self and friends transition Y Y Obtain friends' transition events.","title":"HTTP"},{"location":"tech/http/#distinguishing-payloads","text":"When a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from: On iOS, a new topic key is added to the payload if the payload is unencrypted. If the payload is encrypted, the topic key is only available in the decrypted payload. Both the Android and iOS apps (iOS after #560 is implemented) include headers to identify the user ( X-Limit-U ) and the device ( X-Limit-D ) if the user has entered this information in the \"Identification\" section of the connection settings. Content-Type: application/json X-Limit-U: jjolie X-Limit-D: myphone","title":"Distinguishing payloads"},{"location":"tech/http/#php-example","text":"Using a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table: mysql> select * from locations; +---------------------+------+-----------+----------+ | dt | tid | lat | lon | +---------------------+------+-----------+----------+ | 2016-02-20 09:16:05 | JJ | 48.858330 | 2.295130 | | 2016-02-20 09:19:49 | JJ | 48.860430 | 2.294010 | +---------------------+------+-----------+----------+ For the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a tst timestamp when the event actually occurred. <?php # Obtain the JSON payload from an OwnTracks app POSTed via HTTP # and insert into database table. header(\"Content-type: application/json\"); $payload = file_get_contents(\"php://input\"); $data = @json_decode($payload, true); if ($data['_type'] == 'location') { # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6)); $mysqli = new mysqli(\"127.0.0.1\", \"user\", \"password\", \"database\"); $tst = $data['tst']; $lat = $data['lat']; $lon = $data['lon']; $tid = $data['tid']; # Convert timestamp to a format suitable for mysql $dt = date('Y-m-d H:i:s', $tst); $sql = \"INSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?)\"; $stmt = $mysqli->prepare($sql); # bind parameters (s = string, i = integer, d = double, b = blob) $stmt->bind_param('ssdd', $dt, $tid, $lat, $lon); $stmt->execute(); $stmt->close(); } $response = array(); # optionally add objects to return to the app (e.g. # friends or cards) print json_encode($response); ?> Assuming the Web server hosting this example is called example.com , and assuming the above script is in Jane's home directory's public_html saved as loc.php , the URL you configure in the OwnTracks app would be http://example.com/~jane/loc.php . We urge you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of https://user:password@example.com/~jane/loc.php . There's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you study the API documentation .","title":"PHP example"},{"location":"tech/http/#testing-your-http-endpoint","text":"An simple example for testing a HTTP endpoint you set up: #!/bin/sh user=jane device=phone payload=$(jo _type=location \\ t=u \\ batt=11 \\ lat=48.856826 \\ lon=2.292713 \\ tid=JJ \\ tst=$(date +%s) \\ topic=\"owntracks/$user/$device\") curl --data \"${payload}\" http://127.0.0.1:8085/pub?u=${user}&d=${device} see also: Traccar","title":"Testing your HTTP endpoint"},{"location":"tech/json/","text":"Types # OwnTracks uses JSON format for its message payloads. The different payload types are identified by a mandatory _type element. Depending on the app platform, different payload types are supported. _type iOS Android beacon Y N card Y Y cmd Y Y configuration Y Y encrypted Y Y location Y Y lwt Y Y request Y N steps Y N transition Y Y waypoint Y Y waypoints Y Y Topics # In MQTT mode the apps publish to: owntracks/user/device with _type=location for location updates, and with _type=lwt owntracks/user/device/cmd with _type=cmd for remote commands owntracks/user/device/event with _type=transition for enter/leave events owntracks/user/device/step to report step counter owntracks/user/device/beacon for beacon ranging owntracks/user/device/dump for config dumps owntracks/user/device/waypoint when a geofence is created on the device owntracks/user/device/waypoints (plural) when exporting a list of configured waypoints from device to backend In MQTT mode apps subscribe to: owntracks/user/device/cmd if remote commands are enabled owntracks/+/+ for seeing other user's locations, depending on broker ACL owntracks/+/+/event for transition messages ( enter / leave ) owntracks/+/+/info for obtaining cards . In HTTP mode the apps POST their data to a single endpoint you configure. _type=location # This location object describes the location of the device that reported it. { \"_type\" : \"location\", elements } acc Accuracy of the reported location in meters without unit (iOS,Android/integer/meters/optional) alt Altitude measured above sea level (iOS,Android/integer/meters/optional) batt Device battery level (iOS,Android/integer/percent/optional) bs Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full (iOS, Android) cog Course over ground (iOS/integer/degree/optional) lat latitude (iOS,Android/float/degree/required) lon longitude (iOS,Android/float/degree/required) rad radius around the region when entering/leaving (iOS/integer/meters/optional) t trigger for the location report (iOS,Android/string/optional) p ping issued randomly by background task (iOS,Android) c circular region enter/leave event (iOS,Android) b beacon region enter/leave event (iOS) r response to a reportLocation cmd message (iOS,Android) u manual publish requested by the user (iOS,Android) t timer based publish in move move (iOS) v updated by Settings/Privacy/Locations Services/System Services/Frequent Locations monitoring (iOS) tid Tracker ID used to display the initials of a user (iOS,Android/string/optional) required for http mode tst UNIX epoch timestamp in seconds of the location fix (iOS,Android/integer/epoch/required) vac vertical accuracy of the alt element (iOS/integer/meters/optional) vel velocity (iOS,Android/integer/kmh/optional) p barometric pressure (iOS/float/kPa/optional/extended data) poi point of interest name (iOS/string/optional) conn Internet connectivity status (route to host) when the message is created (iOS,Android/string/optional/extended data) w phone is connected to a WiFi connection (iOS,Android) o phone is offline (iOS,Android) m mobile data (iOS,Android) tag name of the tag (iOS/string/optional) topic (only in HTTP payloads) contains the original publish topic (e.g. owntracks/jane/phone ). (iOS,Android >= 2.4,string) inregions contains a list of regions the device is currently in (e.g. [\"Home\",\"Garage\"] ). Might be empty. (iOS,Android/list of strings/optional) inrids contains a list of region IDs the device is currently in (e.g. [\"6da9cf\",\"3defa7\"] ). Might be empty. (iOS,Android/list of strings/optional) SSID , if available, is the unique name of the WLAN. (iOS,string/optional) BSSID , if available, identifies the access point. (iOS,string/optional) created_at identifies the time at which the message is constructed (vs. tst which is the timestamp of the GPS fix) (iOS,Android) m identifies the monitoring mode at which the message is constructed ( significant = 1 , move = 2 ) (iOS/integer/optional) Notes # The tst in a ping is a current timestamp , so that it doesn't look like a duplicate. The tid defaults to the last two characters of the topic A missing t element also indicates an automatic location update A publish of \"_type\": \"location\" with a \"b\" trigger is sent when an iOS device enters or leaves a beacon in addition to a \"_type\": \"transition\" : if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated. The acc , alt , cog , vac , vel elements are only added if they are not zero Some Android devices always return 0 for alt or vel Elements marked with extended data are only added if extendedData=true is configured Greenwich # The OwnTracks edition of the Choral Greenwich device reports the following additional elements in a _type=location message: { \"_type\": \"location\", elements } alt Altitude measured above sea level (integer/meters/optional) batt Device battery level (integer/percent/optional) cog Course over ground (integer/degree/optional) dist Distance travelled since the last location report (integer/meters/optional) trip Distance travelled since the last reboot (integer/meters/optional) vel velocity (integer/kmh/optional) t trigger for the location report (string/optional) f First publish after reboot m Manually requested locations (e.g. by publishing to /cmd ) t Time for location published because device is moving. T Time for location published because of time passed while device is stationary ( maxInterval ) k Transitioning from move to stationary (park) v Transitioning from stationary to move (mo-v-e) l Last known position when device lost GPS fix L Last known position before gracefull shutdown Notes # The device can be configured to produce or not produce fields marked as optional Queclink # OwnTracks works with a selection of trackers by Queclink , for which the protocol conversion is done via qtripp . Queclink devices report the following additional elements in a _type=location message: { \"_type\": \"location\", elements } t trigger for the location report (string/optional) o Corner M Mileage ! Tow or fake tow or sensor without ignition a motionless (aka park) i ignition on I ignition off e external power off E external power ON 1 Devices powered up 2 Battery stop charging 3 Battery start charging 9 Battery power low h harsh behavior s speed alarm odometer total distance of the device (float/kilometers/optional) hmc total hours of operation (float/seconds/optional) ubatt voltage of the battery (float/volts/optional) uext voltage of the external power source (float/volts/optional) vin vehicle identification number (string/optional) imei identification number (string/optional) name vehicle name (string/optional) don is duration since ignition on (float/seconds/optional) doff is duration since ignition off (float/seconds/optional) aiv is analog input voltage (float/volts/optional) rpm is engine rounds per minute (float/rounds per minute/optional) fcon is fuel consumption (float/L per 100km/optional) flvl is fuel level (float/percent/optional) anum is number of analog inputs (integer/optional) adid-xx is id of analog input number xx (string/optional) adty-xx is type of analog input number xx (string/optional) adda-xx is data of analog input number xx (string/optional) temp_c-xx is temperature of analog input number xx (float/celsius/optional) can is can data (string/optional) din1 is status of digital input 1 (boolean/optional) din2 is status of digital input 2 (boolean/optional) dout1 is status of digital output 1 (boolean/optional) dout2 is status of digital output 2 (boolean/optional) ign is status of ignition (boolean/optional) motion is motion status (boolean/optional) tow is status of tow sensor (boolean/optional) fake is status of fake tow sensor (boolean/optional) sens is status of motion sensor (boolean/optional) sent is epoch when message was sent (integer/epoch/optional) mcc is mobile country code (integer/optional) mnc is mobile network code (integer/optional) lac is location area code (string/optional) cid is cell id (string/optional) nmds is non movement detection status (boolean/optional) rit queclink record id and type (integer/optional) rty queclink record type (integer/optional) rid queclink record id (integer/optional) mst queclink motion state (integer/optional) count is counter of message (string/optional) raw_line raw data (string/optional) counter number of ignored positions (integer/optional) ignored indicates counter positions have been ignored (boolean/optional) Notes # The device can be configured to produce or not produce fields marked as optional _type=lwt # A last will and testament is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this: { \"_type\":\"lwt\", elements } tst UNIX epoch timestamp at which the app first connected (iOS,Android/integer/epoch/required) _type=waypoint # Waypoints / regions denote specific geographical regions that you want to keep track of. You define a region in the OwnTracks app, and OwnTracks publishes this waypoint to the topic branch ../waypoint (singular). OwnTracks also monitors these waypoints and will publish {_type: \"transition\", ...} message when entering or leaving the region. A waypoint may also define a BLE Beacon instead of a geographical region. { \"_type\" : \"waypoint\", elements } desc Name of the waypoint that is included in the sent transition message, copied into the location message inregions array when a current position is within a region. (iOS,Android,string/required) lat Latitude (iOS,Android/float/meters/optional) lon Longitude (iOS,Android/float/meters/optional) rad Radius around the latitude and longitude coordinates (iOS,Android/integer/meters/optional) tst Timestamp of creation of region, copied into the wtst element of the transition message (iOS,Android/integer/epoch/required) uuid UUID of the BLE Beacon (iOS/string/optional) major Major number of the BLE Beacon (iOS/integer/optional) minor Minor number of the BLE Beacon_(iOS/integer/optional)_ rid region ID, created automatically, copied into the location payload inrids array (iOS/string)_ Notes # In iOS version >= 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the desc element. If lat , lon and rad elements are present, transition messages are sent when entering and leaving the geographical region If uuid , major , minor elements are present, BLE becons with that specifications are monitored Beacons and Geographical regions can be defined together Waypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage. Waypoints are sent to the broker and transition messages contain a desc and event element. _type=transition # A transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained. { \"_type\": \"transition\", elements } wtst Timestamp of waypoint creation (iOS,Android/integer/epoch/required) lat Latitude at which the event occured (iOS,Android/float/meters/optional) lon Longitue at which the event occured (iOS,Android/float/meters/optional) tst Timestamp at which the event occured (iOS,Android/integer/epoch/required) acc Accuracy of the geographical coordinates (iOS,Android/int/meters/required) tid Tracker ID of the (iOS/string/none/optional) required in http mode. event Event that triggered the transition (iOS,Android/string/required) enter The device entered the defined geographical region or BLE Beacon range (iOS) leave The device left the defined geographical region or BLE Beacon range (iOS) desc Name of the waypoint (iOS,Android/string/optional) t Trigger of the event (iOS,Android/string/optional) c Circular geographical region (iOS, Android) b BLE Beacon (iOS) l Loction update (Android) rid Region ID (iOS/Android, after January 2021) _type=configuration # The device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages. { \"_type\": \"configuration\", elements } allowRemoteLocation Respond to reportLocation cmd message (iOS/boolean) allowinvalidcerts disable TLS certificate checks insecure (iOS/boolean) auth Use username and password for endpoint authentication (iOS,Android/boolean) autostartOnBoot Autostart the app on device boot (Android/boolean) cleanSession MQTT endpoint clean session (iOS,Android/boolean) clientId client id to use for MQTT connect. Defaults to \" user deviceId \" (iOS,Android/string) clientpkcs Name of the client pkcs12 file (iOS/string) cmd Respond to cmd messages (iOS,Android/boolean) deviceId id of the device used for pubTopicBase and clientId construction. Defaults to the os name of the device (iOS,Android/string) downgrade battery level below which to downgrade monitoring from move mode (iOS/integer/percent/optional) encryptionKey the secret key used for payload encryption (_iOS , Android/string) extendedData Add extended data attributes to location messages (iOS,Android/boolean) host MQTT endpoint host (iOS,Android/string) httpHeaders extra HTTP headers:field names and field content are separated by a colon (:), multiple fields by a backslash-n (\\n) \\<field-name>:\\<field-content>\\n\\<field-name>:\\<field-content>... (iOS only/string) ignoreInaccurateLocations Location accuracy below which reports are supressed (iOS,Android/integer/meters) ignoreStaleLocations Number of days after which location updates are assumed stale. Locations sent by friends older than the number of days specified here will not be shown on map or in friends list. Defaults to 0, which means stale locations are not filtered. (iOS,Android/integer/days) keepalive MQTT endpoint keepalive (iOS,Android/integer/seconds) locatorDisplacement maximum distance between location source updates (iOS,Android/integer/meters) locatorInterval maximum interval between location source updates (iOS,Android/integer/seconds) locatorPriority source/power setting for location updates (Android/integer/) 0 NO_POWER / best accuracy possible with zero additional power consumption (Android) 1 LOW_POWER / city level accuracy (Android) 2 BALANCED_POWER / block level accuracy based on Wifi/Cell (Android) 3 HIGH_POWER / most accurate accuracy based on GPS (Android) locked Locks settings screen on device for editing (iOS/boolean) maxHistory Number of notifications to store historically. Zero (0) means no notifications are stored and history tab is hidden. Defaults to zero. (iOS/integer) mode Endpoint protocol mode (iOS,Android/integer) 0 MQTT (iOS, Android) 3 HTTP (iOS, Android) monitoring Location reporting mode (iOS,Android/integer) -1 Quiet 0 Manual 1 Significant 2 Move mqttProtocolLevel MQTT broker protocol level (iOS,Android/integer) 3 MQTT 3 (default) 4 MQTT 3.1.1 5 MQTT 5 (iOS only) notificationLocation Show last reported location in ongoing notification (Android/boolean) opencageApiKey API key for alternate Geocoding provider. See OpenCage for details. (Android/string) passphrase Passphrase of the client pkcs12 file (iOS/string) password Endpoint password (iOS,Android/string) ping Interval in which location messages of with t : p are reported (Android/integer) port MQTT endpoint port (iOS,Android/integer) positions Number of locations to keep and display (iOS/integer) pubTopicBase MQTT topic base to which the app publishes; %u is replaced by the user name, %d by device (iOS,Android/string) pubRetain MQTT retain flag for reported messages (iOS,Android/boolean) pubQos MQTT QoS level for reported messages (iOS,Android/integer) ranging Beacon ranging (iOS/boolean) remoteConfiguration Allow remote configuration by sending a setConfiguration cmd message (Android/boolean) sub subscribe to subTopic via MQTT (iOS,Android/boolean) subTopic A whitespace separated list of MQTT topics to which the app subscribes if sub is true (defaults see topics ) (iOS,Android/string) subQos (iOS,Android/boolean) tid Two digit Tracker ID used to display short name and default face of a user (iOS,Android/string) tls MQTT endpoint TLS connection (iOS,Android/boolean) tlsClientCrtPassword Passphrase of the client pkcs12 file (Android/string) url HTTP endpoint URL to which messages are POSTed (iOS,Android/string) username Endpoint username (iOS,Android/string) ws use MQTT over Websocket, default false (iOS,Android/boolean) waypoints Array of waypoint messages (iOS,Android/array) Notes # When importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a mode element, the mode is changed first and all remaining elements are imported for the new mode. In MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60). Afterwards, an lwt message will be send. _type=beacon # These messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life. { \"_type\":\"beacon\", elements } desc name of the seen beacon (iOS/String) uuid UUID of the seen beacon (iOS/String) major Major number of the seen beacon (iOS/integer/epoch) minor Minor number of the seen beacon (iOS/integer/epoch) tst Timestamp at which the beacon was seen (iOS/integer/epoch) acc Accuracy of the proximity value (iOS/integer/meters) rssi Received signal strength of the beacon (iOS/integer/decibel) prox Relative distance to the beacon (iOS/integer) 0 Proximity of the beacon could not be determined 1 Beacon is in the immediate vicinity 2 Beacon is relatively close to the user 3 Beacon is far away Notes # The theoretical relationship between RSSI and distance is RSSI[dbm] = \u2212(10n log10(d) \u2212 A) where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon. _type=cmd # {\"_type\":\"cmd\", \"action\":\"reportLocation\"} {\"_type\":\"cmd\", \"action\":\"reportSteps\"} {\"_type\":\"cmd\", \"action\":\"dump\"} {\"_type\":\"cmd\", \"action\":\"waypoints\"} {\"_type\":\"cmd\", \"action\":\"clearWaypoints\"} {\"_type\":\"cmd\", \"action\":\"setConfiguration\", \"configuration\":{\"_type\":\"configuration\",...} {\"_type\":\"cmd\", \"action\":\"setWaypoints\", \"waypoints\":{\"_type\":\"waypoints\",\"waypoints\":[...]} {\"_type\":\"cmd\", \"action\":\"action\", \"content\":\"Backend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org\"} {\"_type\":\"cmd\", \"action\":\"action\", \"content\":\"<a href='http://support.owntracks.org'>Backend Maintenance tonight</a>\"} {\"_type\":\"cmd\", \"action\":\"action\", \"url\":\"http://support.owntracks.org\"} {\"_type\":\"cmd\", \"action\":\"action\", \"notification\":\"Warning! Battery low\"} action action to be performed by the device (iOS,Android/string) action Inserts an additional Featured Content tab in the UI (iOS) dump Triggers the publish of a configuration message (iOS) reportSteps Triggers the report of a steps messages_(iOS)_ from Timestamp (iOS/epoch/optional) to Timestamp (iOS/epoch/optional) reportLocation Triggers the publish of a location messages (iOS,Android) Don\u2018t expect device to be online. Send with QoS>0. Device will receive and repond when activated next time. clearWaypoints deletes all waypoints/regions (iOS) setWaypoints Imports (merge) and activates new waypoints (iOS,Android) waypoints Array of waypoint messages to import (iOS,Android/array/required) setConfiguration Imports and activates new configuration values (iOS,Android) configuration Configuration message to import (iOS,Android/required) waypoints Triggers publish of a waypoints message (iOS,Android) Notes # If url for the action cmd message is specified, the URL is opened in a full screen web view within the app If the optional extern boolean is true a click on the notification will launch an external browser instead If url is not specified the text of the content element is displayed. Links embedded in the text are operational. If the content consists of HTML, it is rendered The Featured Content tab can be removed with an action cmd message without content and without url element If the action cmd contains a notification element, the value of the element is shown in the app (iOS) On iOS, the array of waypoints to the setWaypoints command allows updates / removal; the key of the waypoint is its name ( desc ). If you specify an invalid lat or lon (invalid means out of range number value e.g. -1000000 , a string like \"foo\" will result in a 0 in app) the waypoint is deleted. On Android there's a primary key which isn't surfaced to the API, and tst is a uniquely-constrained value which effectively acts like a key. _type=steps # { \"_type\":\"steps\", elements } tst Timestamp of the request (iOS/integer/epoch) steps Steps walked with the device in the specfied time period (iOS/integer/steps) from Effective start of time period (iOS/integer/epoch) to Effective end of time period (iOS/integer/epoch) Notes # steps is -1 if device does not support step counting or specified time period is invalid _type=card # Apps read Card to display a name and icon for a user. { \"_type\": \"card\", elements } name Name to identify a user (iOS,Android/string/optional) face Base64 encoded PNG image that is displayed instead of the Tracker ID (iOS,Android/string/optional) _type=waypoints # The app can export a list of configured waypoints to the endpoint ../waypoints (plural). { \"_type\": \"waypoints\", elements } _creator Identification of what created the array. Ignored by the apps (iOS,Android/string/optional) waypoints Array of waypoint messages (iOS,Android/array/required) _type=encrypted # Apps can optionally encrypt outgoing messages with a shared symmetric key. The encrypted message is contained in the data element. For security reasons, the encryption key is not exported with configuration messages and cannot be imported. { \"_type\": \"encrypted\", elements } data Encrypted and Base64 encoded original JSON message (iOS,Android/string/required) _type=request # Apps can request the creation of tours which elicit a cmd response from the Recorder. See tours for the details. { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { ... } }","title":"JSON"},{"location":"tech/json/#types","text":"OwnTracks uses JSON format for its message payloads. The different payload types are identified by a mandatory _type element. Depending on the app platform, different payload types are supported. _type iOS Android beacon Y N card Y Y cmd Y Y configuration Y Y encrypted Y Y location Y Y lwt Y Y request Y N steps Y N transition Y Y waypoint Y Y waypoints Y Y","title":"Types"},{"location":"tech/json/#topics","text":"In MQTT mode the apps publish to: owntracks/user/device with _type=location for location updates, and with _type=lwt owntracks/user/device/cmd with _type=cmd for remote commands owntracks/user/device/event with _type=transition for enter/leave events owntracks/user/device/step to report step counter owntracks/user/device/beacon for beacon ranging owntracks/user/device/dump for config dumps owntracks/user/device/waypoint when a geofence is created on the device owntracks/user/device/waypoints (plural) when exporting a list of configured waypoints from device to backend In MQTT mode apps subscribe to: owntracks/user/device/cmd if remote commands are enabled owntracks/+/+ for seeing other user's locations, depending on broker ACL owntracks/+/+/event for transition messages ( enter / leave ) owntracks/+/+/info for obtaining cards . In HTTP mode the apps POST their data to a single endpoint you configure.","title":"Topics"},{"location":"tech/json/#_typelocation","text":"This location object describes the location of the device that reported it. { \"_type\" : \"location\", elements } acc Accuracy of the reported location in meters without unit (iOS,Android/integer/meters/optional) alt Altitude measured above sea level (iOS,Android/integer/meters/optional) batt Device battery level (iOS,Android/integer/percent/optional) bs Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full (iOS, Android) cog Course over ground (iOS/integer/degree/optional) lat latitude (iOS,Android/float/degree/required) lon longitude (iOS,Android/float/degree/required) rad radius around the region when entering/leaving (iOS/integer/meters/optional) t trigger for the location report (iOS,Android/string/optional) p ping issued randomly by background task (iOS,Android) c circular region enter/leave event (iOS,Android) b beacon region enter/leave event (iOS) r response to a reportLocation cmd message (iOS,Android) u manual publish requested by the user (iOS,Android) t timer based publish in move move (iOS) v updated by Settings/Privacy/Locations Services/System Services/Frequent Locations monitoring (iOS) tid Tracker ID used to display the initials of a user (iOS,Android/string/optional) required for http mode tst UNIX epoch timestamp in seconds of the location fix (iOS,Android/integer/epoch/required) vac vertical accuracy of the alt element (iOS/integer/meters/optional) vel velocity (iOS,Android/integer/kmh/optional) p barometric pressure (iOS/float/kPa/optional/extended data) poi point of interest name (iOS/string/optional) conn Internet connectivity status (route to host) when the message is created (iOS,Android/string/optional/extended data) w phone is connected to a WiFi connection (iOS,Android) o phone is offline (iOS,Android) m mobile data (iOS,Android) tag name of the tag (iOS/string/optional) topic (only in HTTP payloads) contains the original publish topic (e.g. owntracks/jane/phone ). (iOS,Android >= 2.4,string) inregions contains a list of regions the device is currently in (e.g. [\"Home\",\"Garage\"] ). Might be empty. (iOS,Android/list of strings/optional) inrids contains a list of region IDs the device is currently in (e.g. [\"6da9cf\",\"3defa7\"] ). Might be empty. (iOS,Android/list of strings/optional) SSID , if available, is the unique name of the WLAN. (iOS,string/optional) BSSID , if available, identifies the access point. (iOS,string/optional) created_at identifies the time at which the message is constructed (vs. tst which is the timestamp of the GPS fix) (iOS,Android) m identifies the monitoring mode at which the message is constructed ( significant = 1 , move = 2 ) (iOS/integer/optional)","title":"_type=location"},{"location":"tech/json/#notes","text":"The tst in a ping is a current timestamp , so that it doesn't look like a duplicate. The tid defaults to the last two characters of the topic A missing t element also indicates an automatic location update A publish of \"_type\": \"location\" with a \"b\" trigger is sent when an iOS device enters or leaves a beacon in addition to a \"_type\": \"transition\" : if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated. The acc , alt , cog , vac , vel elements are only added if they are not zero Some Android devices always return 0 for alt or vel Elements marked with extended data are only added if extendedData=true is configured","title":"Notes"},{"location":"tech/json/#greenwich","text":"The OwnTracks edition of the Choral Greenwich device reports the following additional elements in a _type=location message: { \"_type\": \"location\", elements } alt Altitude measured above sea level (integer/meters/optional) batt Device battery level (integer/percent/optional) cog Course over ground (integer/degree/optional) dist Distance travelled since the last location report (integer/meters/optional) trip Distance travelled since the last reboot (integer/meters/optional) vel velocity (integer/kmh/optional) t trigger for the location report (string/optional) f First publish after reboot m Manually requested locations (e.g. by publishing to /cmd ) t Time for location published because device is moving. T Time for location published because of time passed while device is stationary ( maxInterval ) k Transitioning from move to stationary (park) v Transitioning from stationary to move (mo-v-e) l Last known position when device lost GPS fix L Last known position before gracefull shutdown","title":"Greenwich"},{"location":"tech/json/#notes_1","text":"The device can be configured to produce or not produce fields marked as optional","title":"Notes"},{"location":"tech/json/#queclink","text":"OwnTracks works with a selection of trackers by Queclink , for which the protocol conversion is done via qtripp . Queclink devices report the following additional elements in a _type=location message: { \"_type\": \"location\", elements } t trigger for the location report (string/optional) o Corner M Mileage ! Tow or fake tow or sensor without ignition a motionless (aka park) i ignition on I ignition off e external power off E external power ON 1 Devices powered up 2 Battery stop charging 3 Battery start charging 9 Battery power low h harsh behavior s speed alarm odometer total distance of the device (float/kilometers/optional) hmc total hours of operation (float/seconds/optional) ubatt voltage of the battery (float/volts/optional) uext voltage of the external power source (float/volts/optional) vin vehicle identification number (string/optional) imei identification number (string/optional) name vehicle name (string/optional) don is duration since ignition on (float/seconds/optional) doff is duration since ignition off (float/seconds/optional) aiv is analog input voltage (float/volts/optional) rpm is engine rounds per minute (float/rounds per minute/optional) fcon is fuel consumption (float/L per 100km/optional) flvl is fuel level (float/percent/optional) anum is number of analog inputs (integer/optional) adid-xx is id of analog input number xx (string/optional) adty-xx is type of analog input number xx (string/optional) adda-xx is data of analog input number xx (string/optional) temp_c-xx is temperature of analog input number xx (float/celsius/optional) can is can data (string/optional) din1 is status of digital input 1 (boolean/optional) din2 is status of digital input 2 (boolean/optional) dout1 is status of digital output 1 (boolean/optional) dout2 is status of digital output 2 (boolean/optional) ign is status of ignition (boolean/optional) motion is motion status (boolean/optional) tow is status of tow sensor (boolean/optional) fake is status of fake tow sensor (boolean/optional) sens is status of motion sensor (boolean/optional) sent is epoch when message was sent (integer/epoch/optional) mcc is mobile country code (integer/optional) mnc is mobile network code (integer/optional) lac is location area code (string/optional) cid is cell id (string/optional) nmds is non movement detection status (boolean/optional) rit queclink record id and type (integer/optional) rty queclink record type (integer/optional) rid queclink record id (integer/optional) mst queclink motion state (integer/optional) count is counter of message (string/optional) raw_line raw data (string/optional) counter number of ignored positions (integer/optional) ignored indicates counter positions have been ignored (boolean/optional)","title":"Queclink"},{"location":"tech/json/#notes_2","text":"The device can be configured to produce or not produce fields marked as optional","title":"Notes"},{"location":"tech/json/#_typelwt","text":"A last will and testament is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this: { \"_type\":\"lwt\", elements } tst UNIX epoch timestamp at which the app first connected (iOS,Android/integer/epoch/required)","title":"_type=lwt"},{"location":"tech/json/#_typewaypoint","text":"Waypoints / regions denote specific geographical regions that you want to keep track of. You define a region in the OwnTracks app, and OwnTracks publishes this waypoint to the topic branch ../waypoint (singular). OwnTracks also monitors these waypoints and will publish {_type: \"transition\", ...} message when entering or leaving the region. A waypoint may also define a BLE Beacon instead of a geographical region. { \"_type\" : \"waypoint\", elements } desc Name of the waypoint that is included in the sent transition message, copied into the location message inregions array when a current position is within a region. (iOS,Android,string/required) lat Latitude (iOS,Android/float/meters/optional) lon Longitude (iOS,Android/float/meters/optional) rad Radius around the latitude and longitude coordinates (iOS,Android/integer/meters/optional) tst Timestamp of creation of region, copied into the wtst element of the transition message (iOS,Android/integer/epoch/required) uuid UUID of the BLE Beacon (iOS/string/optional) major Major number of the BLE Beacon (iOS/integer/optional) minor Minor number of the BLE Beacon_(iOS/integer/optional)_ rid region ID, created automatically, copied into the location payload inrids array (iOS/string)_","title":"_type=waypoint"},{"location":"tech/json/#notes_3","text":"In iOS version >= 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the desc element. If lat , lon and rad elements are present, transition messages are sent when entering and leaving the geographical region If uuid , major , minor elements are present, BLE becons with that specifications are monitored Beacons and Geographical regions can be defined together Waypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage. Waypoints are sent to the broker and transition messages contain a desc and event element.","title":"Notes"},{"location":"tech/json/#_typetransition","text":"A transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained. { \"_type\": \"transition\", elements } wtst Timestamp of waypoint creation (iOS,Android/integer/epoch/required) lat Latitude at which the event occured (iOS,Android/float/meters/optional) lon Longitue at which the event occured (iOS,Android/float/meters/optional) tst Timestamp at which the event occured (iOS,Android/integer/epoch/required) acc Accuracy of the geographical coordinates (iOS,Android/int/meters/required) tid Tracker ID of the (iOS/string/none/optional) required in http mode. event Event that triggered the transition (iOS,Android/string/required) enter The device entered the defined geographical region or BLE Beacon range (iOS) leave The device left the defined geographical region or BLE Beacon range (iOS) desc Name of the waypoint (iOS,Android/string/optional) t Trigger of the event (iOS,Android/string/optional) c Circular geographical region (iOS, Android) b BLE Beacon (iOS) l Loction update (Android) rid Region ID (iOS/Android, after January 2021)","title":"_type=transition"},{"location":"tech/json/#_typeconfiguration","text":"The device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages. { \"_type\": \"configuration\", elements } allowRemoteLocation Respond to reportLocation cmd message (iOS/boolean) allowinvalidcerts disable TLS certificate checks insecure (iOS/boolean) auth Use username and password for endpoint authentication (iOS,Android/boolean) autostartOnBoot Autostart the app on device boot (Android/boolean) cleanSession MQTT endpoint clean session (iOS,Android/boolean) clientId client id to use for MQTT connect. Defaults to \" user deviceId \" (iOS,Android/string) clientpkcs Name of the client pkcs12 file (iOS/string) cmd Respond to cmd messages (iOS,Android/boolean) deviceId id of the device used for pubTopicBase and clientId construction. Defaults to the os name of the device (iOS,Android/string) downgrade battery level below which to downgrade monitoring from move mode (iOS/integer/percent/optional) encryptionKey the secret key used for payload encryption (_iOS , Android/string) extendedData Add extended data attributes to location messages (iOS,Android/boolean) host MQTT endpoint host (iOS,Android/string) httpHeaders extra HTTP headers:field names and field content are separated by a colon (:), multiple fields by a backslash-n (\\n) \\<field-name>:\\<field-content>\\n\\<field-name>:\\<field-content>... (iOS only/string) ignoreInaccurateLocations Location accuracy below which reports are supressed (iOS,Android/integer/meters) ignoreStaleLocations Number of days after which location updates are assumed stale. Locations sent by friends older than the number of days specified here will not be shown on map or in friends list. Defaults to 0, which means stale locations are not filtered. (iOS,Android/integer/days) keepalive MQTT endpoint keepalive (iOS,Android/integer/seconds) locatorDisplacement maximum distance between location source updates (iOS,Android/integer/meters) locatorInterval maximum interval between location source updates (iOS,Android/integer/seconds) locatorPriority source/power setting for location updates (Android/integer/) 0 NO_POWER / best accuracy possible with zero additional power consumption (Android) 1 LOW_POWER / city level accuracy (Android) 2 BALANCED_POWER / block level accuracy based on Wifi/Cell (Android) 3 HIGH_POWER / most accurate accuracy based on GPS (Android) locked Locks settings screen on device for editing (iOS/boolean) maxHistory Number of notifications to store historically. Zero (0) means no notifications are stored and history tab is hidden. Defaults to zero. (iOS/integer) mode Endpoint protocol mode (iOS,Android/integer) 0 MQTT (iOS, Android) 3 HTTP (iOS, Android) monitoring Location reporting mode (iOS,Android/integer) -1 Quiet 0 Manual 1 Significant 2 Move mqttProtocolLevel MQTT broker protocol level (iOS,Android/integer) 3 MQTT 3 (default) 4 MQTT 3.1.1 5 MQTT 5 (iOS only) notificationLocation Show last reported location in ongoing notification (Android/boolean) opencageApiKey API key for alternate Geocoding provider. See OpenCage for details. (Android/string) passphrase Passphrase of the client pkcs12 file (iOS/string) password Endpoint password (iOS,Android/string) ping Interval in which location messages of with t : p are reported (Android/integer) port MQTT endpoint port (iOS,Android/integer) positions Number of locations to keep and display (iOS/integer) pubTopicBase MQTT topic base to which the app publishes; %u is replaced by the user name, %d by device (iOS,Android/string) pubRetain MQTT retain flag for reported messages (iOS,Android/boolean) pubQos MQTT QoS level for reported messages (iOS,Android/integer) ranging Beacon ranging (iOS/boolean) remoteConfiguration Allow remote configuration by sending a setConfiguration cmd message (Android/boolean) sub subscribe to subTopic via MQTT (iOS,Android/boolean) subTopic A whitespace separated list of MQTT topics to which the app subscribes if sub is true (defaults see topics ) (iOS,Android/string) subQos (iOS,Android/boolean) tid Two digit Tracker ID used to display short name and default face of a user (iOS,Android/string) tls MQTT endpoint TLS connection (iOS,Android/boolean) tlsClientCrtPassword Passphrase of the client pkcs12 file (Android/string) url HTTP endpoint URL to which messages are POSTed (iOS,Android/string) username Endpoint username (iOS,Android/string) ws use MQTT over Websocket, default false (iOS,Android/boolean) waypoints Array of waypoint messages (iOS,Android/array)","title":"_type=configuration"},{"location":"tech/json/#notes_4","text":"When importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a mode element, the mode is changed first and all remaining elements are imported for the new mode. In MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60). Afterwards, an lwt message will be send.","title":"Notes"},{"location":"tech/json/#_typebeacon","text":"These messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life. { \"_type\":\"beacon\", elements } desc name of the seen beacon (iOS/String) uuid UUID of the seen beacon (iOS/String) major Major number of the seen beacon (iOS/integer/epoch) minor Minor number of the seen beacon (iOS/integer/epoch) tst Timestamp at which the beacon was seen (iOS/integer/epoch) acc Accuracy of the proximity value (iOS/integer/meters) rssi Received signal strength of the beacon (iOS/integer/decibel) prox Relative distance to the beacon (iOS/integer) 0 Proximity of the beacon could not be determined 1 Beacon is in the immediate vicinity 2 Beacon is relatively close to the user 3 Beacon is far away","title":"_type=beacon"},{"location":"tech/json/#notes_5","text":"The theoretical relationship between RSSI and distance is RSSI[dbm] = \u2212(10n log10(d) \u2212 A) where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon.","title":"Notes"},{"location":"tech/json/#_typecmd","text":"{\"_type\":\"cmd\", \"action\":\"reportLocation\"} {\"_type\":\"cmd\", \"action\":\"reportSteps\"} {\"_type\":\"cmd\", \"action\":\"dump\"} {\"_type\":\"cmd\", \"action\":\"waypoints\"} {\"_type\":\"cmd\", \"action\":\"clearWaypoints\"} {\"_type\":\"cmd\", \"action\":\"setConfiguration\", \"configuration\":{\"_type\":\"configuration\",...} {\"_type\":\"cmd\", \"action\":\"setWaypoints\", \"waypoints\":{\"_type\":\"waypoints\",\"waypoints\":[...]} {\"_type\":\"cmd\", \"action\":\"action\", \"content\":\"Backend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org\"} {\"_type\":\"cmd\", \"action\":\"action\", \"content\":\"<a href='http://support.owntracks.org'>Backend Maintenance tonight</a>\"} {\"_type\":\"cmd\", \"action\":\"action\", \"url\":\"http://support.owntracks.org\"} {\"_type\":\"cmd\", \"action\":\"action\", \"notification\":\"Warning! Battery low\"} action action to be performed by the device (iOS,Android/string) action Inserts an additional Featured Content tab in the UI (iOS) dump Triggers the publish of a configuration message (iOS) reportSteps Triggers the report of a steps messages_(iOS)_ from Timestamp (iOS/epoch/optional) to Timestamp (iOS/epoch/optional) reportLocation Triggers the publish of a location messages (iOS,Android) Don\u2018t expect device to be online. Send with QoS>0. Device will receive and repond when activated next time. clearWaypoints deletes all waypoints/regions (iOS) setWaypoints Imports (merge) and activates new waypoints (iOS,Android) waypoints Array of waypoint messages to import (iOS,Android/array/required) setConfiguration Imports and activates new configuration values (iOS,Android) configuration Configuration message to import (iOS,Android/required) waypoints Triggers publish of a waypoints message (iOS,Android)","title":"_type=cmd"},{"location":"tech/json/#notes_6","text":"If url for the action cmd message is specified, the URL is opened in a full screen web view within the app If the optional extern boolean is true a click on the notification will launch an external browser instead If url is not specified the text of the content element is displayed. Links embedded in the text are operational. If the content consists of HTML, it is rendered The Featured Content tab can be removed with an action cmd message without content and without url element If the action cmd contains a notification element, the value of the element is shown in the app (iOS) On iOS, the array of waypoints to the setWaypoints command allows updates / removal; the key of the waypoint is its name ( desc ). If you specify an invalid lat or lon (invalid means out of range number value e.g. -1000000 , a string like \"foo\" will result in a 0 in app) the waypoint is deleted. On Android there's a primary key which isn't surfaced to the API, and tst is a uniquely-constrained value which effectively acts like a key.","title":"Notes"},{"location":"tech/json/#_typesteps","text":"{ \"_type\":\"steps\", elements } tst Timestamp of the request (iOS/integer/epoch) steps Steps walked with the device in the specfied time period (iOS/integer/steps) from Effective start of time period (iOS/integer/epoch) to Effective end of time period (iOS/integer/epoch)","title":"_type=steps"},{"location":"tech/json/#notes_7","text":"steps is -1 if device does not support step counting or specified time period is invalid","title":"Notes"},{"location":"tech/json/#_typecard","text":"Apps read Card to display a name and icon for a user. { \"_type\": \"card\", elements } name Name to identify a user (iOS,Android/string/optional) face Base64 encoded PNG image that is displayed instead of the Tracker ID (iOS,Android/string/optional)","title":"_type=card"},{"location":"tech/json/#_typewaypoints","text":"The app can export a list of configured waypoints to the endpoint ../waypoints (plural). { \"_type\": \"waypoints\", elements } _creator Identification of what created the array. Ignored by the apps (iOS,Android/string/optional) waypoints Array of waypoint messages (iOS,Android/array/required)","title":"_type=waypoints"},{"location":"tech/json/#_typeencrypted","text":"Apps can optionally encrypt outgoing messages with a shared symmetric key. The encrypted message is contained in the data element. For security reasons, the encryption key is not exported with configuration messages and cannot be imported. { \"_type\": \"encrypted\", elements } data Encrypted and Base64 encoded original JSON message (iOS,Android/string/required)","title":"_type=encrypted"},{"location":"tech/json/#_typerequest","text":"Apps can request the creation of tours which elicit a cmd response from the Recorder. See tours for the details. { \"_type\": \"request\", \"request\": \"tour\", \"tour\": { ... } }","title":"_type=request"},{"location":"tech/lua/","text":"Lua hooks # If Recorder is compiled with Lua support (which we do by default), a Lua script you provide is launched at startup. Lua is a powerful, fast, lightweight, embeddable scripting language . You can use this to process location publishes in any way you desire: your imagination (and Lua-scripting knowhow) set the limits. Some examples: insert received publishes into a database of your choice switch on the coffee machine when your OwnTracks device reports you're entering home (but see also mqttwarn ) write a file with data in a format of your choice (see etc/example.lua ) Run the Recorder with the path to your Lua script specified in its --lua-script option (there is no default). If the script cannot be loaded (e.g. because it cannot be read or contains syntax errors), the Recorder aborts with a diagnostic. Configure lua_script: in our quicksetup configuration.yaml to have this enabled for you. If the Lua script can be loaded, it is automatically provided with a table variable called otr which contains the following members: otr.version is a read-only string with the Recorder version (example: \"0.3.2\" ) otr.log(s) is a function which takes a string s which is logged to syslog at the Recorder's facility and log level INFO. otr.strftime(fmt, t) is a function which takes a format string fmt (see strftime(3) ) and an integer number of seconds t and returns a string with the formatted UTC time. If t is 0 or negative, the current system time is used. Your Lua script must provide the following functions: otr_init # This is invoked at start of Recorder. If the function returns a non-zero value, Recorder unloads Lua and disables its processing; i.e. the hook() will not be invoked on location publishes. otr_exit # This is invoked when the Recorder stops, which it doesn't really do unless you CTRL-C it or send it a SIGTERM signal. otr_hook # This function is invoked at every location publish processed by the Recorder. Your function is passed three arguments: topic is the topic published to (e.g. owntracks/jane/phone ) type is the type of MQTT message. This is the _type in our JSON messages (e.g. location , cmd , transition , ...) or \"unknown\" . location is a Lua table (associative array) with all the elements obtained in the JSON message. In the case of type being location , we also add country code ( cc ) and the location's address ( addr ) unless reverse-geo lookups have been disabled in Recorder. Assume the following small example Lua script in example.lua : local file function otr_init() otr.log(\"example.lua starting; writing to /tmp/lua.out\") file = io.open(\"/tmp/lua.out\", \"a\") file:write(\"written by OwnTracks Recorder version \" .. otr.version .. \"\\n\") end function otr_hook(topic, _type, data) local timestr = otr.strftime(\"It is %T in the year %Y\", 0) print(\"L: \" .. topic .. \" -> \" .. _type) file:write(timestr .. \" \" .. topic .. \" lat=\" .. data['lat'] .. data['addr'] .. \"\\n\") end function otr_exit() end When Recorder is launched with --lua-script example.lua it invokes otr_init() which opens a file. Then, for each location received, it calls otr_hook() which updates the file. Assuming an OwnTracks device publishes this (shortened for clarity) payload {\"batt\":-1,\"lon\":2.29513,\"lat\":48.85833,\"t\":\"u\",\"tst\":1441984413,\"_type\":\"location\",\"tid\":\"JJ\"} the file /tmp/lua.out would contain written by OwnTracks Recorder version 0.3.0 It is 17:13:33 in the year 2015 owntracks/jane/phone lat=48.858339 Avenue Anatole France, 75007 Paris, France Republishing HTTP posts # OwnTracks location (and other type) publishes submitted via HTTP are not automatically republished to MQTT. Should you wish to do this, Lua hooks can help accomplish this. The following example illustrates how to do so. -- requires: -- a) Compile recorder with -DLUA and configure -- b) OTR_LUASCRIPT = \".../repub.lua\" -- also requires Lua JSON from http://regex.info/blog/lua/json JSON = (loadfile \"/etc/ot-recorder/JSON.lua\")() function otr_init() end function otr_exit() end function otr_hook(topic, _type, data) otr.log(\"DEBUG_PUB:\" .. topic .. \" \" .. JSON:encode(data)) if(data['_http'] == true) then if(data['_repub'] == true) then return end data['_repub'] = true local payload = JSON:encode(data) otr.publish(topic, payload, 1, 1) end end There's more information on this with examples, including creating a per-JSON-element hook, if you're interested.","title":"Lua"},{"location":"tech/lua/#lua-hooks","text":"If Recorder is compiled with Lua support (which we do by default), a Lua script you provide is launched at startup. Lua is a powerful, fast, lightweight, embeddable scripting language . You can use this to process location publishes in any way you desire: your imagination (and Lua-scripting knowhow) set the limits. Some examples: insert received publishes into a database of your choice switch on the coffee machine when your OwnTracks device reports you're entering home (but see also mqttwarn ) write a file with data in a format of your choice (see etc/example.lua ) Run the Recorder with the path to your Lua script specified in its --lua-script option (there is no default). If the script cannot be loaded (e.g. because it cannot be read or contains syntax errors), the Recorder aborts with a diagnostic. Configure lua_script: in our quicksetup configuration.yaml to have this enabled for you. If the Lua script can be loaded, it is automatically provided with a table variable called otr which contains the following members: otr.version is a read-only string with the Recorder version (example: \"0.3.2\" ) otr.log(s) is a function which takes a string s which is logged to syslog at the Recorder's facility and log level INFO. otr.strftime(fmt, t) is a function which takes a format string fmt (see strftime(3) ) and an integer number of seconds t and returns a string with the formatted UTC time. If t is 0 or negative, the current system time is used. Your Lua script must provide the following functions:","title":"Lua hooks"},{"location":"tech/lua/#otr_init","text":"This is invoked at start of Recorder. If the function returns a non-zero value, Recorder unloads Lua and disables its processing; i.e. the hook() will not be invoked on location publishes.","title":"otr_init"},{"location":"tech/lua/#otr_exit","text":"This is invoked when the Recorder stops, which it doesn't really do unless you CTRL-C it or send it a SIGTERM signal.","title":"otr_exit"},{"location":"tech/lua/#otr_hook","text":"This function is invoked at every location publish processed by the Recorder. Your function is passed three arguments: topic is the topic published to (e.g. owntracks/jane/phone ) type is the type of MQTT message. This is the _type in our JSON messages (e.g. location , cmd , transition , ...) or \"unknown\" . location is a Lua table (associative array) with all the elements obtained in the JSON message. In the case of type being location , we also add country code ( cc ) and the location's address ( addr ) unless reverse-geo lookups have been disabled in Recorder. Assume the following small example Lua script in example.lua : local file function otr_init() otr.log(\"example.lua starting; writing to /tmp/lua.out\") file = io.open(\"/tmp/lua.out\", \"a\") file:write(\"written by OwnTracks Recorder version \" .. otr.version .. \"\\n\") end function otr_hook(topic, _type, data) local timestr = otr.strftime(\"It is %T in the year %Y\", 0) print(\"L: \" .. topic .. \" -> \" .. _type) file:write(timestr .. \" \" .. topic .. \" lat=\" .. data['lat'] .. data['addr'] .. \"\\n\") end function otr_exit() end When Recorder is launched with --lua-script example.lua it invokes otr_init() which opens a file. Then, for each location received, it calls otr_hook() which updates the file. Assuming an OwnTracks device publishes this (shortened for clarity) payload {\"batt\":-1,\"lon\":2.29513,\"lat\":48.85833,\"t\":\"u\",\"tst\":1441984413,\"_type\":\"location\",\"tid\":\"JJ\"} the file /tmp/lua.out would contain written by OwnTracks Recorder version 0.3.0 It is 17:13:33 in the year 2015 owntracks/jane/phone lat=48.858339 Avenue Anatole France, 75007 Paris, France","title":"otr_hook"},{"location":"tech/lua/#republishing-http-posts","text":"OwnTracks location (and other type) publishes submitted via HTTP are not automatically republished to MQTT. Should you wish to do this, Lua hooks can help accomplish this. The following example illustrates how to do so. -- requires: -- a) Compile recorder with -DLUA and configure -- b) OTR_LUASCRIPT = \".../repub.lua\" -- also requires Lua JSON from http://regex.info/blog/lua/json JSON = (loadfile \"/etc/ot-recorder/JSON.lua\")() function otr_init() end function otr_exit() end function otr_hook(topic, _type, data) otr.log(\"DEBUG_PUB:\" .. topic .. \" \" .. JSON:encode(data)) if(data['_http'] == true) then if(data['_repub'] == true) then return end data['_repub'] = true local payload = JSON:encode(data) otr.publish(topic, payload, 1, 1) end end There's more information on this with examples, including creating a per-JSON-element hook, if you're interested.","title":"Republishing HTTP posts"},{"location":"tech/mqtt/","text":"MQTT # Keepalives # MQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the keepalive interval which is set by the client. The server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec. From the spec: The actual value of the Keep Alive is application specific; typically this is a few minutes. The maximum value is 18 hours 12 minutes and 15 seconds. For example, mosquitto_sub uses a default of 60 sec. In addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand. Broker # Below is a list of known configuration values that are required to connect to certain MQTT endpoints AWS IOT # The OwnTracks apps are partially compatible to the AWS IOT broker in MQTT mode. As AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. Before connecting, a so called thing has to be configured which represents the connecting client. The thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. The most basic policy allows all actions for the thing . { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:*\", \"Resource\": \"*\" } ] } The following settings are required to connect { \"_type\":\"configuration\", \"mode\":0, \"host\": \"ENDPOINT.amazonaws.com\", \"port\": 8883, \"subQos\":0, \"pubQos\":0, \"auth\":false, \"pubRetain\":false, \"cleanSession\":true, \"tls\":true \"clientId\":\"CLIENTID\", } The ENDPOINT can be obtained in the thing details under Interact . Additionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca. Before importing it into the app, you need to set a password to the client TLS certificate. Losant IoT Developer Platform # The OwnTracks apps are partially compatible to the Losant IoT Developer Platform in MQTT mode. As Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. The following settings are required to connect { \"_type\": \"configuration\", \"mode\":0, \"mqttProtocolLevel\": 4, \"host\":\"broker.losant.com\", \"port\":8883, \"tls\":true, \"pubRetain\": false, \"pubQos\": 0, \"subQos\":0, \"cleanSession\": true, \"clientId\":\"CLIENT_ID\", \"auth\":true, \"username\":\"ACCESS_KEY\", \"password\":\"ACCESS_SECRET\" } See the official documentation how to obtain the ACCESS_KEY and ACCESS_SECRET .","title":"Mqtt"},{"location":"tech/mqtt/#mqtt","text":"","title":"MQTT"},{"location":"tech/mqtt/#keepalives","text":"MQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the keepalive interval which is set by the client. The server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec. From the spec: The actual value of the Keep Alive is application specific; typically this is a few minutes. The maximum value is 18 hours 12 minutes and 15 seconds. For example, mosquitto_sub uses a default of 60 sec. In addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand.","title":"Keepalives"},{"location":"tech/mqtt/#broker","text":"Below is a list of known configuration values that are required to connect to certain MQTT endpoints","title":"Broker"},{"location":"tech/mqtt/#aws-iot","text":"The OwnTracks apps are partially compatible to the AWS IOT broker in MQTT mode. As AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. Before connecting, a so called thing has to be configured which represents the connecting client. The thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. The most basic policy allows all actions for the thing . { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:*\", \"Resource\": \"*\" } ] } The following settings are required to connect { \"_type\":\"configuration\", \"mode\":0, \"host\": \"ENDPOINT.amazonaws.com\", \"port\": 8883, \"subQos\":0, \"pubQos\":0, \"auth\":false, \"pubRetain\":false, \"cleanSession\":true, \"tls\":true \"clientId\":\"CLIENTID\", } The ENDPOINT can be obtained in the thing details under Interact . Additionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca. Before importing it into the app, you need to set a password to the client TLS certificate.","title":"AWS IOT"},{"location":"tech/mqtt/#losant-iot-developer-platform","text":"The OwnTracks apps are partially compatible to the Losant IoT Developer Platform in MQTT mode. As Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. The following settings are required to connect { \"_type\": \"configuration\", \"mode\":0, \"mqttProtocolLevel\": 4, \"host\":\"broker.losant.com\", \"port\":8883, \"tls\":true, \"pubRetain\": false, \"pubQos\": 0, \"subQos\":0, \"cleanSession\": true, \"clientId\":\"CLIENT_ID\", \"auth\":true, \"username\":\"ACCESS_KEY\", \"password\":\"ACCESS_SECRET\" } See the official documentation how to obtain the ACCESS_KEY and ACCESS_SECRET .","title":"Losant IoT Developer Platform"},{"location":"tech/program/","text":"Programming # We've shown you some clients which consume OwnTracks data , but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of Python together with the Paho Python client . Getting started: Paho Python # We're assuming you have Python installed, which you can verify by attempting to invoke python3 -V ; if installed, it tells you the version number. We're also assuming you have pip installed (a Python package manager) which may be called pip or something on your machine. Install the Paho Python module using $ python3 -mvenv venv $ source venv/bin/activate (venv) $ pip install paho-mqtt Progress reports # Assume we want to create a program which should report the location of our friends, as a simple list: TID = n4 is currently at 51.0343863, 9.4763712 TID = jane is currently at 48.856826, 2.292713 We need a small utility program which will subscribe to location publishes received by your broker by connecting to it on localhost and subscribing to owntracks/+/+ (a wild-card expression in which each + means anything at this level ). The Code # For each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID ( TID ) as well as latitude, longitude coordinates. Keep a copy of our OwnTracks-JSON documentation handy and study the topic names of each possible publish by the apps. #!/usr/bin/env python import paho.mqtt.client as mqtt import json # The callback for when the client successfully connects to the broker def on_connect(client, userdata, flags, rc): ''' We subscribe on_connect() so that if we lose the connection and reconnect, subscriptions will be renewed. ''' client.subscribe(\"owntracks/+/+\") # The callback for when a PUBLISH message is received from the broker def on_message(client, userdata, msg): topic = msg.topic payload = msg.payload.decode(\"utf-8\") try: data = json.loads(payload) print(\"TID = {0} is currently at {1}, {2}\".format(data['tid'], data['lat'], data['lon'])) except: print(\"Cannot decode data on topic {0}\".format(topic)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"localhost\", 1883, 60) # Blocking call which processes all network traffic and dispatches # callbacks (see on_*() above). It also handles reconnecting. client.loop_forever() Testing # Testing location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply: Use the publish now button in OwnTracks to fire a location update. The smart phone won't really move much of course, but it'll allow you to test your program a bit. Publish your own OwnTracks-JSON payload to the broker with mosquitto_pub or similar, even using a small script: #!/bin/sh jo _type=location \\ lat=48.856826 \\ lon=2.292713 \\ tid=j1 \\ tst=$(date +%s) | mosquitto_pub -r -t owntracks/jane/nokia -l Adding Lua hooks to Recorder # If you wish to dig deeper into what our Recorder backend can do, we've documented getting started with Lua hooks for you.","title":"Code"},{"location":"tech/program/#programming","text":"We've shown you some clients which consume OwnTracks data , but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of Python together with the Paho Python client .","title":"Programming"},{"location":"tech/program/#getting-started-paho-python","text":"We're assuming you have Python installed, which you can verify by attempting to invoke python3 -V ; if installed, it tells you the version number. We're also assuming you have pip installed (a Python package manager) which may be called pip or something on your machine. Install the Paho Python module using $ python3 -mvenv venv $ source venv/bin/activate (venv) $ pip install paho-mqtt","title":"Getting started: Paho Python"},{"location":"tech/program/#progress-reports","text":"Assume we want to create a program which should report the location of our friends, as a simple list: TID = n4 is currently at 51.0343863, 9.4763712 TID = jane is currently at 48.856826, 2.292713 We need a small utility program which will subscribe to location publishes received by your broker by connecting to it on localhost and subscribing to owntracks/+/+ (a wild-card expression in which each + means anything at this level ).","title":"Progress reports"},{"location":"tech/program/#the-code","text":"For each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID ( TID ) as well as latitude, longitude coordinates. Keep a copy of our OwnTracks-JSON documentation handy and study the topic names of each possible publish by the apps. #!/usr/bin/env python import paho.mqtt.client as mqtt import json # The callback for when the client successfully connects to the broker def on_connect(client, userdata, flags, rc): ''' We subscribe on_connect() so that if we lose the connection and reconnect, subscriptions will be renewed. ''' client.subscribe(\"owntracks/+/+\") # The callback for when a PUBLISH message is received from the broker def on_message(client, userdata, msg): topic = msg.topic payload = msg.payload.decode(\"utf-8\") try: data = json.loads(payload) print(\"TID = {0} is currently at {1}, {2}\".format(data['tid'], data['lat'], data['lon'])) except: print(\"Cannot decode data on topic {0}\".format(topic)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"localhost\", 1883, 60) # Blocking call which processes all network traffic and dispatches # callbacks (see on_*() above). It also handles reconnecting. client.loop_forever()","title":"The Code"},{"location":"tech/program/#testing","text":"Testing location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply: Use the publish now button in OwnTracks to fire a location update. The smart phone won't really move much of course, but it'll allow you to test your program a bit. Publish your own OwnTracks-JSON payload to the broker with mosquitto_pub or similar, even using a small script: #!/bin/sh jo _type=location \\ lat=48.856826 \\ lon=2.292713 \\ tid=j1 \\ tst=$(date +%s) | mosquitto_pub -r -t owntracks/jane/nokia -l","title":"Testing"},{"location":"tech/program/#adding-lua-hooks-to-recorder","text":"If you wish to dig deeper into what our Recorder backend can do, we've documented getting started with Lua hooks for you.","title":"Adding Lua hooks to Recorder"},{"location":"tech/qr/","text":"To configure OwnTracks (and especially iBeacons for the iOS app), you can use URIs or QR codes. The QR codes can opened via the camera app, the URIs via the Web browser, the email app, etc. QR codes can be prepared with a number of tools: there are online offerings, and there is a standalone C program by the name of qrencode which works very well: qrencode -l H -v 10 -d 300 -o mybeacon.png 'owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1' iBeacon QR URI # scheme = owntracks host = <empty> path = /beacon query = rid=<rid>&name=<name>&uuid=<uuid>&major=<major>&minor=<minor> rid, major, and minor are optional Example: owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1 config QR URI # See Features/Remoteconfig/URL config","title":"Qr"},{"location":"tech/qr/#ibeacon-qr-uri","text":"scheme = owntracks host = <empty> path = /beacon query = rid=<rid>&name=<name>&uuid=<uuid>&major=<major>&minor=<minor> rid, major, and minor are optional Example: owntracks:///beacon?rid=ac3def&name=MyBeacon&uuid=12345678-1234-1234-1234-123456789A&major=2&minor=1","title":"iBeacon QR URI"},{"location":"tech/qr/#config-qr-uri","text":"See Features/Remoteconfig/URL config","title":"config QR URI"}]}