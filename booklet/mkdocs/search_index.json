{
    "docs": [
        {
            "location": "/", 
            "text": "OwnTracks\n\n\n\n\n\nOwnTracks is an Open Source project which provides an iOS and an Android app with which your smartphone records its current location. While there are many smartphone apps available which can do that, we think OwnTracks is special.\n\n\n\n\nWhether you want your young child to know where you currently are, or you want to keep track of where you spent your last vacation, or you and a group of friends want to see each other on a map, OwnTracks does that. It consists of an app which runs on your smart phone, and which periodically, publishes a small chunk of data which other OwnTracks users you authorize may see. The big deal here is \nwhich you authorize\n: we are extremely picky about \nthe security features of OwnTracks\n.\n\n\nFrom this point onwards, it gets a bit complicated, but we'll try and ease your way into the world of OwnTracks so you may enjoy it. \n\n\nWe think the best way to get started using OwnTracks is to follow this guide, chapter by chapter, but you certainly may fast-forward or even skip sections you're familiar with. Pressing \nNext\n on each page will guide you (pun!) through the guide.\n\n\nWe'll now move on to explain \nwhat OwnTracks does and how it works\n.", 
            "title": "Intro"
        }, 
        {
            "location": "/guide/whathow/", 
            "text": "What OwnTracks does\n\n\nThe OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other things we'll discuss in a moment).\n\n\nWe'd like you to read this bit again:\n\n\n\n\nwaits for the smart phone to tell it that the device has moved\n\n\n\n\nIt is very important to understand that OwnTracks literally waits for the device's operating system to inform it of a movement; only then can OwnTracks react and do something. To make matters even more complicated\n1\n, OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing.\n\n\nThat's basically all OwnTracks does.\n\n\nMore\n\n\nThat last sentence isn't true. Strike it.\n\n\nOwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and \nthat of your friends\n on a map. Ah: better. It can also detect when you enter or leave a particular region for which \nyou set a so-called waypoint\n. People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.)\n\n\nOwnTracks also has a pedometer, a.k.a. step counter (on iPhone 5S, 6) which you can query remotely. OwnTracks has support for \niBeacons\n, and it gives you neat notifications when one of your friends gets home so you can phone them over a land-line to plan a get-together.\n\n\nOwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.)\n\n\nAnd finally, though for us this is \nvery\n important, OwnTracks does all this securely.\n\n\nHow OwnTracks works\n\n\nThe OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's \nmoved\n a significant distance\n1\n, it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \"\nhey, I'm here\n\", whereby \"\nhere\n\" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server. This last server is called a \nbroker\n and the contact is made with an open, lightweight, \nstandardized protocol called MQTT\n. (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called \npublish\n in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is ideally something you provide, but we can help you out to start with by lending you the use of ours, free of charge for a while.\n\n\n\n\nInstead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server.\n\n\n\n\nAbove: the general architecture of OwnTracks\n\n\nThe broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend, \nto a program\n which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later.\n\n\nThe important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's \nyours\n.\n\n\nBasic setup\n\n\nOwnTracks used to be difficult to set up particularly because you had to provide the server (called a \nbroker\n, remember?) yourself, but we've gone to great lengths to make it easy for you to try before you'll want to take it upon yourself to do all the setup work.\n\n\nWe'll now cover the \ntwo scenarios\n.\n\n\n\n\n\n\n\n\n\n\nThis is a relative amount, but you can tune it a bit.", 
            "title": "What it does"
        }, 
        {
            "location": "/guide/whathow/#what-owntracks-does", 
            "text": "The OwnTracks app runs in the background on your Android or iOS device and waits for the smart phone to tell it that the device has moved, whereupon OwnTracks sends out a message with its current coordinates (and a few other things we'll discuss in a moment).  We'd like you to read this bit again:   waits for the smart phone to tell it that the device has moved   It is very important to understand that OwnTracks literally waits for the device's operating system to inform it of a movement; only then can OwnTracks react and do something. To make matters even more complicated 1 , OwnTracks on Android runs in the background, all the time, whereas on iOS it is \"killed off\" by the operating system and woken up every several hundred seconds, in which it gets a teeny tiny time slot to do its thing.  That's basically all OwnTracks does.", 
            "title": "What OwnTracks does"
        }, 
        {
            "location": "/guide/whathow/#more", 
            "text": "That last sentence isn't true. Strike it.  OwnTracks does quite a bit more. It shows your location on a map. Wow: big deal, huh? Well, it shows your location and  that of your friends  on a map. Ah: better. It can also detect when you enter or leave a particular region for which  you set a so-called waypoint . People use this, say, to control some aspect of their home-automation system. (Everybody left home? We can turn the lights off.)  OwnTracks also has a pedometer, a.k.a. step counter (on iPhone 5S, 6) which you can query remotely. OwnTracks has support for  iBeacons , and it gives you neat notifications when one of your friends gets home so you can phone them over a land-line to plan a get-together.  OwnTracks reports the device's battery level remotely so you can add that to your monitoring setup, if you have one. (No worries if you don't -- you probably don't need it then.)  And finally, though for us this is  very  important, OwnTracks does all this securely.", 
            "title": "More"
        }, 
        {
            "location": "/guide/whathow/#how-owntracks-works", 
            "text": "The OwnTracks apps run on your smart phone (but we've already mentioned that at least once, haven't we?). When the device determines that it's  moved  a significant distance 1 , it contacts a server via 3G or WiFi (hopefully one of those is available, but we queue messages many thousands on the app until connectivity can be established) and says \" hey, I'm here \", whereby \" here \" is specified with a bit more precision. This server is either a HTTP Web server or an MQTT server. This last server is called a  broker  and the contact is made with an open, lightweight,  standardized protocol called MQTT . (If you think that's bad it isn't: the protocol you use to surf the Web is called HTTP; does that sound much better?) So the smart phone sends your location (this operation is called  publish  in MQTT-speak) to the broker and goes back to sleep until it realizes you've again moved a significant distance whereupon the whole procedure starts anew. This broker is ideally something you provide, but we can help you out to start with by lending you the use of ours, free of charge for a while.   Instead of using MQTT, you can configure the apps to use HTTP, whereupon they then speak HTTP to your server.   Above: the general architecture of OwnTracks  The broker receives the data, and then? Well, it can re-distribute it, at your wish. What this basically means is it can forward your location to a friend,  to a program  which stores your location in, say, a database, etc. There are plenty of things you can do, and we'll show you some of them later.  The important message here, and we can't repeat this often enough: OwnTracks is designed in such a way as that you can chose what you do with your data. It's  yours .", 
            "title": "How OwnTracks works"
        }, 
        {
            "location": "/guide/whathow/#basic-setup", 
            "text": "OwnTracks used to be difficult to set up particularly because you had to provide the server (called a  broker , remember?) yourself, but we've gone to great lengths to make it easy for you to try before you'll want to take it upon yourself to do all the setup work.  We'll now cover the  two scenarios .      This is a relative amount, but you can tune it a bit.", 
            "title": "Basic setup"
        }, 
        {
            "location": "/guide/clients/", 
            "text": "Clients\n\n\nUsing our OwnTracks app is cool, but what do you do with the location data the apps send (i.e. \npublish\n) to the MQTT broker? We have some suggestions.\n\n\nYou know that OwnTracks \npublishes\n location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called \nJSON\n, and \nthis is what it looks like\n.\n\n\nWhen you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that.\n\n\nmosquitto_sub\n\n\nmosquitto_sub\n is a very basic command-line client provided by the \nMosquitto project\n. However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with \nstdout\n pointing to a file.\n\n\nIn it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in.\n\n\nmosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#'\n\n\n\n\nmosquitto_sub\n and it's counterpart, \nmosquitto_pub\n for publishing to a broker, support a slew of options. It'll be worth your while to study their \nmanual page\n.\n\n\nRecorder\n\n\nWe recommend our very own \nOwnTracks Recorder\n because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind.\n\n\n\n\nAnd the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well.\n\n\nRead \nmore about the Recorder\n.\n\n\nmqttwarn\n\n\nYou'll recall (we hope) the discussion on \nMQTT\n and the analogy with the cauldron. \nmqttwarn\n, while not specific to OwnTracks, is another client you connect to your \nMQTT broker\n. We think it's worth mentioning (and both Ben and JP -- the creators -- are quite pleased with what it does).\n\n\nmqttwarn\n lets you do things like tweet everytime OwnTracks reports a location (but do consider whether you \nreally\n want that), send an e-mail when a loved one enters a particular region, etc.\n\n\nopenHAB\n\n\nPresence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action. \n\n\n\n\nThis is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal \nMQTT broker\n where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in \nprivate mode\n, all your data is 'yours' and yours alone - there is no cloud service collecting, storing and potentially mining your data. \n\n\nRead more about \nopenHAB and OwnTracks\n.\n\n\nHome Assistant\n\n\nAnother home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal \nMQTT broker\n. It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4. \n\n\nSee the \ndemo\n for an example of the map with OwnTracks devices or read more about how Home Assistant \nconnects to your private MQTT broker\n, how to \nenable OwnTracks support in Home Assistant\n and how to \nconfigure automations based on zones\n.\n\n\nOwnTracks-Cards\n\n\nThis is a webapp to create and edit \nOwnTracks cards\n.\nIt can be either used to just create the JSON representation of the card, which has to be published to the MQTT broker manually. Or it can directly publish the card to an MQTT broker connected via websockets.\nJust head over to the \ndemo\n and create a card. Configure your MQTT broker by clicking the connection state.\nThe source code can be found on \nGithub\n.\n\n\nRoll your own\n\n\nIf you feel really brave, you can \nwrite your own program\n which subscribes to OwnTracks data, but don't forget to tell us about it!\n\n\nRelated\n\n\nHere are some projects we know of which use and/or integrate OwnTracks and/or\nwhich are useful when using MQTT in general or OwnTracks in particular.\n\n\n\n\nMQTT Inspector for iOS\n, written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT.\n\n\nthe thing system\n ( \ncode\n )\n\n\nA Clojure webapp that aims to manage information gathered from OwnTracks; \nclojure-mqttitude-backend\n\n\nAn \nOwnTracks flow\n by \nGiovanni @juzam Angoli\n for Node-RED which publishes messages to \npushover.net\n upon entering or leaving a geo-fence.\n\n\nMyMQTT\n is an app for Android which enables you to subscribe and publish to an MQTT broker.\n\n\nMatthew Bordignon made a small \nWeb page which uses Websockets to display the barometer reading\n published by OwnTracks for iOS. (\nScreenshot\n.)\n\n\nPHP front \n backend for OwnTracks payloads\n\n\nOrion, an alternative to OwnTracks Recorder with powerful visualization features (\nserver\n, \nweb client\n, \ndemo\n)\n\n\nOwntracksOSM\n is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches (\nscreenshots\n).", 
            "title": "Clients"
        }, 
        {
            "location": "/guide/clients/#clients", 
            "text": "Using our OwnTracks app is cool, but what do you do with the location data the apps send (i.e.  publish ) to the MQTT broker? We have some suggestions.  You know that OwnTracks  publishes  location information to an MQTT or HTTP endpoint. The data it publishes is transferred in a particular format called  JSON , and  this is what it looks like .  When you've got your endpoint set up, and OwnTracks configured to use it, you'll want to do something useful with the data, and the following sections introduce you to some of the existing clients you can utilize for doing that.", 
            "title": "Clients"
        }, 
        {
            "location": "/guide/clients/#mosquitto_sub", 
            "text": "mosquitto_sub  is a very basic command-line client provided by the  Mosquitto project . However, it is brilliantly useful, and you can also use it for long-time collection of data by having it run in the background with  stdout  pointing to a file.  In it's most basic invocation, you have the program connect to your broker and subscribe to the topics you're interested in.  mosquitto_sub -h localhost -p 1883 -v -t 'owntracks/#'  mosquitto_sub  and it's counterpart,  mosquitto_pub  for publishing to a broker, support a slew of options. It'll be worth your while to study their  manual page .", 
            "title": "mosquitto_sub"
        }, 
        {
            "location": "/guide/clients/#recorder", 
            "text": "We recommend our very own  OwnTracks Recorder  because it's lightweight, relatively simple to set up, and because it offers a lot of features. It stores location data published by the apps by subscribing to an MQTT broker, and it enables you to access that data in a variety of formats. The best part is: it doesn't require a heavy external database of any kind.   And the best is, you can configure the Recorder to also accept the HTTP POST requests from the apps, so it's the best companion for the OwnTracks apps in HTTP mode as well.  Read  more about the Recorder .", 
            "title": "Recorder"
        }, 
        {
            "location": "/guide/clients/#mqttwarn", 
            "text": "You'll recall (we hope) the discussion on  MQTT  and the analogy with the cauldron.  mqttwarn , while not specific to OwnTracks, is another client you connect to your  MQTT broker . We think it's worth mentioning (and both Ben and JP -- the creators -- are quite pleased with what it does).  mqttwarn  lets you do things like tweet everytime OwnTracks reports a location (but do consider whether you  really  want that), send an e-mail when a loved one enters a particular region, etc.", 
            "title": "mqttwarn"
        }, 
        {
            "location": "/guide/clients/#openhab", 
            "text": "Presence detection in home automation is one of the most important pieces of the puzzle. Without it your smart home is effectively blind, and as a result can hardly be called 'smart' at all. There are very few automation rules that do not require some form of context in terms of human occupancy. Rules around security, lighting, music, even coffee machines -- all need to know if 'someone' is home before deciding whether to take action.    This is where OwnTracks steps in. In its simplest form it can be configured with waypoints (for home/work etc) that generate events whenever your phone enters/leaves these regions. These are sent to your own personal  MQTT broker  where your home automation software can react accordingly. The beauty of OwnTracks is two-fold - it is simple, you can disable the standard location reporting so all you get is the waypoint event/leave events, which is all your smart home cares about. The second is that, in  private mode , all your data is 'yours' and yours alone - there is no cloud service collecting, storing and potentially mining your data.   Read more about  openHAB and OwnTracks .", 
            "title": "openHAB"
        }, 
        {
            "location": "/guide/clients/#home-assistant", 
            "text": "Another home automation solution that can be used with OwnTracks is Home Assistant. Home Assistant allows you to track the location of people connected to your personal  MQTT broker . It has a map to show their current location and can trigger automations based on entering and leaving zones. In order to use the internal broker of Home Assistant, the MQTT protocol level has to be set to 4.   See the  demo  for an example of the map with OwnTracks devices or read more about how Home Assistant  connects to your private MQTT broker , how to  enable OwnTracks support in Home Assistant  and how to  configure automations based on zones .", 
            "title": "Home Assistant"
        }, 
        {
            "location": "/guide/clients/#owntracks-cards", 
            "text": "This is a webapp to create and edit  OwnTracks cards .\nIt can be either used to just create the JSON representation of the card, which has to be published to the MQTT broker manually. Or it can directly publish the card to an MQTT broker connected via websockets.\nJust head over to the  demo  and create a card. Configure your MQTT broker by clicking the connection state.\nThe source code can be found on  Github .", 
            "title": "OwnTracks-Cards"
        }, 
        {
            "location": "/guide/clients/#roll-your-own", 
            "text": "If you feel really brave, you can  write your own program  which subscribes to OwnTracks data, but don't forget to tell us about it!", 
            "title": "Roll your own"
        }, 
        {
            "location": "/guide/clients/#related", 
            "text": "Here are some projects we know of which use and/or integrate OwnTracks and/or\nwhich are useful when using MQTT in general or OwnTracks in particular.   MQTT Inspector for iOS , written by Christoph Krey, who also did our OwnTracks for iOS app. This is an indispensable utility for all things MQTT.  the thing system  (  code  )  A Clojure webapp that aims to manage information gathered from OwnTracks;  clojure-mqttitude-backend  An  OwnTracks flow  by  Giovanni @juzam Angoli  for Node-RED which publishes messages to  pushover.net  upon entering or leaving a geo-fence.  MyMQTT  is an app for Android which enables you to subscribe and publish to an MQTT broker.  Matthew Bordignon made a small  Web page which uses Websockets to display the barometer reading  published by OwnTracks for iOS. ( Screenshot .)  PHP front   backend for OwnTracks payloads  Orion, an alternative to OwnTracks Recorder with powerful visualization features ( server ,  web client ,  demo )  OwntracksOSM  is an Owntracks and OpenStreetMap based mapping and location sharing app for Samsung smartwatches ( screenshots ).", 
            "title": "Related"
        }, 
        {
            "location": "/guide/scenarios/", 
            "text": "Scenarios\n\n\nThere are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the \ntechnical terminology\n handy.\n\n\n\n\nThere is a bit of stuff you have to learn about in order to use OwnTracks: \nMQTT brokers\n, \ntopics\n, but the upside is that you get to use many of the neat features \nMQTT\n mode or \nHTTP\n mode come with. For example, you can set up \nfriends\n.\n\n\nHTTP mode\n\n\nIf you don't want to go to the trouble of hosting your own MQTT setup, you can use \nHTTP\n mode to publish location data to a \nHTTP server of your chosing\n, and you can also use our Recorder for doing so.\n\n\nMQTT mode\n\n\nThis is where you say \nadios!\n (or whatever you say in your language when you leave) to us, continue to use our app (still free of charge of course -- it's Open Source), and host everything yourself. And to be honest, that's \nprecisely what we think you should do\n so that you only (and the people you authorize) see where you are. That is the \nOwn\n in OwnTracks: it's \nyour own data\n and you only should see it.\n\n\nIn MQTT mode you're on your own: you \nset up and configure your MQTT broker\n, you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up.\n\n\nWhat you basically have to do is to\n\n\n\n\nset up an MQTT broker\n\n\nOptionally \nuse existing clients\n to consume OwnTracks data\n\n\nPossibly dig in and \nwrite your own client\n and do really cool stuff!\n\n\n\n\nWe urge you to resist the temptation of using \nMQTT mode\n with one of the many public brokers hosted by different organizations. While it \nis\n an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy.\n\n\nIf you need assistance, we may be able to help you on our \nTalk\n site.\n\n\nYou will now want to \nconfigure a client\n with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not \nwrite your own client\n?\n\n\nNow it's time to \ndiscuss topics\n.", 
            "title": "Scenarios"
        }, 
        {
            "location": "/guide/scenarios/#scenarios", 
            "text": "There are two basic scenarios we have for you depending on your needs. It'll help if you keep a copy of the  technical terminology  handy.   There is a bit of stuff you have to learn about in order to use OwnTracks:  MQTT brokers ,  topics , but the upside is that you get to use many of the neat features  MQTT  mode or  HTTP  mode come with. For example, you can set up  friends .", 
            "title": "Scenarios"
        }, 
        {
            "location": "/guide/scenarios/#http-mode", 
            "text": "If you don't want to go to the trouble of hosting your own MQTT setup, you can use  HTTP  mode to publish location data to a  HTTP server of your chosing , and you can also use our Recorder for doing so.", 
            "title": "HTTP mode"
        }, 
        {
            "location": "/guide/scenarios/#mqtt-mode", 
            "text": "This is where you say  adios!  (or whatever you say in your language when you leave) to us, continue to use our app (still free of charge of course -- it's Open Source), and host everything yourself. And to be honest, that's  precisely what we think you should do  so that you only (and the people you authorize) see where you are. That is the  Own  in OwnTracks: it's  your own data  and you only should see it.  In MQTT mode you're on your own: you  set up and configure your MQTT broker , you configure authentication, and then you configure your OwnTracks apps to connect to your broker. It's not particularly difficult to do, and you have full control over everything you set up.  What you basically have to do is to   set up an MQTT broker  Optionally  use existing clients  to consume OwnTracks data  Possibly dig in and  write your own client  and do really cool stuff!   We urge you to resist the temptation of using  MQTT mode  with one of the many public brokers hosted by different organizations. While it  is  an easy way out those brokers are publically accessible which means anybody can see where you are if they can identify you. Furthermore, public brokers often don't implement access control, so basically anybody can create a \"location\" update which looks as though it may be yours. Believe us: it'll drive you crazy.  If you need assistance, we may be able to help you on our  Talk  site.  You will now want to  configure a client  with which you consume the data which is published by OwnTracks, or if you're feeling very brave, why not  write your own client ?  Now it's time to  discuss topics .", 
            "title": "MQTT mode"
        }, 
        {
            "location": "/guide/apps/", 
            "text": "OwnTracks apps\n\n\nThe OwnTracks apps operate in one of two modes (discussed in \nscenarios\n), and you tell the app in which mode you want to use it.\n\n\nIn \nPrivate\n MQTT mode, you configure our iOS and Android app to access your broker, and in \nPrivate\n HTTP mode you do similarly but with an HTTP endpoint.\n\n\niOS\n\n\n\n\nAndroid\n\n\n\n\nThere are other \nclients\n you can use with OwnTracks.", 
            "title": "Apps"
        }, 
        {
            "location": "/guide/apps/#owntracks-apps", 
            "text": "The OwnTracks apps operate in one of two modes (discussed in  scenarios ), and you tell the app in which mode you want to use it.  In  Private  MQTT mode, you configure our iOS and Android app to access your broker, and in  Private  HTTP mode you do similarly but with an HTTP endpoint.", 
            "title": "OwnTracks apps"
        }, 
        {
            "location": "/guide/apps/#ios", 
            "text": "", 
            "title": "iOS"
        }, 
        {
            "location": "/guide/apps/#android", 
            "text": "There are other  clients  you can use with OwnTracks.", 
            "title": "Android"
        }, 
        {
            "location": "/guide/topics/", 
            "text": "Topics\n\n\nIf you use HTTP mode skip this chapter.\n\n\nYou now know that \nMQTT\n is a messaging protocol, and that it uses\ntopic names to label messages.  topic names can be structured into multiple\ntopic levels by separating them with a forward slash (\n/\n). topic levels are\nUTF-8 text strings, and almost any character is valid except \n/\n, \n*\n, and \n+\n.\nThe last two are used to address sets of topic names.\n\n\nThe principles during the design of the OwnTracks topic-naming scheme were\n\n\n\n\nhuman readability\n\n\ntraffic minimization\n\n\ngranular access control\n\n\n\n\ntopic name Root\n\n\nTypically an MQTT broker hosts multiple applications. To create a separate name space\nfor OwnTracks we use a topic name root as the beginning of a topic name. Per default\nthis is \nowntracks/\n, but you may choose any other root (e.g. \npeters/locations/\n) or,\nif you prefer, the empty string. In order to change the default behaviour of \nowntracks/\n\ncreate a \npersonalized configuration\n from scratch or, export\nyour current configuration, edit that and re-import to your device. On Android you trigger\nthe import function by opening the \n.otrc\n file in a file manager; on iOS by, say, opening\nthe file in Mail, Dropbox or similar app. The settings which have to be changed are\n\n\npubTopicBase\nsubTopic\n\n\n\n\nDevice name\n\n\nLocations are captured in OwnTracks by devices (e.g. your Smartphone). The\ndevice name forms the second component of the topic name. In order to avoid\nclashes in naming and to simplify subscription and authorization we decided to\nuse two topic levels\n\n\n\n\nThe user name or identifier (e.g. \npeter\n)\n\n\nThe device name (e.g. \niPhone\n)\n\n\n\n\nA typical topic name for a device would therefore be \npeter/iPhone\n. Other\ndevice naming schemes are possible and transparent to OwnTracks (e.g. using\njust one level \npeters-iPhone\n or multiple levels \naFamily/father/iPhone\n), but\nunder any one OwnTracks name root the number of levels used for device names\nhave to be the same.\n\n\nBase topic name\n\n\nCombining the topic name root and the device name result in what we call \nbase\ntopic name\n for each device (e.g. \nowntracks/peter/iPhone\n).  The devices label\ntheir location messages with the \nbase topic name\n when publishing to the MQTT\nbroker.\n\n\nSubscribing to location Messages\n\n\nGiven the structure explained above, the topic filter you can use to subscribe to the\nlocation messages of all devices is \nowntracks/+/+\n (the topic name root plus a so-called\nwild card (\n+\n) for each level of the device name.\n\n\nAdditional topic names\n\n\nFor additional communication from and to devices, OwnTracks uses topic names relative\nto the base topic name.\n\n\nDevices listen to the relative topic name \ncmd\n for commands you can publish to\nOwnTracks devices (i.e. \nowntracks/peter/iPhone/cmd\n). For example, if\nauthorized, you could request a location update from a friend's device by\npublishing an \nappropriate payload\n to said topic.\n\n\nThe output of specific OwnTracks commands is published by the device to the\nrelative topic names \nstep\n, \ndump\n, etc.\n\n\nIn addition, devices subscribe to the relative topic name \ninfo\n for information about \nother devices. Messages published with the relative topic name \ninfo\n\n(e.g. \nowntracks/peter/iPhone/info\n) contain a \ncard\n payload -- the name and\navatar of a user with which authorized users can identify, say, Peter within their OwnTracks app.\n\n\nDevices publish their \nwaypoints\n to the relative topic name\n\nwaypoint\n and the corresponding events the transition into or out of a\nwaypoint triggers, to the relative topic name \nevent\n.\n\n\nSummary\n\n\nA device (named \npeter/iPhone\n in this example) is connected to an \nMQTT\nBroker\n with the OwnTracks name Root \nowntracks\n. It publishes\nlocation messages labeled with the topic name \nowntracks/peter/iPhone\n. The\nsame device publishes \nwaypoints\n labeled as\n\nowntracks/peter/iPhone/waypoint\nand publishes to\n\nowntracks/peter/iPhone/event\n when entering or leaving a waypoint (i.e. a monitored region).\n\n\nThe same device subscribes to \nowntracks/+/+\n to receive location messages of all \nother devices it is authorized for which are connected to the same MQTT broker.\nIn addition, the device may listen to \nowntracks/+/+/event\nif the user of the devices\nwants to be informed about other users entering or leaving monitored regions. Subscribing\nto \nowntracks/+/+/info\ngives the device access to additional information about the other\ndevices.\n\n\nIf a device's owner allows other users to ad-hoc request messages from his device,\nthe device will subscribe to \nowntracks/peter/iPhone/cmd\n as well, and it will listen for OwnTracks\ncommands; responses to these commands will be published and labeled \nowntracks/peter/iPhone/dump\n,\n\nowntracks/peter/iPhone/step\n, etc.\n\n\nA full set of supported topic names and expected payloads is documented in \nour JSON API\n.\n\n\nTerms used\n\n\n\n\ntopic name\n\n\nOwnTracks topic name root\n\n\nOwnTracks device name\n\n\nOwnTracks base topic name\n\n\nrelative topic names\n\n\nOwnTracks device\n\n\nOwnTracks user\n\n\nOwnTracks command", 
            "title": "Topics"
        }, 
        {
            "location": "/guide/topics/#topics", 
            "text": "If you use HTTP mode skip this chapter.  You now know that  MQTT  is a messaging protocol, and that it uses\ntopic names to label messages.  topic names can be structured into multiple\ntopic levels by separating them with a forward slash ( / ). topic levels are\nUTF-8 text strings, and almost any character is valid except  / ,  * , and  + .\nThe last two are used to address sets of topic names.  The principles during the design of the OwnTracks topic-naming scheme were   human readability  traffic minimization  granular access control", 
            "title": "Topics"
        }, 
        {
            "location": "/guide/topics/#topic-name-root", 
            "text": "Typically an MQTT broker hosts multiple applications. To create a separate name space\nfor OwnTracks we use a topic name root as the beginning of a topic name. Per default\nthis is  owntracks/ , but you may choose any other root (e.g.  peters/locations/ ) or,\nif you prefer, the empty string. In order to change the default behaviour of  owntracks/ \ncreate a  personalized configuration  from scratch or, export\nyour current configuration, edit that and re-import to your device. On Android you trigger\nthe import function by opening the  .otrc  file in a file manager; on iOS by, say, opening\nthe file in Mail, Dropbox or similar app. The settings which have to be changed are  pubTopicBase\nsubTopic", 
            "title": "topic name Root"
        }, 
        {
            "location": "/guide/topics/#device-name", 
            "text": "Locations are captured in OwnTracks by devices (e.g. your Smartphone). The\ndevice name forms the second component of the topic name. In order to avoid\nclashes in naming and to simplify subscription and authorization we decided to\nuse two topic levels   The user name or identifier (e.g.  peter )  The device name (e.g.  iPhone )   A typical topic name for a device would therefore be  peter/iPhone . Other\ndevice naming schemes are possible and transparent to OwnTracks (e.g. using\njust one level  peters-iPhone  or multiple levels  aFamily/father/iPhone ), but\nunder any one OwnTracks name root the number of levels used for device names\nhave to be the same.", 
            "title": "Device name"
        }, 
        {
            "location": "/guide/topics/#base-topic-name", 
            "text": "Combining the topic name root and the device name result in what we call  base\ntopic name  for each device (e.g.  owntracks/peter/iPhone ).  The devices label\ntheir location messages with the  base topic name  when publishing to the MQTT\nbroker.", 
            "title": "Base topic name"
        }, 
        {
            "location": "/guide/topics/#subscribing-to-location-messages", 
            "text": "Given the structure explained above, the topic filter you can use to subscribe to the\nlocation messages of all devices is  owntracks/+/+  (the topic name root plus a so-called\nwild card ( + ) for each level of the device name.", 
            "title": "Subscribing to location Messages"
        }, 
        {
            "location": "/guide/topics/#additional-topic-names", 
            "text": "For additional communication from and to devices, OwnTracks uses topic names relative\nto the base topic name.  Devices listen to the relative topic name  cmd  for commands you can publish to\nOwnTracks devices (i.e.  owntracks/peter/iPhone/cmd ). For example, if\nauthorized, you could request a location update from a friend's device by\npublishing an  appropriate payload  to said topic.  The output of specific OwnTracks commands is published by the device to the\nrelative topic names  step ,  dump , etc.  In addition, devices subscribe to the relative topic name  info  for information about \nother devices. Messages published with the relative topic name  info \n(e.g.  owntracks/peter/iPhone/info ) contain a  card  payload -- the name and\navatar of a user with which authorized users can identify, say, Peter within their OwnTracks app.  Devices publish their  waypoints  to the relative topic name waypoint  and the corresponding events the transition into or out of a\nwaypoint triggers, to the relative topic name  event .", 
            "title": "Additional topic names"
        }, 
        {
            "location": "/guide/topics/#summary", 
            "text": "A device (named  peter/iPhone  in this example) is connected to an  MQTT\nBroker  with the OwnTracks name Root  owntracks . It publishes\nlocation messages labeled with the topic name  owntracks/peter/iPhone . The\nsame device publishes  waypoints  labeled as owntracks/peter/iPhone/waypoint and publishes to owntracks/peter/iPhone/event  when entering or leaving a waypoint (i.e. a monitored region).  The same device subscribes to  owntracks/+/+  to receive location messages of all \nother devices it is authorized for which are connected to the same MQTT broker.\nIn addition, the device may listen to  owntracks/+/+/event if the user of the devices\nwants to be informed about other users entering or leaving monitored regions. Subscribing\nto  owntracks/+/+/info gives the device access to additional information about the other\ndevices.  If a device's owner allows other users to ad-hoc request messages from his device,\nthe device will subscribe to  owntracks/peter/iPhone/cmd  as well, and it will listen for OwnTracks\ncommands; responses to these commands will be published and labeled  owntracks/peter/iPhone/dump , owntracks/peter/iPhone/step , etc.  A full set of supported topic names and expected payloads is documented in  our JSON API .", 
            "title": "Summary"
        }, 
        {
            "location": "/guide/topics/#terms-used", 
            "text": "topic name  OwnTracks topic name root  OwnTracks device name  OwnTracks base topic name  relative topic names  OwnTracks device  OwnTracks user  OwnTracks command", 
            "title": "Terms used"
        }, 
        {
            "location": "/guide/broker/", 
            "text": "MQTT broker\n\n\nAn MQTT broker is a service to which MQTT clients connect. These clients publish\ndata to specific \ntopics\n and they can subscribe to one or more \ntopics\n to receive\nmessages. A \ntopic\n is like an \"address\" for a particular message. For example,\na topic for a device that publishes a temperature reading of your living room\nmay be \ntemperature/indoors/living\n, whereas a device which publishes weather\ndata could do so to \nweather/germany/frankfurt\n. In the particular case of OwnTracks, we\nuse a topic branch called \nowntracks/username/device\n, but you can override that\nname if you prefer to. The reason we've chosen that structure is to accomodate\nfriends and family on a single broker, taking into consideration that a particular\nuser might have more than one device.\n\n\nPrivate broker\n\n\nIdeally, you set up a private broker under your control. This sounds more difficult\nthan it actually is, and there are some very nice brokers you can use free of charge\non your own infrastructure. As an example, we've written up how to install\nMosquitto on a Raspberry Pi.\n\n\nRasPi\n\n\n\n\nThe hardest bit is installing an OS, say, \nRaspbian Wheezy\n, onto an SD card, but there are many tutorials on how to do that. (Here's an example \nusing Mac OS X\n.) A basic install will suffice, and after logging in with Raspbian's default username and password, we'll get started from there. Note that the current Raspbian Wheezy mosquitto package does NOT contain the \nmosquitto_passwd\n tool. If you want to use it, make sure you install the package from a mosquitto repo:\n\n\nRoger Light, \nMosquitto\n's creator has thankfully (!) set up a few \nMosquitto repositories\n we can use to obtain the latest and greatest version, so we'll do just that. We first perform the required steps to add and activate the repository. The last step in particular can take a few moments.\n\n\ncurl -O http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key\nsudo apt-key add mosquitto-repo.gpg.key\nrm mosquitto-repo.gpg.key\ncd /etc/apt/sources.list.d/\nsudo curl -O http://repo.mosquitto.org/debian/mosquitto-$(awk -F\n[)(]+\n '/VERSION=/ {print $2}' /etc/os-release).list\nsudo apt-get update\n\n\n\n\nNow we can go ahead and install \nMosquitto\n proper. There are three packages:\n\n\n\n\nmosquitto\n is the MQTT broker (i.e. server)\n\n\nmosquitto-clients\n are the command-line clients, which I recommend you install\n\n\nDon't install \npython-mosquitto\n; if you want to do programming with Python and MQTT, we \nshow you how to do so with the Paho Python module\n.\n\n\n\n\nsudo apt-get install mosquitto mosquitto-clients\n\n\n\n\nRegrettably, as with most Debian packages, the broker is immediately started; stop it.\n\n\nsudo /etc/init.d/mosquitto stop\n\n\n\n\nThat concludes the installation of the \nMosquitto\n MQTT broker, and we'll now proceed to\nits configuration. This section is geared towards a configuration of \nMosquitto\n which will\nwork well with OwnTracks. In particular we want the following features enabled\nby default:\n\n\n\n\nConnections to the broker must be authenticated either against user/password or using client certificates.\n\n\nConnections to the broker shall also be \nTLS\n protected. This requires a (server-side) TLS certificate and key which will be configured automatically.\n\n\nACLs will restrict who may access what.\n\n\n\n\nTo create a \nmosquitto\n user database, use \nsudo mosquitto_passwd -c /etc/mosquitto/passwd \nusername\n.\n\n\nYou will be prompted to enter a password. That will be the password required to connect to the server (with the username you chose). If you want to add more users, repeat the command without \n-c\n as that will create (i.e. overwrite) the passwd file.\nAdd a config line \npassword_file /etc/mosquitto/passwd\n to \n/etc/mosquitto/mosquitto.conf\n.\n\n\nIf you want to use certificates to identify yourself to the broker and/or to TLS-encrypt the TCP session, we've got some utilities over at the \nOwnTracks repository\n which are going to automate this process for you. It's a work-in-progress (of course), but this is what \nsudo ./mosquitto-setup.sh\n looks like at the moment:\n\n\nSaving previous configuration as mosquitto.conf-20130901-133525\nGenerating a 2048 bit RSA private key\n.................................................................................................+++\n...............................+++\nwriting new private key to '/etc/mosquitto/ca.key'\n-----\nCreated CA certificate in /etc/mosquitto/ca.crt\nsubject=\n    commonName                = An MQTT broker\n    organizationName          = MQTTitude.org\n    emailAddress              = nobody@example.net\n--- Creating server key and signing request\nGenerating RSA private key, 2048 bit long modulus\n............+++\n..............+++\ne is 65537 (0x10001)\n--- Creating and signing server certificate\nSignature ok\nsubject=/CN=raspberrypi/O=MQTTitude.org/emailAddress=nobody@example.net\nGetting CA Private Key\n\n\n\n\nA CA is created together with a server key-pair with a whole bunch of \nsubjAltName\n\nsettings:\n\n\n    X509v3 Subject Alternative Name:\n        IP Address:192.168.1.189, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1, DNS:broker.example.com, DNS:foo.example.de, DNS:localhost\n\n\n\n\nCheck for a couple of broker settings in \n/etc/mosquitto/mosquitto.conf\n.\nYour mileage may vary, but you might want to set the following parameters:\n\n\nport 1883\npersistence_file mosquitto.db\nlog_dest syslog\nlog_dest stdout\nlog_dest topic\nlog_type error\nlog_type warning\nlog_type notice\nlog_type information\nconnection_messages true\nlog_timestamp true\nallow_anonymous false\npassword_file /etc/mosquitto/passwd\n\n\n\n\nWill it work? Let's start the broker manually to see what it says:\n\n\nsudo /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf\n1378042632: mosquitto version 1.2 (build date 2013-08-09 21:49:03+0100) starting\n1378042632: Config loaded from /etc/mosquitto/mosquitto.conf.\n1378042632: Opening ipv4 listen socket on port 1883.\n1378042632: Opening ipv4 listen socket on port 8883.\n1378042632: Opening ipv6 listen socket on port 8883.\n1378042632: Warning: Address family not supported by protocol\n...^C\n1378042634: mosquitto version 1.2 terminating\n1378042634: Saving in-memory database to /tmp/mosquitto.db.\n\n\n\n\nThe Mosquitto clients need to have access to a copy of the CA certificate (\nca.crt\n) and you can transport that insecurely to your clients (it's a public certificate).\n\n\nmosquitto_pub  --cafile ca.crt -h 127.0.0.1 -p 8883  ...\n\n\n\n\nThat's it for the moment. \n\n\nTesting\n\n\nOnce you've chosen an MQTT broker, make sure you feel comfortable with the\nutilities it provides to subscribe and publish to topics. We recommend the\n\nMosquitto\n utilities for doing so.\n\n\nFor example, to subscribe to all topics prefixed by \nowntracks\n on your broker:\n\n\nmosquitto_sub -h hostname -p 1883 -v -t 'owntracks/#'\n\n\n\n\n(Note that the hash symbol has to be quoted in the shell which is why we've put\nthe whole topic branch in single quotes.)\n\n\nIn another screen you could publish a test message:\n\n\nmosquitto_pub -h hostname -p 1883 -t 'owntracks/test' -m 'hello world'\n\n\n\n\nand in the first screen you'd see the topic name followed by a space and the message\n\npayload\n.\n\n\nOnce you feel comfortable with what is going on, you should consider adding \nTLS\n.\n\n\nBridging\n\n\nIf you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up \nhow you can bridge brokers\n.\n\n\nLogging\n\n\nBefore doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening.\n\n\nMosquitto typically logs via \nsyslog\n, and \nsyslog\n's configuration defines where the log messages are actually written to. Your \nsyslog\n may be called \nsyslog\n, \nrsyslog\n, \nsyslog-ng\n, or anything else for that matter. In case of doubt, check the files in \n/var/log\n; one of them \nought\n to have what you're looking for (e..g \nmessages\n, \nsyslog\n, \nlocalmessages\n, or even \ndebugmessages\n).\n\n\nMosquitto typically logs each connection request, a publish, a subscribe request, etc. (Read the \nmanpage for \nmosquitto.conf\n to learn how to configure logging.\n\n\nA successful publish of an OwnTracks location could look somewhat like this:\n\n\nmosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes))\nmosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7)\nmosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7)\nmosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7)\n\n\n\n\nACLs\n\n\nYou will definitely want to set up Access Control Lists (ACLs) on your broker so that you can control who may see what. As an example, suppose Jane (username \njjolie\n) should be able to publish to her \nOwnTracks MQTT topics\n and Fred (username \nfred\n) should be allowed to see Jane's location, we could configure something like this:\n\n\nuser jjolie\ntopic owntracks/jjolie/#\n\nuser fred\ntopic read owntracks/jjolie/5s\ntopic owntracks/fred/nexus/#\n\n\n\n\nFirewall\n\n\nIf you want to run your \nPrivate\n broker it's possibly going to be at home under your desk (or is it in your small office?). Be that as it may, how does an OwnTracks app reach (network-wise) that broker?  Chances are you have some form of router which connects the local network in your home to the Internet.\n\n\nOwnTracks runs on the device which is in your pocket or your purse, or wherever you placed it, and it must be able to connect to your MQTT broker, but it cannot: your router hopefully has a firewall configured on it which will allow outgoing (from your home outwards) connections, but it is sure to not allow incoming connections. We must change that, at least for MQTT, and we're going to assume you've configured TLS, i.e. your broker is (also) listening on TCP port 8883\n\n\nWhat you need to do to get this working is to reconfigure your router to allow incoming TCP traffic on port 8883 and to hand that off to the TCP/IP address of your MQTT broker. The exact details on how to do that vary from vendor to vendor, but a close look at the documentation of your router should show you how to do that.\n\n\nWhat is also likely, or at least possible, is that your home doesn't have a fixed TCP/IP address, but one which changes periodically. The OwnTracks apps won't be able to find your home then, will they? If you keep \"moving\" (i.e changing addresses).\n\n\nA service which is typically (if maybe incorrectly) called dynamic DNS comes to the rescue. These services allow you to configure a DNS name (e.g. \nfreds-router.example.org\n) which points to the changing IP address of your router.\n\n\nOnce you've completed those steps, configure the OwnTracks apps to use the shiny new DNS name and TCP port number (8883) and you should be all set.\n\n\nOwnTracks\n\n\nSo, you've configured your broker and you are familiar with the \nmosquitto\n command-line\nclients, so now it's time to see if you can \nget OwnTracks to speak to your broker\n.", 
            "title": "Broker"
        }, 
        {
            "location": "/guide/broker/#mqtt-broker", 
            "text": "An MQTT broker is a service to which MQTT clients connect. These clients publish\ndata to specific  topics  and they can subscribe to one or more  topics  to receive\nmessages. A  topic  is like an \"address\" for a particular message. For example,\na topic for a device that publishes a temperature reading of your living room\nmay be  temperature/indoors/living , whereas a device which publishes weather\ndata could do so to  weather/germany/frankfurt . In the particular case of OwnTracks, we\nuse a topic branch called  owntracks/username/device , but you can override that\nname if you prefer to. The reason we've chosen that structure is to accomodate\nfriends and family on a single broker, taking into consideration that a particular\nuser might have more than one device.", 
            "title": "MQTT broker"
        }, 
        {
            "location": "/guide/broker/#private-broker", 
            "text": "Ideally, you set up a private broker under your control. This sounds more difficult\nthan it actually is, and there are some very nice brokers you can use free of charge\non your own infrastructure. As an example, we've written up how to install\nMosquitto on a Raspberry Pi.", 
            "title": "Private broker"
        }, 
        {
            "location": "/guide/broker/#raspi", 
            "text": "The hardest bit is installing an OS, say,  Raspbian Wheezy , onto an SD card, but there are many tutorials on how to do that. (Here's an example  using Mac OS X .) A basic install will suffice, and after logging in with Raspbian's default username and password, we'll get started from there. Note that the current Raspbian Wheezy mosquitto package does NOT contain the  mosquitto_passwd  tool. If you want to use it, make sure you install the package from a mosquitto repo:  Roger Light,  Mosquitto 's creator has thankfully (!) set up a few  Mosquitto repositories  we can use to obtain the latest and greatest version, so we'll do just that. We first perform the required steps to add and activate the repository. The last step in particular can take a few moments.  curl -O http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key\nsudo apt-key add mosquitto-repo.gpg.key\nrm mosquitto-repo.gpg.key\ncd /etc/apt/sources.list.d/\nsudo curl -O http://repo.mosquitto.org/debian/mosquitto-$(awk -F [)(]+  '/VERSION=/ {print $2}' /etc/os-release).list\nsudo apt-get update  Now we can go ahead and install  Mosquitto  proper. There are three packages:   mosquitto  is the MQTT broker (i.e. server)  mosquitto-clients  are the command-line clients, which I recommend you install  Don't install  python-mosquitto ; if you want to do programming with Python and MQTT, we  show you how to do so with the Paho Python module .   sudo apt-get install mosquitto mosquitto-clients  Regrettably, as with most Debian packages, the broker is immediately started; stop it.  sudo /etc/init.d/mosquitto stop  That concludes the installation of the  Mosquitto  MQTT broker, and we'll now proceed to\nits configuration. This section is geared towards a configuration of  Mosquitto  which will\nwork well with OwnTracks. In particular we want the following features enabled\nby default:   Connections to the broker must be authenticated either against user/password or using client certificates.  Connections to the broker shall also be  TLS  protected. This requires a (server-side) TLS certificate and key which will be configured automatically.  ACLs will restrict who may access what.   To create a  mosquitto  user database, use  sudo mosquitto_passwd -c /etc/mosquitto/passwd  username .  You will be prompted to enter a password. That will be the password required to connect to the server (with the username you chose). If you want to add more users, repeat the command without  -c  as that will create (i.e. overwrite) the passwd file.\nAdd a config line  password_file /etc/mosquitto/passwd  to  /etc/mosquitto/mosquitto.conf .  If you want to use certificates to identify yourself to the broker and/or to TLS-encrypt the TCP session, we've got some utilities over at the  OwnTracks repository  which are going to automate this process for you. It's a work-in-progress (of course), but this is what  sudo ./mosquitto-setup.sh  looks like at the moment:  Saving previous configuration as mosquitto.conf-20130901-133525\nGenerating a 2048 bit RSA private key\n.................................................................................................+++\n...............................+++\nwriting new private key to '/etc/mosquitto/ca.key'\n-----\nCreated CA certificate in /etc/mosquitto/ca.crt\nsubject=\n    commonName                = An MQTT broker\n    organizationName          = MQTTitude.org\n    emailAddress              = nobody@example.net\n--- Creating server key and signing request\nGenerating RSA private key, 2048 bit long modulus\n............+++\n..............+++\ne is 65537 (0x10001)\n--- Creating and signing server certificate\nSignature ok\nsubject=/CN=raspberrypi/O=MQTTitude.org/emailAddress=nobody@example.net\nGetting CA Private Key  A CA is created together with a server key-pair with a whole bunch of  subjAltName \nsettings:      X509v3 Subject Alternative Name:\n        IP Address:192.168.1.189, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1, DNS:broker.example.com, DNS:foo.example.de, DNS:localhost  Check for a couple of broker settings in  /etc/mosquitto/mosquitto.conf .\nYour mileage may vary, but you might want to set the following parameters:  port 1883\npersistence_file mosquitto.db\nlog_dest syslog\nlog_dest stdout\nlog_dest topic\nlog_type error\nlog_type warning\nlog_type notice\nlog_type information\nconnection_messages true\nlog_timestamp true\nallow_anonymous false\npassword_file /etc/mosquitto/passwd  Will it work? Let's start the broker manually to see what it says:  sudo /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf\n1378042632: mosquitto version 1.2 (build date 2013-08-09 21:49:03+0100) starting\n1378042632: Config loaded from /etc/mosquitto/mosquitto.conf.\n1378042632: Opening ipv4 listen socket on port 1883.\n1378042632: Opening ipv4 listen socket on port 8883.\n1378042632: Opening ipv6 listen socket on port 8883.\n1378042632: Warning: Address family not supported by protocol\n...^C\n1378042634: mosquitto version 1.2 terminating\n1378042634: Saving in-memory database to /tmp/mosquitto.db.  The Mosquitto clients need to have access to a copy of the CA certificate ( ca.crt ) and you can transport that insecurely to your clients (it's a public certificate).  mosquitto_pub  --cafile ca.crt -h 127.0.0.1 -p 8883  ...  That's it for the moment.", 
            "title": "RasPi"
        }, 
        {
            "location": "/guide/broker/#testing", 
            "text": "Once you've chosen an MQTT broker, make sure you feel comfortable with the\nutilities it provides to subscribe and publish to topics. We recommend the Mosquitto  utilities for doing so.  For example, to subscribe to all topics prefixed by  owntracks  on your broker:  mosquitto_sub -h hostname -p 1883 -v -t 'owntracks/#'  (Note that the hash symbol has to be quoted in the shell which is why we've put\nthe whole topic branch in single quotes.)  In another screen you could publish a test message:  mosquitto_pub -h hostname -p 1883 -t 'owntracks/test' -m 'hello world'  and in the first screen you'd see the topic name followed by a space and the message payload .  Once you feel comfortable with what is going on, you should consider adding  TLS .", 
            "title": "Testing"
        }, 
        {
            "location": "/guide/broker/#bridging", 
            "text": "If you want to connect two (or more) brokers (e.g. yours and that of your friend) you can, and we've written up  how you can bridge brokers .", 
            "title": "Bridging"
        }, 
        {
            "location": "/guide/broker/#logging", 
            "text": "Before doing anything else, please consult the manual to determine where your Mosquitto logs are being written to. It's hard stabbing around in the dark when a glance at a log file can give you valuable tips on what is actually happening.  Mosquitto typically logs via  syslog , and  syslog 's configuration defines where the log messages are actually written to. Your  syslog  may be called  syslog ,  rsyslog ,  syslog-ng , or anything else for that matter. In case of doubt, check the files in  /var/log ; one of them  ought  to have what you're looking for (e..g  messages ,  syslog ,  localmessages , or even  debugmessages ).  Mosquitto typically logs each connection request, a publish, a subscribe request, etc. (Read the  manpage for  mosquitto.conf  to learn how to configure logging.  A successful publish of an OwnTracks location could look somewhat like this:  mosquitto[1366]: Received PUBLISH from jane-5s-m-o (d0, q2, r1, m7, 'owntracks/jane/5s', ... (159 bytes))\nmosquitto[1366]: Sending PUBREC to jane-5s-m-o (Mid: 7)\nmosquitto[1366]: Received PUBREL from jane-5s-m-o (Mid: 7)\nmosquitto[1366]: Sending PUBCOMP to jane-5s-m-o (Mid: 7)", 
            "title": "Logging"
        }, 
        {
            "location": "/guide/broker/#acls", 
            "text": "You will definitely want to set up Access Control Lists (ACLs) on your broker so that you can control who may see what. As an example, suppose Jane (username  jjolie ) should be able to publish to her  OwnTracks MQTT topics  and Fred (username  fred ) should be allowed to see Jane's location, we could configure something like this:  user jjolie\ntopic owntracks/jjolie/#\n\nuser fred\ntopic read owntracks/jjolie/5s\ntopic owntracks/fred/nexus/#", 
            "title": "ACLs"
        }, 
        {
            "location": "/guide/broker/#firewall", 
            "text": "If you want to run your  Private  broker it's possibly going to be at home under your desk (or is it in your small office?). Be that as it may, how does an OwnTracks app reach (network-wise) that broker?  Chances are you have some form of router which connects the local network in your home to the Internet.  OwnTracks runs on the device which is in your pocket or your purse, or wherever you placed it, and it must be able to connect to your MQTT broker, but it cannot: your router hopefully has a firewall configured on it which will allow outgoing (from your home outwards) connections, but it is sure to not allow incoming connections. We must change that, at least for MQTT, and we're going to assume you've configured TLS, i.e. your broker is (also) listening on TCP port 8883  What you need to do to get this working is to reconfigure your router to allow incoming TCP traffic on port 8883 and to hand that off to the TCP/IP address of your MQTT broker. The exact details on how to do that vary from vendor to vendor, but a close look at the documentation of your router should show you how to do that.  What is also likely, or at least possible, is that your home doesn't have a fixed TCP/IP address, but one which changes periodically. The OwnTracks apps won't be able to find your home then, will they? If you keep \"moving\" (i.e changing addresses).  A service which is typically (if maybe incorrectly) called dynamic DNS comes to the rescue. These services allow you to configure a DNS name (e.g.  freds-router.example.org ) which points to the changing IP address of your router.  Once you've completed those steps, configure the OwnTracks apps to use the shiny new DNS name and TCP port number (8883) and you should be all set.", 
            "title": "Firewall"
        }, 
        {
            "location": "/guide/broker/#owntracks", 
            "text": "So, you've configured your broker and you are familiar with the  mosquitto  command-line\nclients, so now it's time to see if you can  get OwnTracks to speak to your broker .", 
            "title": "OwnTracks"
        }, 
        {
            "location": "/guide/bridge/", 
            "text": "Bridging\n\n\nIn order to profit from the \nFriends feature\n in\nOwnTracks, all contacts you want to be able to track on your your device must\nshare a broker, but that can be difficult if both you and your friend\n(henceforce \"Jane\" in the examples that follow) also use your brokers for other\npurposes.\n\n\nMosquitto\n (and some other \nMQTT\n brokers) have a feature called bridging\nwhich basically lets you connect two (or more) brokers together.\n\n\nLet's assume that you and Jane want to see each other's location updates while\nmaintaining a connection from your devices to your respective MQTT brokers at\nhome. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those.\n\n\n\n\nWhat will happen?\n\n\nSetting up a bridge is not difficult, but there are some things we have to keep in mind.  In this example, we'll assume the following:\n\n\n\n\nYour broker will initiate a connection to Jane's broker\n\n\nYou'll be using \nTLS\n to protect credentials and data in transit\n\n\nJane has given you (e.g. via e-mail) a copy of her TLS CA certificate\n\n\nJane has set up an ACL on her \nMosquitto\n broker to ensure you have access only to her OwnTracks location data and nothing else.\n\n\nJane has a username and password for your broker to use when connecting to her broker, and she's given you both.\n\n\nJane has a device called \nnexus7\n and she publishes location updates to \nher\n broker at \nowntracks/jane/nexus7\n.\n\n\nYou have an iPhone and want to share your location data with Jane. You publish (on your broker) to \nowntracks/john/iphone\n.\n\n\n\n\nHere's what you configure \non your broker\n's \nmosquitto.conf\n:\n\n\n# Bridge to Jane\nconnection br-me-to-jane\nbridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt\nbridge_insecure false\naddress jane.example.org:8883\ncleansession false\nclientid br-john-jane\nstart_type automatic\nusername john\npassword s3cr1t\nnotifications false\ntry_private true\ntopic nexus7 in 2 owntracks/jane/ owntracks/jane/\ntopic iphone out 2 owntracks/john/ owntracks/john/\n\n\n\n\nThese last two lines define which topic branches will be published (\nout\n) and\nwhich will be subscribed to (\nin\n) from the point of view of your broker. There\nare a lot of things you can tweak in this configuration, but this is should get\nyou started.\n\n\nPublishes\n\n\nWhen your device publishes location data to your broker, it will publish the single topic \nowntracks/john/iphone\n to Jane's broker. Conversely, as your broker is now subscribed to Jane's at \nowntracks/jane/nexus7\n, it will receive Jane's location data and re-publish that to your connected device.\n\n\nEvents\n\n\nOwnTracks uses more than just a single topic per user \nas documented\n. This means we must add more \ntopic\n statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location \nnow\n).\n\n\nAssuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes \nin\n to our broker. The second line is new: it bridges Jane's \nnexus7\n events into our broker.\n\n\ntopic nexus7 in 2 owntracks/jane/ owntracks/jane/\ntopic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/\n\n\n\n\nCMD\n\n\nTapping on OwnTrack's \nrequest location update\n publishes a \ncmd\n to the destination device, so we bridge that topic \nout\n towards Jane's broker:\n\n\ntopic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/\n\n\n\n\nMQTTitude\n\n\nLet's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration:\n\n\ntopic # in 2 owntracks/ mqttitude/\n\n\n\n\nWhat this does is: your bridge subscribes to the \nremote\n topic \nmqttitude/#\n and all received messages will be republished at \nowntracks/\n on \nyour\n broker (note the \nin\n direction). \n\n\nNeat, eh? \n\n\nConsult the manual page for\n\nmosquitto.conf\n for more\ndetails.", 
            "title": "Bridging"
        }, 
        {
            "location": "/guide/bridge/#bridging", 
            "text": "In order to profit from the  Friends feature  in\nOwnTracks, all contacts you want to be able to track on your your device must\nshare a broker, but that can be difficult if both you and your friend\n(henceforce \"Jane\" in the examples that follow) also use your brokers for other\npurposes.  Mosquitto  (and some other  MQTT  brokers) have a feature called bridging\nwhich basically lets you connect two (or more) brokers together.  Let's assume that you and Jane want to see each other's location updates while\nmaintaining a connection from your devices to your respective MQTT brokers at\nhome. In other words, you will use your broker, whereas Jane connects to her broker because, e.g. she has private contacts who use her broker, but she doesn't want you to have access to those.", 
            "title": "Bridging"
        }, 
        {
            "location": "/guide/bridge/#what-will-happen", 
            "text": "Setting up a bridge is not difficult, but there are some things we have to keep in mind.  In this example, we'll assume the following:   Your broker will initiate a connection to Jane's broker  You'll be using  TLS  to protect credentials and data in transit  Jane has given you (e.g. via e-mail) a copy of her TLS CA certificate  Jane has set up an ACL on her  Mosquitto  broker to ensure you have access only to her OwnTracks location data and nothing else.  Jane has a username and password for your broker to use when connecting to her broker, and she's given you both.  Jane has a device called  nexus7  and she publishes location updates to  her  broker at  owntracks/jane/nexus7 .  You have an iPhone and want to share your location data with Jane. You publish (on your broker) to  owntracks/john/iphone .   Here's what you configure  on your broker 's  mosquitto.conf :  # Bridge to Jane\nconnection br-me-to-jane\nbridge_cafile /etc/mosquitto/jane/JANE-OwnTracks-ca.crt\nbridge_insecure false\naddress jane.example.org:8883\ncleansession false\nclientid br-john-jane\nstart_type automatic\nusername john\npassword s3cr1t\nnotifications false\ntry_private true\ntopic nexus7 in 2 owntracks/jane/ owntracks/jane/\ntopic iphone out 2 owntracks/john/ owntracks/john/  These last two lines define which topic branches will be published ( out ) and\nwhich will be subscribed to ( in ) from the point of view of your broker. There\nare a lot of things you can tweak in this configuration, but this is should get\nyou started.", 
            "title": "What will happen?"
        }, 
        {
            "location": "/guide/bridge/#publishes", 
            "text": "When your device publishes location data to your broker, it will publish the single topic  owntracks/john/iphone  to Jane's broker. Conversely, as your broker is now subscribed to Jane's at  owntracks/jane/nexus7 , it will receive Jane's location data and re-publish that to your connected device.", 
            "title": "Publishes"
        }, 
        {
            "location": "/guide/bridge/#events", 
            "text": "OwnTracks uses more than just a single topic per user  as documented . This means we must add more  topic  statements to our broker (and Jane to her broker) if we additionally want to support transition events (e.g. when did Jane leave home?) and outgoing commands (e.g. tell Jane's device to report its location  now ).  Assuming Jane allows this (by configuring appropriate ACLs on her broker), we add one or more of the following. The first line we already had: it bridges Jane's location publishes  in  to our broker. The second line is new: it bridges Jane's  nexus7  events into our broker.  topic nexus7 in 2 owntracks/jane/ owntracks/jane/\ntopic event in 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/", 
            "title": "Events"
        }, 
        {
            "location": "/guide/bridge/#cmd", 
            "text": "Tapping on OwnTrack's  request location update  publishes a  cmd  to the destination device, so we bridge that topic  out  towards Jane's broker:  topic cmd out 2 owntracks/jane/nexus7/ owntracks/jane/nexus7/  MQTTitude  Let's assume for the moment that you're running a broker with a number of connected OwnTracks clients, some of which are still publishing to the \"old\" topic branch at `mqttitude/', but you want to \"assimilate\" these clients into your environment without having to force them to rename the topic to which they publish. You can easily do that in Mosquitto, by adding the following line to your bridge configuration:  topic # in 2 owntracks/ mqttitude/  What this does is: your bridge subscribes to the  remote  topic  mqttitude/#  and all received messages will be republished at  owntracks/  on  your  broker (note the  in  direction).   Neat, eh?   Consult the manual page for mosquitto.conf  for more\ndetails.", 
            "title": "CMD"
        }, 
        {
            "location": "/guide/waypoints/", 
            "text": "Waypoints\n\n\nIf you've configured a geo-fence, a \nlocation\n message will\ncontain the elements:\n\n\n\n\nrad\nius (if its value is greater than 0)\n\n\ndesc\nription with the name you set for the waypoint\n\n\nevent\n with a value of \n\"enter\"\n or \n\"leave\"\n, depending on\n   whether the device is entering or leaving a configured region, respectively.\n\n\n\n\nIf you set up a waypoint, the app publishes that waypoint (without the retain flag,\nirrespective of your general preference) to the base topic with \n/waypoint\n\ntacked onto the topic (e.g. \nowntracks/\nuser\n/\ndevice\n/waypoint\n) with the\npayload for \n_type=waypoint\n as specified in the \nJSON page\n.\n\n\nWhen you set up a waypoint (with a \ndesc\nription and a \nrad\nius), this\nwaypoint is published to the broker with the current time stamp. If you update\nthe waypoint definition on the device at a later stage, the waypoint is\nre-published, with the \noriginal\n timestamp, but with possibly new\n\ndesc\nription and/or \nrad\nius. To be precise, the \ntst\n timestamp is used as an\nidentifier of the waypoint even if it is later modified on the device.\n\n\nSubscribers to the broker (our apps and any other program) can avoid getting\nwaypoints by subscribing to, say, \nowntracks/+/+\n; also broker ACLs can\nprohibit access to \nowntracks/+/+/waypoint\n for particular users if so desired.\nConversely, all messages published by the apps (\nlocation\n and \nwaypoint\n) are\navailable with a subscription to \nowntracks/#\n.\n\n\nThe OwnTracks apps may keep track of waypoints, e.g. for displaying to users.", 
            "title": "Waypoints"
        }, 
        {
            "location": "/guide/waypoints/#waypoints", 
            "text": "If you've configured a geo-fence, a  location  message will\ncontain the elements:   rad ius (if its value is greater than 0)  desc ription with the name you set for the waypoint  event  with a value of  \"enter\"  or  \"leave\" , depending on\n   whether the device is entering or leaving a configured region, respectively.   If you set up a waypoint, the app publishes that waypoint (without the retain flag,\nirrespective of your general preference) to the base topic with  /waypoint \ntacked onto the topic (e.g.  owntracks/ user / device /waypoint ) with the\npayload for  _type=waypoint  as specified in the  JSON page .  When you set up a waypoint (with a  desc ription and a  rad ius), this\nwaypoint is published to the broker with the current time stamp. If you update\nthe waypoint definition on the device at a later stage, the waypoint is\nre-published, with the  original  timestamp, but with possibly new desc ription and/or  rad ius. To be precise, the  tst  timestamp is used as an\nidentifier of the waypoint even if it is later modified on the device.  Subscribers to the broker (our apps and any other program) can avoid getting\nwaypoints by subscribing to, say,  owntracks/+/+ ; also broker ACLs can\nprohibit access to  owntracks/+/+/waypoint  for particular users if so desired.\nConversely, all messages published by the apps ( location  and  waypoint ) are\navailable with a subscription to  owntracks/# .  The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.", 
            "title": "Waypoints"
        }, 
        {
            "location": "/guide/beacons/", 
            "text": "iBeacons\n\n\n\n\nWhat is an iBeacon?\n\n\nAn iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement.\n\n\nIf you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received.\n\n\nWhat you can do with iBeacons in OwnTracks\n\n\nThis data is detected by your OwnTracks iOS device and can be used for region monitoring.\n\n\n\n\n\n\nUse an iBeacon to get your exact location\n\nPosition an iBeacon in your study and get enter- and leave-events from that room.\n\n\n\n\n\n\nUse an iBeacon to connect yourself with a vehicle\n\nEquip your car with an iBeacon and monitor how much time you spend commuting.\nAlways see where you parked your car.\n\n\n\n\n\n\nUse an iBeacon to track a valuable accessory\n\nFit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind.\n\n\n\n\n\n\nFull feature set is \nhere\n.", 
            "title": "Beacons"
        }, 
        {
            "location": "/guide/beacons/#ibeacons", 
            "text": "", 
            "title": "iBeacons"
        }, 
        {
            "location": "/guide/beacons/#what-is-an-ibeacon", 
            "text": "An iBeacon is a small Bluetooth device (Bluetooth Low Energy - BLE, Bluetooth 4.0) which sends out it's identification regularily. The iBeacon standard was introduced by Apple Inc. in 2013. It is supported by iOS. iBeacons can be purchased as standalone devices or to be used in connection with computer equipement.  If you position 3/4 iBeacons in a room, your 2/3-dimensional position can be calculated based on the signal strengths received.", 
            "title": "What is an iBeacon?"
        }, 
        {
            "location": "/guide/beacons/#what-you-can-do-with-ibeacons-in-owntracks", 
            "text": "This data is detected by your OwnTracks iOS device and can be used for region monitoring.    Use an iBeacon to get your exact location \nPosition an iBeacon in your study and get enter- and leave-events from that room.    Use an iBeacon to connect yourself with a vehicle \nEquip your car with an iBeacon and monitor how much time you spend commuting.\nAlways see where you parked your car.    Use an iBeacon to track a valuable accessory \nFit an iBeacon to your keys/luggage/expensive equipement and get alarmed when you leave them behind.    Full feature set is  here .", 
            "title": "What you can do with iBeacons in OwnTracks"
        }, 
        {
            "location": "/features/comparison/", 
            "text": "iOS / Android compared\n\n\nThe OwnTracks \nAndroid\n and \niOS\n apps try to be on par as far as the list\nof supported features is concernened. This table summarizes the current status.\n\n\n\n\n\n\n\n\nFeature\n\n\niOS\n\n\nAndroid\n\n\n\n\n\n\n\n\n\n\nMQTT mode\n\n\nY\n\n\nY\n\n\n\n\n\n\nHTTP mode\n\n\nY\n\n\nY\n\n\n\n\n\n\nLocation reporting\n\n\nY\n\n\nY\n\n\n\n\n\n\nTLS\n with system certificate\n\n\nY\n\n\nY\n\n\n\n\n\n\nPlain connections (no TLS)\n\n\nY\n\n\nY\n\n\n\n\n\n\nUsername/password authentication\n\n\nY\n\n\nY\n\n\n\n\n\n\nReconnection to broker\n\n\nY\n\n\nY\n\n\n\n\n\n\nAutomatic PUB after move\n\n\nY\n\n\nY\n\n\n\n\n\n\nAutomatic PUB after time\n\n\nY\n\n\nY\n\n\n\n\n\n\nMap with marker\n\n\nY\n\n\nY\n\n\n\n\n\n\nReverse geocoding on map\n\n\nY\n\n\nY\n\n\n\n\n\n\nAccuracy of last-known loc\n\n\nY\n\n\nY\n\n\n\n\n\n\nButton for manual publish\n\n\nY\n\n\nY\n\n\n\n\n\n\nConfigurable settings\n\n\nY\n\n\nY\n\n\n\n\n\n\nMove mode\n\n\nY\n\n\nY\n\n\n\n\n\n\nFriends list\n\n\nY\n\n\nY\n\n\n\n\n\n\nGeofencing\n\n\nY\n\n\nY\n\n\n\n\n\n\nWaypoints\n\n\nY\n\n\nY\n\n\n\n\n\n\nLocation data (payload) \npublished as JSON\n\n\nY\n\n\nY\n\n\n\n\n\n\nRemote configuration\n\n\nY\n\n\nY\n\n\n\n\n\n\niBeacons\n\n\nY\n\n\n\n\n\n\n\n\nStep-counting, a.k.a pedometer\n\n\nY\n\n\n\n\n\n\n\n\nPayload encryption\n\n\nY\n\n\nY\n\n\n\n\n\n\n\n\nAndroid\n\n\n\n\n\n\nThe broker connection works well with:\n\n\n\n\n\n\nNo TLS (i.e. plain)\n\n\n\n\nTLS with Android system certificate authorities\n\n\nTLS with side-loaded user-provided self signed certificate authorities \n\n\nTLS with client certificates\n\n\n\n\nUsername/password authentication to broker.\n\n\n\n\n\n\nAutomatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is avaiable. \n\n\n\n\n\n\nDisplay of a marker at which the app believes the user to be at\n  (lastKnownLocation)\n\n\n\n\n\n\nReverse geo coding that displays the address of lastKnownLocation\n\n\n\n\n\n\nAccuracy of lastKnownLocation \n\n\n\n\n\n\nButton to manually publish lastKnownLocation\n\n\n\n\n\n\niOS\n\n\n\n\n\n\nRuns on iPhones and iPads as an iPhone app. Not tested on iPods.\n\n\n\n\n\n\nMonitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \n    \"significant location changes\" (\n500m)) or as described in Move Mode below.\n    In addition version \n= 5.3 supports circular region monitoring (aka geo fences).\n    In addition version \n= 7.7 supports iBeacon region monitoring and ranging.\n\n\n\n\n\n\npublishes this locations via MQTT to the configured server while in foreground and background.\n\n\n\n\n\n\nThe current location can be sent (a.k.a. published) on request.", 
            "title": "Comparison"
        }, 
        {
            "location": "/features/comparison/#ios-android-compared", 
            "text": "The OwnTracks  Android  and  iOS  apps try to be on par as far as the list\nof supported features is concernened. This table summarizes the current status.     Feature  iOS  Android      MQTT mode  Y  Y    HTTP mode  Y  Y    Location reporting  Y  Y    TLS  with system certificate  Y  Y    Plain connections (no TLS)  Y  Y    Username/password authentication  Y  Y    Reconnection to broker  Y  Y    Automatic PUB after move  Y  Y    Automatic PUB after time  Y  Y    Map with marker  Y  Y    Reverse geocoding on map  Y  Y    Accuracy of last-known loc  Y  Y    Button for manual publish  Y  Y    Configurable settings  Y  Y    Move mode  Y  Y    Friends list  Y  Y    Geofencing  Y  Y    Waypoints  Y  Y    Location data (payload)  published as JSON  Y  Y    Remote configuration  Y  Y    iBeacons  Y     Step-counting, a.k.a pedometer  Y     Payload encryption  Y  Y     Android    The broker connection works well with:    No TLS (i.e. plain)   TLS with Android system certificate authorities  TLS with side-loaded user-provided self signed certificate authorities   TLS with client certificates   Username/password authentication to broker.    Automatic publishes at configurable maximum intervals under the condition that the devices moved the specified number of meters. Publishes may occur earlier if a new location is avaiable.     Display of a marker at which the app believes the user to be at\n  (lastKnownLocation)    Reverse geo coding that displays the address of lastKnownLocation    Accuracy of lastKnownLocation     Button to manually publish lastKnownLocation    iOS    Runs on iPhones and iPads as an iPhone app. Not tested on iPods.    Monitors \"significant location changes\" as defined by Apple Inc. (about 5 minutes AND \n    \"significant location changes\" ( 500m)) or as described in Move Mode below.\n    In addition version  = 5.3 supports circular region monitoring (aka geo fences).\n    In addition version  = 7.7 supports iBeacon region monitoring and ranging.    publishes this locations via MQTT to the configured server while in foreground and background.    The current location can be sent (a.k.a. published) on request.", 
            "title": "iOS / Android compared"
        }, 
        {
            "location": "/features/ios/", 
            "text": "Startup\n\n\nAfter \ndownloading and installing the iPhone/iPad app\n, start it\nup.\n\n\nThe first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location.\n\n\nSettings\n\n\nAccess settings and the individual modes by pressing on the \nI\n on the top left.\n\n\nFriends\n\n\nThe Friends feature shows self and all Friends published by the server,\ntheir picture or OwnTracks default icon, and their last location.  Tapping on\nthe entry switches back to map centered on friend's last location.\n\n\nThe first time you launch the app you'll also be asked whether it may access your\ncontacts data, which you should allow. (If you change your mind later, \nPrivacy\n in\n\nGeneral settings\n allows you to disable the feature.)\n\n\nTapping on an location entry centers the map on the selected location.\n\n\nNo geo-coding is done automatically in the background to limit mobile data usage.\n\n\nLocation indicators and friendly faces\n\n\nThe locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic.\n\n\nA red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds\nas good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h.\n\n\nA small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement)  with the 12 o'clock position meaning North.\n\n\nIf your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the \nFriends\n list, as soon as a location update for Jane is seen by the app.\n\n\nRegion Monitoring and Waypoints\n\n\nFor all manually published locations, a description, a region radius and a share flag can be edited.\n\n\nSetting the description of a location helps you to remember places.\n\n\nIf a description is entered and the share flag set, the location is published to the MQTT broker as a \nwaypoint\n once.\n\n\nIf the description is non-empty and a radius \n 0 (meters) is set, the app starts monitoring the circular region around the coordinate. A region may be 'waypoint'.\nThe regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish.\n\n\nIf the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959'\nmonitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant.\n\n\nEverytime the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker.\n\n\nUse cases:\n* Define a \nhome\n region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m.\n* Share your favorite places with your friends (\"Best Sushi in Town\").\n* Keep a private note (\"Parked Car here\").\n* Use iBeacons to accurately report enter/leave events for your home\n* Use iBeacons to publish enter/leave events for individual rooms/floors in your home\n\n\nSee also \nWaypoints\n.\n\n\nRegion monitoring (a.k.a. Geo Fences)\n\n\nIf the waypoint description is non-empty and a radius \n 0 (meters) is set, the\napp starts monitoring the circular region around the specified coordinates. \nRegions are shown on the map as blue-ish circles. If the\ndevice is within a region, the corresponding circle turns red-ish. Every time\nthe devices enters or leaves a monitored region, an additional location message\nis published to the MQTT broker, specifying whether the device is entering or leaving\nsaid region.\n\n\nFor example, you can define a home region to ensure that the device publishes a\nnew location when coming home or leaving home even if you do not move more than\n500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep\na private note (\"Parked Car here\").\n\n\nRegion Monitoring with iBeacons\n\n\nRather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers\nto the description to start region monitoring using iBeacons.\n\n\ne.g.\n* 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE'\nreports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity\n\n\n\n\n'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959'\nreports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity\n\n\n\n\nRegion Monitoring with \n+follow\n\n\nCreate a region with a name begining with a \n+\n character, e.g. \n+follow\n and set an initial radius to be greater than zero. From this moment onwards, \nlat\n and \nlon\n will be set dynamically at each location publish and \nradius\n will be the distance you've covered in 30 seconds, at least 50 meters.\n\n\nThis \nfollow\n-type region will not trigger \nenter/leave\n events or notifications, and location publishes will have a type setting of \n\"t\" : \"C\"\n.\n\n\nRemote configuration\n\n\nYou can help your friends customize their copy of OwnTracks with \nremote configuration\n.\n\n\nWhy do location publishes sometimes seem to cease to work?\n\n\nHere's what happens:\n\n\nIf the app goes into Background, the connection is disconnected because the app\ncannot maintain the TCP connection in background.\n\n\nIf you bring the app back into foreground, the app will re-connect.\n\n\nWhen a location change is recorded (no matter if manual, significant, move or\nregion mode), a message is prepared and an attempt to connect to the broker is\nstarted. If there is an error, connect will be retried after 2, 4, 8, ..., 64,\n64, .... seconds until it succeeds.\n\n\nBUT...\n\n\nIf the application is in background or is sent to the background, retries are\nrestarted eventually - depending on iOS' background execution model about every 10 minutes.\n\n\nWith automatic modes switched off, even when bringing the app to foreground, no\nnew location updates are generated.", 
            "title": "iOS"
        }, 
        {
            "location": "/features/ios/#startup", 
            "text": "After  downloading and installing the iPhone/iPad app , start it\nup.  The first time you start the app, the system asks you to give OwnTracks access to your location which it requires in order to, well, find your location.", 
            "title": "Startup"
        }, 
        {
            "location": "/features/ios/#settings", 
            "text": "Access settings and the individual modes by pressing on the  I  on the top left.", 
            "title": "Settings"
        }, 
        {
            "location": "/features/ios/#friends", 
            "text": "The Friends feature shows self and all Friends published by the server,\ntheir picture or OwnTracks default icon, and their last location.  Tapping on\nthe entry switches back to map centered on friend's last location.  The first time you launch the app you'll also be asked whether it may access your\ncontacts data, which you should allow. (If you change your mind later,  Privacy  in General settings  allows you to disable the feature.)  Tapping on an location entry centers the map on the selected location.  No geo-coding is done automatically in the background to limit mobile data usage.  Location indicators and friendly faces  The locations of yourself, your friends and of the waypoints you set are displayed on the map. The inner area of the circle either shows a picture of yourself / your friend or the Tracker ID (tid) which is usually 2 characters and defaults to the last two characters of the publish topic.  A red, yellow rimmed tachometer indicating the velocity (speed) at the reported location starts at at the 6 o'clock position and works clockwise. It uses a logarithmic scale to show slow speeds\nas good as high speeds. The 9 o'clock position indicates a speed of 30 km/h, the 12 o'clock posistion a speed of 100 km/h. 3 o'clock means 180 km/h.  A small blue, yellow rimmed semicircle at the perimeter indicates the course over ground (direction of movement)  with the 12 o'clock position meaning North.  If your iOS addressbook has an entry for, say, Jane Jolie, and Jane has an image associated with her addressbook entry, OwnTracks will show Jane's image on the map and on the  Friends  list, as soon as a location update for Jane is seen by the app.  Region Monitoring and Waypoints  For all manually published locations, a description, a region radius and a share flag can be edited.  Setting the description of a location helps you to remember places.  If a description is entered and the share flag set, the location is published to the MQTT broker as a  waypoint  once.  If the description is non-empty and a radius   0 (meters) is set, the app starts monitoring the circular region around the coordinate. A region may be 'waypoint'.\nThe regions are shown on the map as blue-ish circles. If the device is within a region, the corresponding circle turns red-ish.  If the description is non-empty and includes a value UUID for an iBeacon, the app starts monitoring the iBeacon region. e.g. 'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959'\nmonitors any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant.  Everytime the devices enters or leaves a monitored region, an additional location message is published to the MQTT broker.  Use cases:\n* Define a  home  region to insure that the device publishes a new location when coming home or leaving home even if you do not move more than 500m.\n* Share your favorite places with your friends (\"Best Sushi in Town\").\n* Keep a private note (\"Parked Car here\").\n* Use iBeacons to accurately report enter/leave events for your home\n* Use iBeacons to publish enter/leave events for individual rooms/floors in your home  See also  Waypoints .  Region monitoring (a.k.a. Geo Fences)  If the waypoint description is non-empty and a radius   0 (meters) is set, the\napp starts monitoring the circular region around the specified coordinates. \nRegions are shown on the map as blue-ish circles. If the\ndevice is within a region, the corresponding circle turns red-ish. Every time\nthe devices enters or leaves a monitored region, an additional location message\nis published to the MQTT broker, specifying whether the device is entering or leaving\nsaid region.  For example, you can define a home region to ensure that the device publishes a\nnew location when coming home or leaving home even if you do not move more than\n500m. Share your favorite places with your friends (\"Best Sushi in Town\"). Keep\na private note (\"Parked Car here\").  Region Monitoring with iBeacons  Rather than setting the radius, you may add your iBeacon's UUID and optionally major and minor numbers\nto the description to start region monitoring using iBeacons.  e.g.\n* 'myBeacon:CA271EAE-5FA8-4E80-8F08-2A302A95A959:0001:CAFE'\nreports region with description 'myBeacon' when the iBeacon identified with UUID = CA..., major = 0001 and minor = CAFE is in proximity   'myBeacons:CA271EAE-5FA8-4E80-8F08-2A302A95A959'\nreports region with description 'myBeacons' when any iBeacon identified with UUID = CA..., with major and minor numbers irrelevant is in proximity   Region Monitoring with  +follow  Create a region with a name begining with a  +  character, e.g.  +follow  and set an initial radius to be greater than zero. From this moment onwards,  lat  and  lon  will be set dynamically at each location publish and  radius  will be the distance you've covered in 30 seconds, at least 50 meters.  This  follow -type region will not trigger  enter/leave  events or notifications, and location publishes will have a type setting of  \"t\" : \"C\" .  Remote configuration  You can help your friends customize their copy of OwnTracks with  remote configuration .  Why do location publishes sometimes seem to cease to work?  Here's what happens:  If the app goes into Background, the connection is disconnected because the app\ncannot maintain the TCP connection in background.  If you bring the app back into foreground, the app will re-connect.  When a location change is recorded (no matter if manual, significant, move or\nregion mode), a message is prepared and an attempt to connect to the broker is\nstarted. If there is an error, connect will be retried after 2, 4, 8, ..., 64,\n64, .... seconds until it succeeds.  BUT...  If the application is in background or is sent to the background, retries are\nrestarted eventually - depending on iOS' background execution model about every 10 minutes.  With automatic modes switched off, even when bringing the app to foreground, no\nnew location updates are generated.", 
            "title": "Friends"
        }, 
        {
            "location": "/features/android/", 
            "text": "General Restrictions on Android 6 and higher.\n\n\nSince Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations.\n\n\n\n\nIt is highly recommended to use HTTP mode on Android 6 and higher.\n\n\nThe ongoing notification is required to run in the background.\n\n\nApp standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings \n Battery \n Battery Optimization.\n\n\nOutgoing messages will only be sent in batched intervals. Location updates or event messages may be delayed.\n\n\nIncoming messages such as events might be delayed.\n\n\nWhen using MQTT, the broker connection is not maintained permanently. A reconnect will be attempted regularly or when a message is sent. Changing the keepalive interval does not change this behavior. If the connection is established without the clean session flag, missed messages will be received once connected.\n\n\nThe app cannot attempt to connect if the network connection changes because it is not possible to receive the network change event.\n\n\nBeacons are no long supported in OwnTracks for Android\n\n\n\n\nVendor background restrictions\n\n\nCertain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits.\n\n\nA list of vendors known to interfer with background apps and a number of workarounds can be found at \nDon\u2019t kill my app!\n.\n\n\nGoogle Play Services\n\n\nGoogle Play Services are required to use OwnTracks. There are no plans to remove the dependency.\n\n\nThey are used for\n* Battery efficient location access\n* Geofencing\n* Scheduling of background jobs\n* Resolving coordinates to addresses (an alterative Geocoding service can be configured)\n* Displaying the map\n\n\nSetup\n\n\nIn the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things.\n\n\nBy default a \nTLS\n secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device.\n\n\nIn recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system.\n\n\nIn HTTP mode the \nurl\n is required to connect.\nIn MQTT mode the \nhost\n and \nusername\n  and \npassword\n is required to connect.\n\n\nDebug Log\n\n\nSince Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app.\n\n\nTo generate the logs, follow the next steps:\n\n\n\n\nTemporarily grant write access to local storage. Go to Android App Info \n Permissions and enable the storage permission.\n\n\nOpen the configuration editor at Preferences \n Configuration Management \n Menu on the right top \n Editor\n\n\nUnder key enter \ndebugLog\n\n\nAs value enter \ntrue\n\n\nRestart the app at Menu on the right top \n Restart\n\n\n\n\nApplication logs are written to the local Download folder at Downloads/owntracks_debug DD-MM-YYY.html\nThe file is appended after application restarts and degrades application performance. It should be disabled after gathering enough information. To do so, follow the steps above but enter \nfalse\n as value in the configuration editor.\n\n\nAutomation via Tasker, Automagic, etc.\n\n\nSince Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined \nmodes\n: \nMove\n, \nSignificant location change\n,\nManual\n,\nQuiet\n.\n\n\nTo set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action.  Do not put any text into the fields listed as [LEAVE FIELD BLANK] above.\n\n\nTasker example:\n\n\nTo trigger \nMove\n mode in tasker, create a \nSend Intent\n action and enter the following information:\n\n\n\n\nAction: \norg.owntracks.android.CHANGE_MONITORING\n\n\nCat: \nNone\n\n\nMime Type: [LEAVE FIELD BLANK]\n\n\nData: [LEAVE FIELD BLANK]\n\n\nExtra(1): \nmonitoring:2\n\n\nExtra(2): [LEAVE FIELD BLANK]\n\n\nExtra(3): [LEAVE FIELD BLANK]\n\n\nPackage: [LEAVE FIELD BLANK]\n\n\nClass: [LEAVE FIELD BLANK]\n\n\nTarget: \nService\n\n\n\n\n\n\n\n\n\n\nMode\n\n\nSend This Extra Value\n\n\n\n\n\n\n\n\n\n\nQuiet\n\n\nmonitoring:-1\n\n\n\n\n\n\nManual\n\n\nmonitoring:0\n\n\n\n\n\n\nSignificant Changes\n\n\nmonitoring:1\n\n\n\n\n\n\nMove\n\n\nmonitoring:2\n\n\n\n\n\n\n\n\nAutomagic example:\n\n\nTo trigger \nMove\n mode in Automagic, create a \nStart Service\n action and enter the following information:\n\n\n\n\nAction: \norg.owntracks.android.CHANGE_MONITORING\n\n\nCategory List: [LEAVE FIELD BLANK]\n\n\nData URI: [LEAVE FIELD BLANK]\n\n\nData MIME Type: [LEAVE FIELD BLANK]\n\n\nExplicit Component: ticked\n\n\nPackage Name: \norg.owntracks.android\n\n\nClass Name: [LEAVE FIELD BLANK]\n\n\nFlag List: [LEAVE FIELD BLANK]\n\n\nExtra: \nputInt(\"MONITORING\": 2)\n\n\n\n\n\n\n\n\n\n\nMode\n\n\nSend This Extra Value\n\n\n\n\n\n\n\n\n\n\nQuiet\n\n\nputInt(\"MONITORING\": -1)\n\n\n\n\n\n\nManual\n\n\nputInt(\"MONITORING\": 0)\n\n\n\n\n\n\nSignificant Changes\n\n\nputInt(\"MONITORING\": 1)\n\n\n\n\n\n\nMove\n\n\nputInt(\"MONITORING\": 2)", 
            "title": "Android"
        }, 
        {
            "location": "/features/android/#general-restrictions-on-android-6-and-higher", 
            "text": "Since Android 6 and higher, the operating systems enforces stricter restrictions for apps running in the background. Most importantly, network access and background jobs are restricted to certain time slots. As a result, certain features might be restricted when the app is not actively used. This also applies if OwnTracks is exluded from battery optimizations.   It is highly recommended to use HTTP mode on Android 6 and higher.  The ongoing notification is required to run in the background.  App standby or battery optimization may interfere with OwnTracks due to broken implementation on some devices. It is recommended to disable the Android battery optimization feature for OwnTracks in Settings   Battery   Battery Optimization.  Outgoing messages will only be sent in batched intervals. Location updates or event messages may be delayed.  Incoming messages such as events might be delayed.  When using MQTT, the broker connection is not maintained permanently. A reconnect will be attempted regularly or when a message is sent. Changing the keepalive interval does not change this behavior. If the connection is established without the clean session flag, missed messages will be received once connected.  The app cannot attempt to connect if the network connection changes because it is not possible to receive the network change event.  Beacons are no long supported in OwnTracks for Android", 
            "title": "General Restrictions on Android 6 and higher."
        }, 
        {
            "location": "/features/android/#vendor-background-restrictions", 
            "text": "Certain vendors have their own restrictions for apps running in the background. On these devices, Owntracks might be killed even though it behaves according to the official Android background execution limits.  A list of vendors known to interfer with background apps and a number of workarounds can be found at  Don\u2019t kill my app! .", 
            "title": "Vendor background restrictions"
        }, 
        {
            "location": "/features/android/#google-play-services", 
            "text": "Google Play Services are required to use OwnTracks. There are no plans to remove the dependency.  They are used for\n* Battery efficient location access\n* Geofencing\n* Scheduling of background jobs\n* Resolving coordinates to addresses (an alterative Geocoding service can be configured)\n* Displaying the map", 
            "title": "Google Play Services"
        }, 
        {
            "location": "/features/android/#setup", 
            "text": "In the unlikely case that your broker does not require a username and password, you can disable authentication in the configuration editor. Please note that even then, you have to set a device name and username before you can connect as these are also used to construct various other internal things.  By default a  TLS  secured communication channel with the broker is assumed. Thus you have to ensure that the broker certificate is properly imported on your device.  In recent Android versions, a passcode is required once custom TLS certificates are imported. If you want to circumvent this, you can enable TLS with custom certificates and import that into the private storage location of the app. This will circumvent the Android TLS certificate management by using the certificate directly and skipping any other certificates known to the system.  In HTTP mode the  url  is required to connect.\nIn MQTT mode the  host  and  username   and  password  is required to connect.", 
            "title": "Setup"
        }, 
        {
            "location": "/features/android/#debug-log", 
            "text": "Since Owntracks 2.1.2 application logs can be exported easily to assist in debugging problems with the app.  To generate the logs, follow the next steps:   Temporarily grant write access to local storage. Go to Android App Info   Permissions and enable the storage permission.  Open the configuration editor at Preferences   Configuration Management   Menu on the right top   Editor  Under key enter  debugLog  As value enter  true  Restart the app at Menu on the right top   Restart   Application logs are written to the local Download folder at Downloads/owntracks_debug DD-MM-YYY.html\nThe file is appended after application restarts and degrades application performance. It should be disabled after gathering enough information. To do so, follow the steps above but enter  false  as value in the configuration editor.", 
            "title": "Debug Log"
        }, 
        {
            "location": "/features/android/#automation-via-tasker-automagic-etc", 
            "text": "Since Owntracks 2.1 it is possible to automate changes to the location monitoring mode by sending Owntracks an intent. You can change the mode to one of the following pre-defined  modes :  Move ,  Significant location change , Manual , Quiet .  To set modes, use the same example as provided below and simply substitute the Extra in the table that corresponds to the desired state of Owntracks into the first Extra field of the Intent Action.  Do not put any text into the fields listed as [LEAVE FIELD BLANK] above.  Tasker example:  To trigger  Move  mode in tasker, create a  Send Intent  action and enter the following information:   Action:  org.owntracks.android.CHANGE_MONITORING  Cat:  None  Mime Type: [LEAVE FIELD BLANK]  Data: [LEAVE FIELD BLANK]  Extra(1):  monitoring:2  Extra(2): [LEAVE FIELD BLANK]  Extra(3): [LEAVE FIELD BLANK]  Package: [LEAVE FIELD BLANK]  Class: [LEAVE FIELD BLANK]  Target:  Service      Mode  Send This Extra Value      Quiet  monitoring:-1    Manual  monitoring:0    Significant Changes  monitoring:1    Move  monitoring:2     Automagic example:  To trigger  Move  mode in Automagic, create a  Start Service  action and enter the following information:   Action:  org.owntracks.android.CHANGE_MONITORING  Category List: [LEAVE FIELD BLANK]  Data URI: [LEAVE FIELD BLANK]  Data MIME Type: [LEAVE FIELD BLANK]  Explicit Component: ticked  Package Name:  org.owntracks.android  Class Name: [LEAVE FIELD BLANK]  Flag List: [LEAVE FIELD BLANK]  Extra:  putInt(\"MONITORING\": 2)      Mode  Send This Extra Value      Quiet  putInt(\"MONITORING\": -1)    Manual  putInt(\"MONITORING\": 0)    Significant Changes  putInt(\"MONITORING\": 1)    Move  putInt(\"MONITORING\": 2)", 
            "title": "Automation via Tasker, Automagic, etc."
        }, 
        {
            "location": "/features/security/", 
            "text": "Security\n\n\nOwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your loved ones is something only you respectively they should know. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes.\n\n\n\n\nIf your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over \nTLS\n when connecting to your broker.\n\n\nThe apps support authenticating to the MQTT broker with \nusername\n and \npassword\n which can be as strong (or as convoluted) as your broker supports.\n\n\nIn HTTP mode, the apps provide support for HTTP basic authentication with TLS.\n\n\nCredentials you configure (i.e. \nusername\n and \npassword\n) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits.\n\n\nThe apps support using \nTLS client certificates\n for authentication to the MQTT broker.\n\n\nThe apps support \npayload encryption\n for privacy.\n\n\nThe apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server).", 
            "title": "Security"
        }, 
        {
            "location": "/features/security/#security", 
            "text": "OwnTracks and its associated utilities have been designed foremost with data privacy in mind. We think your location or that of your loved ones is something only you respectively they should know. While we cannot help you (or ourselves for that matter) protect against NSA snooping, we do our best to protect your data from other people's eyes.   If your broker supports it, and if you configure OwnTracks to do so, OwnTracks uses MQTT over  TLS  when connecting to your broker.  The apps support authenticating to the MQTT broker with  username  and  password  which can be as strong (or as convoluted) as your broker supports.  In HTTP mode, the apps provide support for HTTP basic authentication with TLS.  Credentials you configure (i.e.  username  and  password ) are thus protected from snooping, at least until they get to your broker. The same applies to location data our app transmits.  The apps support using  TLS client certificates  for authentication to the MQTT broker.  The apps support  payload encryption  for privacy.  The apps do not send location data to any server until that server has been configured by the user (i.e., there is no preconfigured demo server).", 
            "title": "Security"
        }, 
        {
            "location": "/features/tls/", 
            "text": "TLS\n\n\nYou want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using \nTLS\n (the artist formerly known as \nSSL\n). When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.)\n\n\nConfiguring TLS (\nTransport Layer Security\n) for OwnTracks involves doing three things:\n\n\n\n\nObtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one\n\n\nConfigure TLS on the MQTT broker\n\n\nConfiguring the app to use TLS\n\n\n\n\nYou can share the certificate if you want to (though not many people will want it ...)\nIt's so public, that it's perfectly OK to send yourself the file by, say, e-mail.\n\n\nConfigure TLS on the Mosquitto broker\n\n\nWe'll first show you how to set up TLS on your Mosquitto \nbroker\n.\nThe basic configuration for TLS in \nmosquitto.conf\n is:\n\n\nlistener 8883\ncafile .............\ncertfile .............\nkeyfile .............\n\n\n\n\n(see also: \nmosquitto-tls\n.)\n\n\n\n\n8883\n is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port.\n\n\ncafile\n is the path to the certificate authority file\n\n\ncertfile\n points to your server's certificate in PEM format\n\n\nkeyfile\n points to your server's secret key file (which you \nnever\n divulge!)\n\n\n\n\nConfigure the OwnTracks app to use TLS\n\n\nWe show you here how to set up your iOS or Android device with that kind of certificate.\n\n\nIn both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a \n.crt\n extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment.\n\n\nIn our example, the CA certificate is called \nMQTTitude-ca.crt\n.\n\n\nAndroid\n\n\nNote that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below).\n\n\nSo, here's your e-mail message with said attachment.\n\n\n\n\nNow click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen \nMQTTitude\n, of course. Then click OK.\n\n\n\n\nThat's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.\n\n\nNote that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying).\n\n\n\n\niOS\n\n\nSo, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself!\n\n\n\n\nYou've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install.\n\n\n\n\nRead the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right.\n\n\n\n\nThere you go! That's it: the certificate was installed.\n\n\n\n\nYou're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.\n\n\nmanual configuration on Android\n\n\nFrom the, say, e-mail you got with the certificate, click \"save\" on the attached \n.crt\n file which is stored on your device's \nDownload\n folder.\n\n\nIn OwnTracks's settings, select \nTLS (Custom Certificate)\n\n\n\n\nNow comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is \n/storage/emulated/0/Download/MQTTitude.crt\n. Your mileage, etc; \n\n\n\n\nWhen you click \nConnect\n, it will try and use your certificate. Good luck! ;-)\n\n\nThe nitty gritty\n\n\nThat CA certificate file we mentioned? The attachment called \nsomething.crt\n?\nIt looks like this, in fact, in what is called \nPEM\n format; but you don't really want to know that, but if you do, this is what it looks like:\n\n\n-----BEGIN CERTIFICATE-----\nMIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV\nBAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK\n...\npjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS\ncPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc=\n-----END CERTIFICATE-----\n\n\n\n\nThat's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak:\n\n\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            e0:d7:9d:ed:b2:57:9d:73\n        Signature Algorithm: sha1WithRSAEncryption\n        Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com\n        Validity\n            Not Before: Aug 18 10:26:08 2013 GMT\n            Not After : Aug 16 10:26:08 2023 GMT\n        Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n            RSA Public Key: (1024 bit)\n                Modulus (1024 bit):\n                    00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25:\n                    ...\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Subject Key Identifier: \n                4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85\n            X509v3 Authority Key Identifier: \n                keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85\n                DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com\n                serial:E0:D7:9D:ED:B2:57:9D:73\n\n            X509v3 Basic Constraints: \n                CA:TRUE\n    Signature Algorithm: sha1WithRSAEncryption\n        74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c:\n        ...\n\n\n\n\nBetter, huh? Well, at least parts of it are now readable. Hope you liked this.\n\n\nObtain a certificate and key\n\n\nThe following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with \nMosquitto\n.\n\n\nYou can also create your own self-signed certificate. We provide the \ngenerate-CA.sh\n utility for doing this easily.\n\n\nstartssl.com\n\n\nIf you have a key-pair issued by \nstartssl.com\n, you'll be issued a key (in a \n*.key\n file), and a certificate (as \n*.pem\n or \n*.crt\n -- either contains a PEM-encoded certificate).\n\n\nMosquitto\n will need the certificate chain for \nstartssl.com\n, which you can find as \nca-bundle.crt\n at \nwww.startssl.com/certs/\n.\n\n\nAs far as TLS is concerned, you'll therefore set up your \nmosquitto.conf\n as follows, specifying corrrect paths to the files.\n\n\nlistener 8883\ncafile ca-bundle.crt\ncertfile server.crt\nkeyfile server.key\n\n\n\n\nThen download the \nstartssl.com\n CA certificate (\nca.crt\n) and install that on your device as described above.", 
            "title": "TLS"
        }, 
        {
            "location": "/features/tls/#tls", 
            "text": "You want data between your mobile device (a.k.a. smartphone) and the MQTT broker you use to be secured from eavesdropping. This is accomplished using  TLS  (the artist formerly known as  SSL ). When you configure your broker you will generate what is called a CA certificate which is basically a large amount of bits. (See below for the nitty gritty.)  Configuring TLS ( Transport Layer Security ) for OwnTracks involves doing three things:   Obtain a TLS certificate/key pair (see below on how to do this) if you don't yet have one  Configure TLS on the MQTT broker  Configuring the app to use TLS   You can share the certificate if you want to (though not many people will want it ...)\nIt's so public, that it's perfectly OK to send yourself the file by, say, e-mail.", 
            "title": "TLS"
        }, 
        {
            "location": "/features/tls/#configure-tls-on-the-mosquitto-broker", 
            "text": "We'll first show you how to set up TLS on your Mosquitto  broker .\nThe basic configuration for TLS in  mosquitto.conf  is:  listener 8883\ncafile .............\ncertfile .............\nkeyfile .............  (see also:  mosquitto-tls .)   8883  is the standard MQTT port for TLS connections. Change it if you need to, but make sure your OwnTracks app is configured to use the same port.  cafile  is the path to the certificate authority file  certfile  points to your server's certificate in PEM format  keyfile  points to your server's secret key file (which you  never  divulge!)", 
            "title": "Configure TLS on the Mosquitto broker"
        }, 
        {
            "location": "/features/tls/#configure-the-owntracks-app-to-use-tls", 
            "text": "We show you here how to set up your iOS or Android device with that kind of certificate.  In both cases we assume you've got an e-mail in your inbox with the file you've sent yourself. This file has a  .crt  extension, and in both Android and iOS you can simply launch configuration by clicking on the attachment.  In our example, the CA certificate is called  MQTTitude-ca.crt .  Android  Note that by following these instructions on Android you'll be prompted to set a device PIN or pattern to protect the device. If you already have that, just carry on. If you absolutely don't want to do that, you should download the certificate into, say, the Downloads folder, and configure it manually in OwnTracks (see below).  So, here's your e-mail message with said attachment.   Now click on the attached file, and you'll get the following dialog where you have to specify a name for the certificate (sigh: the certificate contains a name, but Android wants you to name it anyway). Give it any old name. We've chosen  MQTTitude , of course. Then click OK.   That's it. You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.  Note that installing a certificate into Android will, since Kitkat (4.4) bring up a warning when you power up your device. This warning is harmless (even though we consider it quite annoying).   iOS  So, here's your e-mail containing the certificate file. Click on it to launch the profile installer. No worries: we're not going to break anything. We're just adding yet another certificate to iOS' certificate store, and you're going to say that you trust that certificate. You ought to trust it: you've just created it yourself!   You've clicked, and here's the trust store. You see the certificate has a name, but it's not trusted yet. Click on Install.   Read the text if you must. Just kidding: honestly, it's ok. But do read the text, and then click \"Install\" on the top right.   There you go! That's it: the certificate was installed.   You're done, and if you no longer require the certificate file just delete the e-mail, though we recommend you keep it around for a bit.  manual configuration on Android  From the, say, e-mail you got with the certificate, click \"save\" on the attached  .crt  file which is stored on your device's  Download  folder.  In OwnTracks's settings, select  TLS (Custom Certificate)   Now comes the hard part: you have to enter the path to the certificate you downloaded. On my device this is  /storage/emulated/0/Download/MQTTitude.crt . Your mileage, etc;    When you click  Connect , it will try and use your certificate. Good luck! ;-)", 
            "title": "Configure the OwnTracks app to use TLS"
        }, 
        {
            "location": "/features/tls/#the-nitty-gritty", 
            "text": "That CA certificate file we mentioned? The attachment called  something.crt ?\nIt looks like this, in fact, in what is called  PEM  format; but you don't really want to know that, but if you do, this is what it looks like:  -----BEGIN CERTIFICATE-----\nMIIDGTCCAoKgAwIBAgIJAODXne2yV51zMA0GCSqGSIb3DQEBBQUAMGcxCzAJBgNV\nBAYTAkRFMQwwCgYDVQQIEwNOUlcxETAPBgNVBAcTCElyZ2VuZHdvMRYwFAYDVQQK\n...\npjGM/XgBs62UhqXnoHrHh/AHIiHieuNFwOhUg0fD/vQ5O6UZkJTWY5LLmEyPN5sS\ncPZ5pT/WCvGuIOgNdy1VyWJrrlAjeQlbK+GDcNc=\n-----END CERTIFICATE-----  That's plain text, even though it might be hard to believe. Actually, it's all sorts of magic wrapped into ASCII bytes, but we can look inside that, and we'll give you a sneak peak:  Certificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            e0:d7:9d:ed:b2:57:9d:73\n        Signature Algorithm: sha1WithRSAEncryption\n        Issuer: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com\n        Validity\n            Not Before: Aug 18 10:26:08 2013 GMT\n            Not After : Aug 16 10:26:08 2023 GMT\n        Subject: C=DE, ST=NRW, L=Irgendwo, O=MQTTitude.org/emailAddress=jjolie@example.com\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n            RSA Public Key: (1024 bit)\n                Modulus (1024 bit):\n                    00:bd:70:b0:49:d4:17:c9:17:33:4d:74:fc:61:25:\n                    ...\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Subject Key Identifier: \n                4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85\n            X509v3 Authority Key Identifier: \n                keyid:4C:89:83:F0:33:AD:2B:D7:FD:DE:1D:6D:8D:00:52:C1:1C:75:B1:85\n                DirName:/C=DE/ST=NRW/L=Irgendwo/O=MQTTitude.org/emailAddress=jjolie@example.com\n                serial:E0:D7:9D:ED:B2:57:9D:73\n\n            X509v3 Basic Constraints: \n                CA:TRUE\n    Signature Algorithm: sha1WithRSAEncryption\n        74:12:f8:d0:51:3a:c6:f8:62:75:61:d1:56:2f:bf:e3:64:3c:\n        ...  Better, huh? Well, at least parts of it are now readable. Hope you liked this.  Obtain a certificate and key  The following sections are not an endorsement of a particular Certification Authority, but rather are a few tips on getting you set up with  Mosquitto .  You can also create your own self-signed certificate. We provide the  generate-CA.sh  utility for doing this easily.  startssl.com  If you have a key-pair issued by  startssl.com , you'll be issued a key (in a  *.key  file), and a certificate (as  *.pem  or  *.crt  -- either contains a PEM-encoded certificate).  Mosquitto  will need the certificate chain for  startssl.com , which you can find as  ca-bundle.crt  at  www.startssl.com/certs/ .  As far as TLS is concerned, you'll therefore set up your  mosquitto.conf  as follows, specifying corrrect paths to the files.  listener 8883\ncafile ca-bundle.crt\ncertfile server.crt\nkeyfile server.key  Then download the  startssl.com  CA certificate ( ca.crt ) and install that on your device as described above.", 
            "title": "The nitty gritty"
        }, 
        {
            "location": "/features/tlscert/", 
            "text": "Client certificates\n\n\nThe OwnTracks iOS and Android clients can be configured to use TLS client\ncertificates to authenticate against their MQTT broker. This is the next best\nthing to two-factor authentication, where the apps have a TLS key and a\ncertificate which has to be presented to the broker for successful\nauthentication.\n\n\nMosquitto\n\n\nWhen using the Mosquitto \nbroker\n support for TLS\ncertificates can be enabled as follows:\n\n\nrequire_certificate true\nuse_identity_as_username true\n\n\n\n\nClient certs\n\n\nTo create a client certificate and key, you can use, say, \ngenerate-CA.sh\n from\nour \ntools repository\n.\n\n\n./generate-CA.sh client jjolie\n\n\n\n\nThis produces at least two files which are required on the OwnTracks devices: a \n.key\n file and a \n.crt\n file.\n\n\nPKCS#12\n\n\nIn order to safely transport a user's key and certificate to the OwnTracks app,\nwe make use of the \nPKCS#12\n container\nformat. OpenSSL's \npkcs12\n subcommand creates this container and protects it\nwith a passphrase you specify. This passphrase we will later require in the app.\n\n\nopenssl pkcs12 \\\n  -export \\\n  -in jjolie.crt \\\n  -inkey jjolie.key \\\n  -name \nJane's certificate/key\n \\\n  -out jjolie.p12\n\n\n\n\nYou now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a \n.otrp\n extension so that it can be opened in OwnTracks.\nYou also send the CA certificate to the device and install it there, as discussed in \nTLS\n\n\nAndroid\n\n\n\n\nSave the certificate to your device in an easy accessible location \n\n\nImport the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser. \n\n\nThe file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device. \n\n\nSpecify the certificate password (certificates without password are not supported). \n\n\n\n\niOS\n\n\nWe recommend you proceed as follows:\n\n\n\n\nInstall the \nTLS\n CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.)\n\n\nSend the prepared PKCS#12 file (with an \n.otrp\n extension) to your device, and open it. It will be imported into OwnTracks\n\n\nLaunch OwnTracks, select Settings and TLS. Select the \notrp\n file you just imported as Client Certificate Filename, and below that, enter its passphrase.\n\n\nLeave \nUse Custom Security Policy\n disabled.\n\n\nVerify the connection to your broker.\n\n\n\n\nIf need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button \nUse Custom Security Policy\n can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only.\n\n\n\n\nMode\n\n\nNone; do not use pinned certificates to validate servers\n\n\nPublic Key; validate host (broker) certificates against the public keys of the pinned certificate\n\n\nCertificate; validate host certificates against pinned certificates\n\n\n\n\n\n\n\n\nPinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled.\n\n\n\n\n\n\nValidate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled.\n\n\n\n\nAllow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates.\n\n\nValidate Domain Name; whether or not to validate the domain name in the certificate's \nCN\n field.\n\n\n\n\nNote: on iOS self-signed certificates \nrequire\n \nCustom Security Policy\n to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.)\n\n\nClient certificates are independent of the custom security policy settings.\n\n\nIf you wish to use certificate pinning, you must provide a DER-encoded file with an \n.otre\n extension to the device containing the pinned certificate.\n\n\nopenssl x509 \\\n   -in ca.crt \\\n   -out ca.otre \\\n   -outform DER", 
            "title": "TLS client"
        }, 
        {
            "location": "/features/tlscert/#client-certificates", 
            "text": "The OwnTracks iOS and Android clients can be configured to use TLS client\ncertificates to authenticate against their MQTT broker. This is the next best\nthing to two-factor authentication, where the apps have a TLS key and a\ncertificate which has to be presented to the broker for successful\nauthentication.  Mosquitto  When using the Mosquitto  broker  support for TLS\ncertificates can be enabled as follows:  require_certificate true\nuse_identity_as_username true  Client certs  To create a client certificate and key, you can use, say,  generate-CA.sh  from\nour  tools repository .  ./generate-CA.sh client jjolie  This produces at least two files which are required on the OwnTracks devices: a  .key  file and a  .crt  file.  PKCS#12  In order to safely transport a user's key and certificate to the OwnTracks app,\nwe make use of the  PKCS#12  container\nformat. OpenSSL's  pkcs12  subcommand creates this container and protects it\nwith a passphrase you specify. This passphrase we will later require in the app.  openssl pkcs12 \\\n  -export \\\n  -in jjolie.crt \\\n  -inkey jjolie.key \\\n  -name  Jane's certificate/key  \\\n  -out jjolie.p12  You now send the PKCS#12 file as attachment to the device, e.g. by e-mail. Note that for iOS, the file must have a  .otrp  extension so that it can be opened in OwnTracks.\nYou also send the CA certificate to the device and install it there, as discussed in  TLS  Android   Save the certificate to your device in an easy accessible location   Import the certificate into the app (Preferences, Connection, Security, Client certificate, Select) by opening it with the file choser.   The file will be copied to the secure storage location of the app. If the import is successfull, the original file can be removed from the device.   Specify the certificate password (certificates without password are not supported).    iOS  We recommend you proceed as follows:   Install the  TLS  CA certificate in your system keystore by sending it (e.g. via e-mail) to your device and installing it in the system profile. (Click on the certificate and follow iOS' instructions.)  Send the prepared PKCS#12 file (with an  .otrp  extension) to your device, and open it. It will be imported into OwnTracks  Launch OwnTracks, select Settings and TLS. Select the  otrp  file you just imported as Client Certificate Filename, and below that, enter its passphrase.  Leave  Use Custom Security Policy  disabled.  Verify the connection to your broker.   If need be, you can adjust a great number of parameters regarding how TLS connections will be verified: there are a number of settings available to fine-tune TLS connections between the app and the broker. The button  Use Custom Security Policy  can be enabled to do so. This switch allows you to control your TLS settings more granularly. If not switched on, it uses the default iOS settings and uses the iOS keychain for certificate validation only.   Mode  None; do not use pinned certificates to validate servers  Public Key; validate host (broker) certificates against the public keys of the pinned certificate  Certificate; validate host certificates against pinned certificates     Pinned Server Certificate; select the certificate to use for pinning. Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an SSL/TLS connection with SSL pinning configured and enabled.    Validate Certificate Chain; if enabled, the entire TLS certificate chain is validated and not just the leaf (host) certificate if disabled.   Allow untrusted Certificates should be disabled if possible. If the app doesn't have the CA certificate in its keychain, you'll have to allow untrusted certificates.  Validate Domain Name; whether or not to validate the domain name in the certificate's  CN  field.   Note: on iOS self-signed certificates  require   Custom Security Policy  to be set. (There seems to be a problem we have not tracked down yet. Using Custom Security Policy once does mark a self signed certificate as valid until the app is restarted. This isn't reset even when Custom Security Policy is switched off afterwards.)  Client certificates are independent of the custom security policy settings.  If you wish to use certificate pinning, you must provide a DER-encoded file with an  .otre  extension to the device containing the pinned certificate.  openssl x509 \\\n   -in ca.crt \\\n   -out ca.otre \\\n   -outform DER", 
            "title": "Client certificates"
        }, 
        {
            "location": "/features/location/", 
            "text": "Location data\n\n\nLocation data is obtained by your smartphone and published to the \nMQTT broker\n as follows:\n\n\nThe Android and iOS apps offer 4 modes of location publication as well as region monitoring:\n\n\n\n\nQuiet\n mode: Only manual location reports. Icon \n[]\n\n\nManual\n mode: Manual location reports and automated reports with region monitoring. Icon \n||\n\n\nSignificant location change\n mode: Standard tracking mode with automated location reports. Icon \n|\n\n\nMove\n mode: Frequent location  \n||\n\n\n\n\nAll four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons. \n\n\niOS\n\n\nMove\n mode\n\n\nIn \nmove\n mode, the app monitors location permanently and publishes a new\nlocation as soon as the device moves \nx\n meters or after \nt\n seconds, whatever\nhappens first. \nx\n and \nt\n can be adjusted by the user in the systems settings for\nOwnTracks. The defaults are 100m and 300 seconds (5 minutes). \n\n\nThe payoff is higher battery usage as high as in navigation or tracker app.\nSo it is recommend to use \nmove\n mode while charging or during moves only - hence the name.\n\n\nPlease note, \nmove\n mode is active when the app is active (a.k.a in foreground).\n\n\nSignificant location change\n mode\n\n\niOS defines a \nSignificant location change\n as traveling a distance of at least\n500 meters in 5 minutes.  This mode allows the app to run in background and\nminimize the power consumption.\n\n\nThis standard tracking mode reports significant location changes only (\n500m\nand at most once every 5 minutes).  This is defined by Apple and is optimal\nwith respect to battery usage.\n\n\nExamples:\n\n\n\n\nif you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a \nping\n-type message once in a while.)\n\n\nif you move at least 500 meters, a new location will be published after 5 minutes\n\n\nif you move 10 kilometers in 5 minutes, only one location will be published\n\n\n\n\nManual\n mode\n\n\nThe app doesn't monitor location changes in \nmanual\n mode while in background.\nThe user has to publish the current location explicitly via the UI. You use this if\nyou want to (temporarily) avoid friends seeing where you are. Note that Region events\ntriggered by entering or leaving Geo Fence or Beacon regions\nare still published automatically whilst in \nManual\n mode.\n\n\nQuiet\n mode\n\n\nSame as \nManual\n mode except that no region events are published.\n\n\nRegion\n monitoring\n\n\nThe app user may mark a previously manually published or manually created \nlocation as a monitored circular region by specifying a monitoring radius in meters. (See \nWaypoints\n.)\nThe app will publish the location\nadditionally every time the device leaves or enters one of the regions, and the\npublished data contains an indication of whether the device is entering or\nleaving the region.\n\n\nRegion monitoring is not related to one of the location publication modes and\nworks independently thereof. It is switched on when a region is setup with description\nand radius. To switch region monitoring off, all regions have to be \nunmarked (by setting their radius to 0).\n\n\nRegions are shown on the map display in transparent blue or red circles. Red\nindicates the device is is within the region.\n\n\niBeacon monitoring\n\n\nThe app user may mark a previously manually published or manually created location\nas a monitored beacon region by appending a beacon UUID to the region's name.\nThe app will publish the location\nadditionally every time the device leaves or enters one of the beacon regions, and the\npublished data contains an indication of whether the device is entering or\nleaving the region.\n\n\nRegion monitoring is not related to one of the location publication modes and\nworks independently. It is switched on when a region's name has a valid UUID\nappended to it.\n\n\nIf the device is within a monitored beacon region, the the beacon indicator\nis shown in red, otherwise blue meaning device is not in any iBeacon region.\n\n\nThere are 2 kinds of locations:\n\n\n\n\nan \nautomatic location\n created when iOS detects a change of location\n\n\na \nmanual location\n created by the user\n\n\n\n\nA \nmanual location\n with a non-zero length remark (description) is a \nwaypoint\n.\n\n\nA \nwaypoint\n's attributes are published when the waypoint is created or changed.\n\n\nIf a \nwaypoint\n specifies a radius, a \ncircular region\n is monitored for \nenter/leave events\n.\n\n\nIf a \nwaypoint\n is not a \ncircular region\n and the waypoint's description contains a valid iBeacon specification, a \nbeacon region\n is monitored for enter/leave events.\n\n\nIf an enter/leave event occurs an event message is published with the \ntype\n attribute set to \nc\nor \nb\nfor (\ncircular region_or _beacon region\n). The message contains an \nevent\n attribute specifying either \nenter\nor \nleave\n.\n\n\nThe description of the \nwaypoint\n is added to the published \nevent\n message.\n\n\n\n\n\n\n\n\nAutomatic\n\n\nDescription\n\n\niBeacon\n\n\nRadius\n\n\nEvent Message\n\n\n/w Description\n\n\nWaypoint Message\n\n\n\n\n\n\n\n\n\n\nY\n\n\nn/a\n\n\nn/a\n\n\nn/a\n\n\nN\n\n\nN\n\n\nN\n\n\n\n\n\n\nN\n\n\nN\n\n\nn/a\n\n\nn/a\n\n\nN\n\n\nN\n\n\nN\n\n\n\n\n\n\nN\n\n\nY\n\n\nN\n\n\nN\n\n\nN\n\n\nN\n\n\nY\n\n\n\n\n\n\nN\n\n\nY\n\n\nN\n\n\nY\n\n\nc\n\n\nN\n\n\nN\n\n\n\n\n\n\nN\n\n\nY\n\n\nN\n\n\nY\n\n\nc\n\n\nY\n\n\nY\n\n\n\n\n\n\nN\n\n\nY\n\n\nY\n\n\nN\n\n\nb\n\n\nN\n\n\nN\n\n\n\n\n\n\nN\n\n\nY\n\n\nY\n\n\nN\n\n\nb\n\n\nY\n\n\nY\n\n\n\n\n\n\nN\n\n\nY\n\n\nY\n\n\nY\n\n\nc\n\n\nN\n\n\nN\n\n\n\n\n\n\nN\n\n\nY\n\n\nY\n\n\nY\n\n\nc\n\n\nY\n\n\nY\n\n\n\n\n\n\n\n\nAndroid\n\n\nMove\n mode\n\n\nIn \nmove\n mode, the app monitors device location permanently. It requests a location fix every 30s in high power mode and publishes a new location as soon as it arrives but at most every 10 seconds. \n\n\nThis mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage.\nIt is recommend to use \nmove\n mode while charging or during periods that require highly accurate tracking while moving quickly. \n\n\nSignificant location change\n mode\n\n\nThis standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives but at most every 10 seconds. \n\n\nThis mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users. \n\n\nIn addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw \nlocation request\n that is send to the Android location API.\n\n* \nlocatorInterval\n: Maximum time between new location fixes. This interval is inexact and updates may arrive faster. \n* \nlocatorDisplacement\n: The smallest displacement in meters the user must move between location updates. Defaults to 0 and is an \nand\n relationship with interval. Can be used to only receive updates when the device has moved. \n* \nlocatorPriority\n: The priority of the request is a strong hint to the LocationClient for which location sources to use. \n\n\nManual\n mode\n\n\nIn \nmanual\n mode, the app monitors device location with a low power location request. It uses the same interval configured for \nsignificant mode\n to receive low accuracy updates to use minimal battery power. \n\n\nThe user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in \nManual\n mode.\n\n\nRemote \nreportLocation\n commands are ignored. \n\n\nQuiet\n mode\n\n\nSame as \nManual\n mode except that no region events are published.", 
            "title": "Location"
        }, 
        {
            "location": "/features/location/#location-data", 
            "text": "Location data is obtained by your smartphone and published to the  MQTT broker  as follows:  The Android and iOS apps offer 4 modes of location publication as well as region monitoring:   Quiet  mode: Only manual location reports. Icon  []  Manual  mode: Manual location reports and automated reports with region monitoring. Icon  ||  Significant location change  mode: Standard tracking mode with automated location reports. Icon  |  Move  mode: Frequent location   ||   All four modes work the same but behave slightly different on iOS or Android. In addition to region monitoring, iOS also supports location reporting based on iBeacons.   iOS  Move  mode  In  move  mode, the app monitors location permanently and publishes a new\nlocation as soon as the device moves  x  meters or after  t  seconds, whatever\nhappens first.  x  and  t  can be adjusted by the user in the systems settings for\nOwnTracks. The defaults are 100m and 300 seconds (5 minutes).   The payoff is higher battery usage as high as in navigation or tracker app.\nSo it is recommend to use  move  mode while charging or during moves only - hence the name.  Please note,  move  mode is active when the app is active (a.k.a in foreground).  Significant location change  mode  iOS defines a  Significant location change  as traveling a distance of at least\n500 meters in 5 minutes.  This mode allows the app to run in background and\nminimize the power consumption.  This standard tracking mode reports significant location changes only ( 500m\nand at most once every 5 minutes).  This is defined by Apple and is optimal\nwith respect to battery usage.  Examples:   if you don't move, no new location is published - even if you don't move for hours. (Note, however, that the app will publish a  ping -type message once in a while.)  if you move at least 500 meters, a new location will be published after 5 minutes  if you move 10 kilometers in 5 minutes, only one location will be published   Manual  mode  The app doesn't monitor location changes in  manual  mode while in background.\nThe user has to publish the current location explicitly via the UI. You use this if\nyou want to (temporarily) avoid friends seeing where you are. Note that Region events\ntriggered by entering or leaving Geo Fence or Beacon regions\nare still published automatically whilst in  Manual  mode.  Quiet  mode  Same as  Manual  mode except that no region events are published.  Region  monitoring  The app user may mark a previously manually published or manually created \nlocation as a monitored circular region by specifying a monitoring radius in meters. (See  Waypoints .)\nThe app will publish the location\nadditionally every time the device leaves or enters one of the regions, and the\npublished data contains an indication of whether the device is entering or\nleaving the region.  Region monitoring is not related to one of the location publication modes and\nworks independently thereof. It is switched on when a region is setup with description\nand radius. To switch region monitoring off, all regions have to be \nunmarked (by setting their radius to 0).  Regions are shown on the map display in transparent blue or red circles. Red\nindicates the device is is within the region.  iBeacon monitoring  The app user may mark a previously manually published or manually created location\nas a monitored beacon region by appending a beacon UUID to the region's name.\nThe app will publish the location\nadditionally every time the device leaves or enters one of the beacon regions, and the\npublished data contains an indication of whether the device is entering or\nleaving the region.  Region monitoring is not related to one of the location publication modes and\nworks independently. It is switched on when a region's name has a valid UUID\nappended to it.  If the device is within a monitored beacon region, the the beacon indicator\nis shown in red, otherwise blue meaning device is not in any iBeacon region.  There are 2 kinds of locations:   an  automatic location  created when iOS detects a change of location  a  manual location  created by the user   A  manual location  with a non-zero length remark (description) is a  waypoint .  A  waypoint 's attributes are published when the waypoint is created or changed.  If a  waypoint  specifies a radius, a  circular region  is monitored for  enter/leave events .  If a  waypoint  is not a  circular region  and the waypoint's description contains a valid iBeacon specification, a  beacon region  is monitored for enter/leave events.  If an enter/leave event occurs an event message is published with the  type  attribute set to  c or  b for ( circular region_or _beacon region ). The message contains an  event  attribute specifying either  enter or  leave .  The description of the  waypoint  is added to the published  event  message.     Automatic  Description  iBeacon  Radius  Event Message  /w Description  Waypoint Message      Y  n/a  n/a  n/a  N  N  N    N  N  n/a  n/a  N  N  N    N  Y  N  N  N  N  Y    N  Y  N  Y  c  N  N    N  Y  N  Y  c  Y  Y    N  Y  Y  N  b  N  N    N  Y  Y  N  b  Y  Y    N  Y  Y  Y  c  N  N    N  Y  Y  Y  c  Y  Y     Android  Move  mode  In  move  mode, the app monitors device location permanently. It requests a location fix every 30s in high power mode and publishes a new location as soon as it arrives but at most every 10 seconds.   This mode mostly relies on GPS location data and is hence the most accurate. The payoff is a higher battery usage.\nIt is recommend to use  move  mode while charging or during periods that require highly accurate tracking while moving quickly.   Significant location change  mode  This standard tracking mode is aimed at everyday usage for location tracking in the background. It uses a balanced power location request that gathers a new location fix every 15 minutes. Location data from other apps is reused and published as soon as it arrives but at most every 10 seconds.   This mode relies mostly on cell tower and WiFi location to conserve power to provide location data that is sufficiently accurate for most users.   In addition to the default settings, all location request parameters in this mode can also be changed. These parameters directly influence the raw  location request  that is send to the Android location API. \n*  locatorInterval : Maximum time between new location fixes. This interval is inexact and updates may arrive faster. \n*  locatorDisplacement : The smallest displacement in meters the user must move between location updates. Defaults to 0 and is an  and  relationship with interval. Can be used to only receive updates when the device has moved. \n*  locatorPriority : The priority of the request is a strong hint to the LocationClient for which location sources to use.   Manual  mode  In  manual  mode, the app monitors device location with a low power location request. It uses the same interval configured for  significant mode  to receive low accuracy updates to use minimal battery power.   The user has to publish the current location explicitly via the UI. You use this if you want to (temporarily) avoid friends seeing where you are. Note that Region events triggered by entering or leaving Geo Fence are still published automatically whilst in  Manual  mode.  Remote  reportLocation  commands are ignored.   Quiet  mode  Same as  Manual  mode except that no region events are published.", 
            "title": "Location data"
        }, 
        {
            "location": "/features/tid/", 
            "text": "TID\n\n\nA \nTID\n is a \ntracker ID\n, a two-character identifier of your chosing, your initials, say. This \nTID\n is published in the \nJSON payload\n of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather \nlong topic name\n.\n\n\n\n\nThe \nTID\n of your \nfriends\n is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained \ncard\n published.", 
            "title": "Tracker ID"
        }, 
        {
            "location": "/features/tid/#tid", 
            "text": "A  TID  is a  tracker ID , a two-character identifier of your chosing, your initials, say. This  TID  is published in the  JSON payload  of each message published by OwnTracks and is meant to be used as a short identifier which is easier to read than a rather  long topic name .   The  TID  of your  friends  is displayed on the OwnTracks map if you don't have an address book entry associated with that friend, and if said friend has no retained  card  published.", 
            "title": "TID"
        }, 
        {
            "location": "/features/friends/", 
            "text": "Friends\n\n\nOwnTracks has a so-called \nFriends and Family\n capability which is enabled by\ndefault. The way this works is friends and/or family members who share a single\n\nMQTT broker\n can \"see\" eachother on the map, respectively on a\nlist of friends held by the app.  (This can be done either by configuring all\napps to use the same broker or by what is called \nbridging\n.)\n\n\nLet's assume for a moment, that a user Jane (user name \njjolie\n) has an iPhone 4s (device name \n4s\n), and that she publishes location data to a topic at\n\n\nowntracks/jjolie/4s\n\n\n\n\nLet us further assume, that her friend John (user name \njohn\n) has an Android Nexus 4 (device name \nnex4\n) and he therefore publishes on the \nsame broker\n to a topic called\n\n\nowntracks/john/nex4\n\n\n\n\nLet us further assume that access control on the \nMQTT broker\n allows both users to subscribe to eachother's topics.\n\n\nNow, if \nboth\n friends subscribe to a topic called \nowntracks/+/+\n (which the\napps do by default) their devices will effectively receive published location\nmessages to either topic. So when either Jane or John publish their location,\nthe other's device will receive it.\n\n\nWhat OwnTracks then does is to list these topic names (e.g. \nowntracks/jjolie/4s\n) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh?\n\n\nFaces\n\n\nIt gets better.\n\n\nYou probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that.\n\n\nDepending on the device you're using, the procedure differs slightly.\n\n\nAndroid\n\n\nThe app subscribes to a topic branch \nowntracks/+/+\n on the broker per default\nto receive locations of\nother people connected to the the same MQTT broker that publish\nto the default topic of \nowntracks/$username/$devicename\n.\n\n\nIt then reads \nCARD\ns to find friends' names and faces.\n\n\niOS\n\n\nThe app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is \nowntracks/+/+\n.\n\n\nSelect the \nFriends\n button to see a list of friends:\n\n\nTapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location.\n\n\nWho is that?\n\n\nIt's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book:\n\n\nSelect an entrythen click on the \nbookmark\n icon on top right. The Address book opens.\n\n\nSelect the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\").\n\n\nWhen you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map.\n\n\nVoila!", 
            "title": "Friends"
        }, 
        {
            "location": "/features/friends/#friends", 
            "text": "OwnTracks has a so-called  Friends and Family  capability which is enabled by\ndefault. The way this works is friends and/or family members who share a single MQTT broker  can \"see\" eachother on the map, respectively on a\nlist of friends held by the app.  (This can be done either by configuring all\napps to use the same broker or by what is called  bridging .)  Let's assume for a moment, that a user Jane (user name  jjolie ) has an iPhone 4s (device name  4s ), and that she publishes location data to a topic at  owntracks/jjolie/4s  Let us further assume, that her friend John (user name  john ) has an Android Nexus 4 (device name  nex4 ) and he therefore publishes on the  same broker  to a topic called  owntracks/john/nex4  Let us further assume that access control on the  MQTT broker  allows both users to subscribe to eachother's topics.  Now, if  both  friends subscribe to a topic called  owntracks/+/+  (which the\napps do by default) their devices will effectively receive published location\nmessages to either topic. So when either Jane or John publish their location,\nthe other's device will receive it.  What OwnTracks then does is to list these topic names (e.g.  owntracks/jjolie/4s ) with the last received position and a time stamp. A click on a particular entry will take you to that entry's location on the map. Neat, eh?  Faces  It gets better.  You probably don't want to remember the (sometimes cryptic) topic names of your friends or family members, but you would like to see their names and a matching face. That's no problem: OwnTracks can do that.  Depending on the device you're using, the procedure differs slightly.  Android  The app subscribes to a topic branch  owntracks/+/+  on the broker per default\nto receive locations of\nother people connected to the the same MQTT broker that publish\nto the default topic of  owntracks/$username/$devicename .  It then reads  CARD s to find friends' names and faces.  iOS  The app \"sees\" a friend as soon as it receives a publish to the topic branch subscribed to, which by default is  owntracks/+/+ .  Select the  Friends  button to see a list of friends:  Tapping on one of the friends, performs a reverse geo-coding to show address. Furthermore, a click on the little right-arrow shows their last location.", 
            "title": "Friends"
        }, 
        {
            "location": "/features/friends/#who-is-that", 
            "text": "It's difficult to remember which MQTT topic belongs to which friend, so we can associate a topic with an image of the friend as contained in the iOS address book:  Select an entrythen click on the  bookmark  icon on top right. The Address book opens.  Select the entry you want to associate with the OwnTracks topic. If you want to release the association, select the wastepaper basket icon in the address book screen. The display changes back from the picture and name of the friend to the mqtt topic (e.g. \"owntracks/kate/nexus4\").  When you zoom the map out (or near to the friend's location), you see a small rendition of the icon directly on the map.  Voila!", 
            "title": "Who is that?"
        }, 
        {
            "location": "/features/card/", 
            "text": "Card\n\n\nOwnTracks typically displays the \nTID\n of a \nfriend\n on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name.\n\n\n\n\nWe developed a new feature we call a \ncard\n which you can use when in \nPrivate mode\n (MQTT) or in \nHTTP mode\n. A card is a retained message which contains a \nJSON payload\n which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device.\n\n\n{\n  \n_type\n: \ncard\n,\n  \nname\n: \nJane Jolie\n,\n  \nface\n: \niV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg==\n\n}\n\n\n\n\nCreating a card\n\n\nCards can be created with shell scripts or with a webapp.\n\n\nShell Script\n\n\nWe provide several utilities for creating a \ncard\n in the \nRecorder's repository\n:\n\n\n\n\nIf you have an image file you want to use, use \nimage2card.sh\n, passing \nimage-filename\n and \nfullname\n.\n\n\nIf you know a user has a Github profile with a name and an avatar, use \ngithub2card.py\n which takes a Github username as argument.\n\n\nIf you know a user has a Gravatar, use \ngravatar2card.sh\n, passing \nemail\n and \nfullname\n.\n\n\n\n\nThese utilities create a \ncard\n on standard output, and you typically then publish the result as a retained message to your MQTT broker:\n\n\n./github2card.py defunkt \n my-card.json\nmosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r\n\n\n\n\nNote the topic branch ending in \ninfo\n and note the use of the retain flag (\n-r\n).\n\n\nWebapp\n\n\nA \nwebapp\n is available to create cards in your browser and optionally publish them directly to your MQTT broker.\n\n\nCards in Recorder in HTTP mode\n\n\nUsing HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in\n\n\nSTORAGEDIR\n/cards/\nuser\n/\nuser\n.json\n\n\n\n\nSo, if \n\"jane\"\n is a friend, the Recorder will load Jane's JSON card machine from the path \nSTORAGEDIR\n/cards/jane/jane.json.\n (The same card is loaded for all devices a user has.)\n\n\nIn \ncontrib/faces/\n of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the \n.json\n file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with \njq . \n file.json\n or \npython -mjson.tool file.json\n.)", 
            "title": "Card"
        }, 
        {
            "location": "/features/card/#card", 
            "text": "OwnTracks typically displays the  TID  of a  friend  on the map, but you can associate an address book entry to that friend on iOS in order to see a friendly face (if you have you friend's photo in your device's address book) and/or a friendly name.   We developed a new feature we call a  card  which you can use when in  Private mode  (MQTT) or in  HTTP mode . A card is a retained message which contains a  JSON payload  which, in absence of an address-book association, will be used to populate your friend on your map. The payload contains a full name (hopefully one you recognize), and an avatar -- a small image. If a card exists it will be used, but you can override its use in OwnTracks by associating your friend with an address book entry of your own device.  {\n   _type :  card ,\n   name :  Jane Jolie ,\n   face :  iV1CFEVkMhmCIKBUKh3 ... ghAAAAABJRU5ErkJggg== \n}  Creating a card  Cards can be created with shell scripts or with a webapp.  Shell Script  We provide several utilities for creating a  card  in the  Recorder's repository :   If you have an image file you want to use, use  image2card.sh , passing  image-filename  and  fullname .  If you know a user has a Github profile with a name and an avatar, use  github2card.py  which takes a Github username as argument.  If you know a user has a Gravatar, use  gravatar2card.sh , passing  email  and  fullname .   These utilities create a  card  on standard output, and you typically then publish the result as a retained message to your MQTT broker:  ./github2card.py defunkt   my-card.json\nmosquitto_pub -t owntracks/jjolie/phone/info -f my-card.json -r  Note the topic branch ending in  info  and note the use of the retain flag ( -r ).  Webapp  A  webapp  is available to create cards in your browser and optionally publish them directly to your MQTT broker.  Cards in Recorder in HTTP mode  Using HTTP mode in the OwnTracks Recorder will cause the Recorder to search for a friend's CARD in  STORAGEDIR /cards/ user / user .json  So, if  \"jane\"  is a friend, the Recorder will load Jane's JSON card machine from the path  STORAGEDIR /cards/jane/jane.json.  (The same card is loaded for all devices a user has.)  In  contrib/faces/  of the Recorder distribution there are some small utilities which can help create CARDs. Please make sure to verify that the  .json  file which you place into the directory is readable by the Recorder and is valid JSON. (You can test that with  jq .   file.json  or  python -mjson.tool file.json .)", 
            "title": "Card"
        }, 
        {
            "location": "/features/waypoints/", 
            "text": "Waypoints\n\n\nThe \nbase topic\n for publishes from the devices (OwnTracks apps) is what you configure it\nto be in the app's preferences/settings. For argument's sake we'll use the default \nowntracks/\nuser\n/\ndevice\n as our example.\n\n\nThis base topic is used for publishes of type \nlocation\n (see \nJSON\n).\nAll messages published to this base topic are retained if you have configured the app to retain them.\n\n\nAdditionally, if you've configured a waypoint or geo-fence, a transition event will be published upon\nentering or leaving a waypoint:\n\n\n\n\nrad\nius (if its value is greater than 0)\n\n\ndesc\nription with the name you set for the waypoint\n\n\nevent\n with a value of \n\"enter\"\n or \n\"leave\"\n, depending on\n   whether the device is entering or leaving a configured region, respectively.\n\n\n\n\nIf you set up a waypoint, the app publishes that waypoint (with \nretain=0\n \nirrespective of your general preference) to the base topic with \n/waypoints\n\ntacked onto the topic (e.g. \nowntracks/\nuser\n/\ndevice\n/waypoints\n) with the\npayload for \n_type=waypoint\n as specified in the \nJSON page\n. Entering or leaving a waypoint will be published as a \nlocation\n message as described above.\n\n\nFor example, If Jane configures a waypoint on her iPhone, the app could publish the following payload\n\n\n{\n    \n_type\n: \nwaypoint\n,\n    \ndesc\n: \nParis is lovely\n,\n    \nlat\n: \n48.858330\n,\n    \nlon\n: \n2.295130\n,\n    \nrad\n: \n50\n,\n    \ntst\n: \n1385997757\n\n}\n\n\n\n\nWhen you set up a waypoint (with a \ndesc\nription and a \nrad\nius), this\nwaypoint is published to the broker with the current time stamp. If you update\nthe waypoint definition on the device at a later stage, the waypoint is\nre-published, with the \noriginal\n timestamp, but with possibly new\n\ndesc\nription and/or \nrad\nius. To be precise, the \ntst\n timestamp is used as an\nidentifier of the waypoint even if it is later modified on the device.\n\n\nSubscribers to the broker (our apps and any other program) can avoid getting\nwaypoints by subscribing to, say, \nowntracks/+/+\n; also broker ACLs can\nprohibit access to \nowntracks/+/+/waypoints\n for particular users if so desired.\nConversely, all messages published by the apps (\nlocation\n and \nwaypoint\n) are\navailable with a subscription to \nowntracks/#\n.\n\n\nThe OwnTracks apps may keep track of waypoints, e.g. for displaying to users. \n\n\nAdding on iOS\n\n\nOn iOS you can navigate to the place where you want to put a waypoint, Tap long and edit the Waypoint. The waypoint is always placed at the center of the map (hence it's predefined name \nCenter\n, which you should change to something meaningful). With a bit of practice, you can then drag the waypoint to it's final destination on the map or, and this may be easier, edit the waypoint and specify its exact coordinates.\n\n\nAdding on Android\n\n\nOn Android, waypoints can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker.  \n\n\nRemote loading of waypoints\n\n\nInstead of configuring multiple waypoints on the device, they can be loaded \nremotely\n with the \nsetWaypoints\n cmd message if remote configuration is enabled on the device. \n\n\nYou can use this to import individual waypoints or groups of pre-configured waypoints which are merged into the existing waypoint definitions on the device. Recall, however, that the \ntst\n element is like a \nkey\n which uniquely identifies each waypoint.\n\n\nDeleting waypoints\n\n\nOn both iOS waypoints can be deleted by swiping it away. On Android, a long press is required. \n\n\nBeacons Ranging\n\n\nIn addition to circular regions, the iOS app can monitor its proximity to \nBLE Beacons\n.", 
            "title": "Waypoints"
        }, 
        {
            "location": "/features/waypoints/#waypoints", 
            "text": "The  base topic  for publishes from the devices (OwnTracks apps) is what you configure it\nto be in the app's preferences/settings. For argument's sake we'll use the default  owntracks/ user / device  as our example.  This base topic is used for publishes of type  location  (see  JSON ).\nAll messages published to this base topic are retained if you have configured the app to retain them.  Additionally, if you've configured a waypoint or geo-fence, a transition event will be published upon\nentering or leaving a waypoint:   rad ius (if its value is greater than 0)  desc ription with the name you set for the waypoint  event  with a value of  \"enter\"  or  \"leave\" , depending on\n   whether the device is entering or leaving a configured region, respectively.   If you set up a waypoint, the app publishes that waypoint (with  retain=0  \nirrespective of your general preference) to the base topic with  /waypoints \ntacked onto the topic (e.g.  owntracks/ user / device /waypoints ) with the\npayload for  _type=waypoint  as specified in the  JSON page . Entering or leaving a waypoint will be published as a  location  message as described above.  For example, If Jane configures a waypoint on her iPhone, the app could publish the following payload  {\n     _type :  waypoint ,\n     desc :  Paris is lovely ,\n     lat :  48.858330 ,\n     lon :  2.295130 ,\n     rad :  50 ,\n     tst :  1385997757 \n}  When you set up a waypoint (with a  desc ription and a  rad ius), this\nwaypoint is published to the broker with the current time stamp. If you update\nthe waypoint definition on the device at a later stage, the waypoint is\nre-published, with the  original  timestamp, but with possibly new desc ription and/or  rad ius. To be precise, the  tst  timestamp is used as an\nidentifier of the waypoint even if it is later modified on the device.  Subscribers to the broker (our apps and any other program) can avoid getting\nwaypoints by subscribing to, say,  owntracks/+/+ ; also broker ACLs can\nprohibit access to  owntracks/+/+/waypoints  for particular users if so desired.\nConversely, all messages published by the apps ( location  and  waypoint ) are\navailable with a subscription to  owntracks/# .  The OwnTracks apps may keep track of waypoints, e.g. for displaying to users.   Adding on iOS  On iOS you can navigate to the place where you want to put a waypoint, Tap long and edit the Waypoint. The waypoint is always placed at the center of the map (hence it's predefined name  Center , which you should change to something meaningful). With a bit of practice, you can then drag the waypoint to it's final destination on the map or, and this may be easier, edit the waypoint and specify its exact coordinates.  Adding on Android  On Android, waypoints can be configured on a separate activity. Coordinates for the geographical region can be entered by hand or by using the place picker.    Remote loading of waypoints  Instead of configuring multiple waypoints on the device, they can be loaded  remotely  with the  setWaypoints  cmd message if remote configuration is enabled on the device.   You can use this to import individual waypoints or groups of pre-configured waypoints which are merged into the existing waypoint definitions on the device. Recall, however, that the  tst  element is like a  key  which uniquely identifies each waypoint.  Deleting waypoints  On both iOS waypoints can be deleted by swiping it away. On Android, a long press is required.   Beacons Ranging  In addition to circular regions, the iOS app can monitor its proximity to  BLE Beacons .", 
            "title": "Waypoints"
        }, 
        {
            "location": "/features/beacons/", 
            "text": "iBeacons\n\n\nIf you want to monitor an iBeacon region rather than a circular region set the\nradius to zero (\n0\n) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers.\n\n\n\n\nSet the UUID of the beacon, and you can optionally specify the major and/or\nminor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor.\nSetting major or minor number to zero (\n0\n) means no major or minor number is specified.\nNote that you should probably not use major or minor number \n0\n, because the meaning of 0 is \"any\".\n\n\nIf the UUID is valid, iBeacon monitoring will start.\n\n\nExamples:\n\n\nName  myBeacons\nUUID  CA271EAE-5FA8-4E80-8F08-2A302A95A959\nMajor 0\nMinor 0\n\nName  mySpecificBeacon\nUUID  CA271EAE-5FA8-4E80-8F08-2A302A95A959\nMajor 1\nMinor 33000\n\n\n\n\nIn the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas\nin the second example, OwnTracks would monitor just that one specific beacon with the major number \n1\n and the minor number \n33000\n.\n\n\nNotes\n\n\nThe app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection.\n\n\nIf you use a \n-\n as the first character in your Waypoint description e.g. \n-MyBeacon\n, the app will ignore short disruptions of the connection to the beacon (hold down).\n\n\nSetting the radius to a negative value (e.g. \n-1\n) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the \nshare\n option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car.\n\n\nExample: office\n\n\nUpon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question.\n\n\n\n\nInstead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive \niBeacons\n can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably.\n\n\nBeacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined \nmajor\n and \nminor\n numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The \nmajor\n number can be used, say, to identify an office building, whereas you'd configure a beacon's \nminor\n number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same \nmajor\n and \nminor\n numbers.\n\n\nLet's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the \nmajor\n and \nminor\n numbers. (How a beacon gets it's UUID, \nmajor\n, and \nminor\n set depends on the product.)\n\n\nWe define a UUID, say, \nDEADBEEF-ABBA-CAFE-AFFE-123456789012\n which we assign to all beacons, and configure them accordingly. (The \nBlukii\n iBeacons we use have a utility with which we can configure them accordingly.)\n\n\nWhat we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose \nMain@WestWing\n here) by a colon. A beacon's \nmajor\n and \nminor\n are optionally concatenated to that string, also colon-separated.\n\n\nInstead of painstakingly configuring this on the device proper, I prepare a small file called \noffice.otrw\n (the \n.otrw\n extension is important), with the following \nJSON\n payload:\n\n\n{\n  \nwaypoints\n : [\n    {\n      \ntst\n : 1432817332,\n      \nlat\n : 52.0,\n      \n_type\n : \nwaypoint\n,\n      \nlon\n : 6.0,\n      \nrad\n : 0,\n      \ndesc\n : \nMain@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001\n\n    }\n  ],\n  \n_type\n : \nwaypoints\n\n}\n\n\n\n\nI then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured.\n\n\nFrom this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an \nenter\n or \nleave\n event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification.\n\n\n\n\nWe publish these \nevents as JSON\n via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please.\n\n\n{\n    \n_type\n: \ntransition\n,\n    \nacc\n: 65,\n    \ndesc\n: \nMain@WestWing\n,\n    \nevent\n: \nenter\n,\n    \nlat\n: 2.2222,\n    \nlon\n: 1.1111,\n    \ntid\n: \njp\n,\n    \ntst\n: 1433342520,\n    \nwtst\n: 1432817332\n}\n\n\n\n\nFor instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc.\n\n\nTo summarize: OwnTracks can monitor beacons by configuring it either with:\n\n\n\n\na \nUUID\n only, in which case the app would report any beacon with that UUID, irrespective of its \nmajor\n/\nminor\n numbers.\n\n\na \nUUID\n with a \nmajor\n number: the app would report iBeacons with the specified UUID and exactly that \nmajor\n number\n\n\nall three: the \nUUID\n, the \nmajor\n and \nminor\n numbers, in which case the app reports events on precisely that beacon.\n\n\n\n\nMore examples\n\n\n\n\nWhere exactly did I park my car?", 
            "title": "Beacons"
        }, 
        {
            "location": "/features/beacons/#ibeacons", 
            "text": "If you want to monitor an iBeacon region rather than a circular region set the\nradius to zero ( 0 ) or a negative value (iOS only), and add the beacon UUID, major, and minor numbers.   Set the UUID of the beacon, and you can optionally specify the major and/or\nminor identifier numbers of the beacons as a decimal number ranging from 1 to 65535 if you desire finer control over which beacons OwnTracks will monitor.\nSetting major or minor number to zero ( 0 ) means no major or minor number is specified.\nNote that you should probably not use major or minor number  0 , because the meaning of 0 is \"any\".  If the UUID is valid, iBeacon monitoring will start.  Examples:  Name  myBeacons\nUUID  CA271EAE-5FA8-4E80-8F08-2A302A95A959\nMajor 0\nMinor 0\n\nName  mySpecificBeacon\nUUID  CA271EAE-5FA8-4E80-8F08-2A302A95A959\nMajor 1\nMinor 33000  In the first example above, OwnTracks will monitor all beacons with the specified UUID, whereas\nin the second example, OwnTracks would monitor just that one specific beacon with the major number  1  and the minor number  33000 .", 
            "title": "iBeacons"
        }, 
        {
            "location": "/features/beacons/#notes", 
            "text": "The app recognizes the beacon typically within 10 seconds, which is a typical beacon-publishing frequency, and this is very good for presence detection.  If you use a  -  as the first character in your Waypoint description e.g.  -MyBeacon , the app will ignore short disruptions of the connection to the beacon (hold down).  Setting the radius to a negative value (e.g.  -1 ) on iOS, the app will update the location coordinates of the waypoint on each enter/leave event. This update will be transmitted to the broker when the  share  option is on and will be reflected on your map screen. You may use this to keep track of moveable items as luggage or your car.", 
            "title": "Notes"
        }, 
        {
            "location": "/features/beacons/#example-office", 
            "text": "Upon arriving at our Frankfurt location, I see from the monitor panel at the reception that Jane is in the office, so I'll pop in to ask a question.   Instead of relying solely on the location your smart phone thinks you are at, small, and relatively inexpensive  iBeacons  can pinpoint you down to a few meters. OwnTracks for iOS has had support for iBeacons for a few releases now, and it works very reliably.  Beacons use Bluetooth low energy to transmit a UUID (typically modifiable) together with user-defined  major  and  minor  numbers, and these allow us to identify, say, a particular room in a building or even a specific corner of a room. The  major  number can be used, say, to identify an office building, whereas you'd configure a beacon's  minor  number to identify a room within that building. Alternatively, if you don't want to bother with identifying rooms, you can e.g. set all beacons to have the same  major  and  minor  numbers.  Let's assume the office we're discussing has a few beacons. Let's further assume we do not want to track people within a particular room; instead we just want to capture whether an employee is in this particular office building. We can configure all beacons with the same UUID, and we will ignore the  major  and  minor  numbers. (How a beacon gets it's UUID,  major , and  minor  set depends on the product.)  We define a UUID, say,  DEADBEEF-ABBA-CAFE-AFFE-123456789012  which we assign to all beacons, and configure them accordingly. (The  Blukii  iBeacons we use have a utility with which we can configure them accordingly.)  What we then do is configure a waypoint within the iOS OwnTracks app. The values for latitude/longitude are irrelevant. What is important is the UUID separated from the name of the beacon (I chose  Main@WestWing  here) by a colon. A beacon's  major  and  minor  are optionally concatenated to that string, also colon-separated.  Instead of painstakingly configuring this on the device proper, I prepare a small file called  office.otrw  (the  .otrw  extension is important), with the following  JSON  payload:  {\n   waypoints  : [\n    {\n       tst  : 1432817332,\n       lat  : 52.0,\n       _type  :  waypoint ,\n       lon  : 6.0,\n       rad  : 0,\n       desc  :  Main@WestWing:DEADBEEF-ABBA-CAFE-AFFE-123456789012:0001 \n    }\n  ],\n   _type  :  waypoints \n}  I then either place that file on a Web server, or e-mail it as attachment to my colleagues who open that on their OwnTracks device, and presto: the device has the beacon monitoring regions configured.  From this point on, OwnTracks monitors all beacons with that particular UUID, and it will publish an  enter  or  leave  event whenever the device gets within range of a beacon or leaves it. Additionally, the device shows the event with a local iOS notification.   We publish these  events as JSON  via MQTT to the MQTT broker the device is connected to, and from there, you consume the message and do as you please.  {\n     _type :  transition ,\n     acc : 65,\n     desc :  Main@WestWing ,\n     event :  enter ,\n     lat : 2.2222,\n     lon : 1.1111,\n     tid :  jp ,\n     tst : 1433342520,\n     wtst : 1432817332\n}  For instance, send an e-mail when a particular person leaves the building, publish a list of people who remain in the building on a monitor (as above), etc.  To summarize: OwnTracks can monitor beacons by configuring it either with:   a  UUID  only, in which case the app would report any beacon with that UUID, irrespective of its  major / minor  numbers.  a  UUID  with a  major  number: the app would report iBeacons with the specified UUID and exactly that  major  number  all three: the  UUID , the  major  and  minor  numbers, in which case the app reports events on precisely that beacon.", 
            "title": "Example: office"
        }, 
        {
            "location": "/features/beacons/#more-examples", 
            "text": "Where exactly did I park my car?", 
            "title": "More examples"
        }, 
        {
            "location": "/features/pedometer/", 
            "text": "Pedometer\n\n\nThe iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only).\nThe way this works is that the iPhone counts the steps you take, and OwnTracks\ncan report these in a JSON payload upon request.\n\n\nCommand\n\n\nIn order for the app to actually report the steps counted by the device, you\nsend it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.)\n\n\nmosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{\n_type\n : \ncmd\n, \naction\n: \nreportSteps\n}'\n\n\n\n\nNote how we\u2019re using QoS=2 here: the message is published to the MQTT broker,\nand when the phone next wakes up, which happens every few hundred seconds, it\nwill obtain the message, and publish a \nJSON\n payload with the counted steps back\nto your MQTT broker.\n\n\n{\n    \n_type\n: \nsteps\n, \n    \nfrom\n: 1400455130, \n    \nsteps\n: 1234, \n    \nto\n: 1400458000, \n    \ntst\n: 1400455130\n}\n\n\n\n\nDaily reports\n\n\nWe use the following small program to issue the JSON needed to request the\nsteps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.)\n\n\n#!/usr/bin/env python\n\nimport datetime\nimport time\nimport json\nimport sys\n\ndays = 0\n\ndef unix_epoch(t, delta):\n    dt = t + delta\n\n    # print dt\n    return int(time.mktime(dt.timetuple()))\n\nnow = datetime.datetime.today()\n\nf = now.replace(now.year, now.month, now.day, 0, 0, 1, 0)\nt = now.replace(now.year, now.month, now.day, 23, 59, 59, 0)\n\ndelta = datetime.timedelta(days=days)\n\n\npayload = {\n        '_type' : 'cmd',\n        'action' : 'reportSteps',\n        'from'  : unix_epoch(f, delta),\n        'to'    : unix_epoch(t, delta),\n}\nprint json.dumps(payload)\n\n\n\n\nIn the evening, a \ncron\n entry sends that off to our broker which will, eventually,\ndeliver the message to the the phone.\n\n\n50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l\n\n\n\n\nDaily reports with Openhab\n\n\nWith openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab.\n\n\nAt first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg\n\n\nmqtt-retain.url=tcp://192.168.1.1:1884\nmqtt-retain.qos=2\n\n\n\n\nAfter that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents:\n\n\nrule \nMQTT_OWNTRACKS_STEPS\n\nwhen\n    // every day at 23:59\n    Time cron \n0 59 23 * * ? *\n\nthen\n    val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000\n    val long to1 = (now.millis / 1000)\n    publish(\nmqtt-retain\n,\nowntracks/jj/5s/cmd\n,'{\naction\n: \nreportSteps\n, \nto\n: '+ to1 +', \n_type\n: \ncmd\n, \nfrom\n: '+ from1 +'}')\nend\n\n\n\n\nFor usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items\n\n\nNumber Steps_Yesterday \n[%d]\n  { mqtt=\n[mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]\n }\n\n\n\n\nNow You can make use of yesterday's steps count.", 
            "title": "Pedometer"
        }, 
        {
            "location": "/features/pedometer/#pedometer", 
            "text": "The iPhone 5S has a built-in pedometer which we\u2019ve leveraged into OwnTracks (iOS only).\nThe way this works is that the iPhone counts the steps you take, and OwnTracks\ncan report these in a JSON payload upon request.  Command  In order for the app to actually report the steps counted by the device, you\nsend it a specially formatted command. (The device does not periodically publish steps on its own -- you must trigger it.)  mosquitto_pub -q 2 -t owntracks/jj/5s/cmd -m '{ _type  :  cmd ,  action :  reportSteps }'  Note how we\u2019re using QoS=2 here: the message is published to the MQTT broker,\nand when the phone next wakes up, which happens every few hundred seconds, it\nwill obtain the message, and publish a  JSON  payload with the counted steps back\nto your MQTT broker.  {\n     _type :  steps , \n     from : 1400455130, \n     steps : 1234, \n     to : 1400458000, \n     tst : 1400455130\n}  Daily reports  We use the following small program to issue the JSON needed to request the\nsteps for the 00:00 - 23:59 time-frame of this particular day (or the day before, etc.)  #!/usr/bin/env python\n\nimport datetime\nimport time\nimport json\nimport sys\n\ndays = 0\n\ndef unix_epoch(t, delta):\n    dt = t + delta\n\n    # print dt\n    return int(time.mktime(dt.timetuple()))\n\nnow = datetime.datetime.today()\n\nf = now.replace(now.year, now.month, now.day, 0, 0, 1, 0)\nt = now.replace(now.year, now.month, now.day, 23, 59, 59, 0)\n\ndelta = datetime.timedelta(days=days)\n\n\npayload = {\n        '_type' : 'cmd',\n        'action' : 'reportSteps',\n        'from'  : unix_epoch(f, delta),\n        'to'    : unix_epoch(t, delta),\n}\nprint json.dumps(payload)  In the evening, a  cron  entry sends that off to our broker which will, eventually,\ndeliver the message to the the phone.  50 22 * * * /usr/local/bin/reportsteps | mosquitto_pub -q 2 -t owntracks/jpm/5s/cmd -l  Daily reports with Openhab  With openhab it's quite easy to user rules engine from openhab and to not rely on servers crontab.  At first you have to define mqtt retain broker (MQTT v. 1 is used) - simply add configuration to /etc/openhab2/services/mqtt.cfg  mqtt-retain.url=tcp://192.168.1.1:1884\nmqtt-retain.qos=2  After that make a simple rule in /etc/openhab2/rules/ directory. Lets say the filename is /etc/openhab2/rules/owntracks.rules with contents:  rule  MQTT_OWNTRACKS_STEPS \nwhen\n    // every day at 23:59\n    Time cron  0 59 23 * * ? * \nthen\n    val long from1 = DateTime.now().withTimeAtStartOfDay().millis / 1000\n    val long to1 = (now.millis / 1000)\n    publish( mqtt-retain , owntracks/jj/5s/cmd ,'{ action :  reportSteps ,  to : '+ to1 +',  _type :  cmd ,  from : '+ from1 +'}')\nend  For usage the info in sitemaps or anywhere else 1 more item has to be made into file /etc/openhab2/items/owntracks.items  Number Steps_Yesterday  [%d]   { mqtt= [mqtt:owntracks/jj/5s/step:state:JSONPATH($.steps)]  }  Now You can make use of yesterday's steps count.", 
            "title": "Pedometer"
        }, 
        {
            "location": "/features/featured/", 
            "text": "Featured\n\n\nThe iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type \ncmd\n:\n\n\n{\naction\n: \naction\n, \ncontent\n: \nhello there!\n, \n_type\n: \ncmd\n}\n\n\n\n\nYou can use \nurl\n instead of \ncontent\n in the payload, in which case the tab opens with the appropriate URL loaded.\n\n\n{\naction\n: \naction\n, \nurl\n: \nhttp://example.com\n, \n_type\n: \ncmd\n}\n\n\n\n\nThe tab pops up silently, i.e. without notification, and selecting the tab displays it.\n\n\nThe open tab silently disappears if content and url are omitted.\n\n\nSee also:\n\n\n\n\nSwitching lights with OwnTracks, iBeacons, and openHAB", 
            "title": "Featured"
        }, 
        {
            "location": "/features/featured/#featured", 
            "text": "The iOS app has a new tab (hidden by default) which is shown when it receives a particular MQTT message of type  cmd :  { action :  action ,  content :  hello there! ,  _type :  cmd }  You can use  url  instead of  content  in the payload, in which case the tab opens with the appropriate URL loaded.  { action :  action ,  url :  http://example.com ,  _type :  cmd }  The tab pops up silently, i.e. without notification, and selecting the tab displays it.  The open tab silently disappears if content and url are omitted.  See also:   Switching lights with OwnTracks, iBeacons, and openHAB", 
            "title": "Featured"
        }, 
        {
            "location": "/features/encrypt/", 
            "text": "Payload encryption\n\n\nIn addition to the \ntransport encryption via TLS\n, the OwnTracks apps support payload encryption using \nlibsodium\n, in particular \nsecret-key authenticated encryption\n. We have also implemented support for payload encryption (i.e. decryption) in the \nOwnTracks Recorder\n.\n\n\nYou configure a \nsecret\n (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt the \nJSON\n with this secret and transport the payload in a new JSON object which looks like this:\n\n\n{\n  \n_type\n: \nencrypted\n,\n  \ndata\n: \n1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg=\n\n}\n\n\n\n\nIf you want to share location with a friend, both you and your friend need to share the same \nsecret\n. A \nsecret\n should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different \nsecret\n keys.\n\n\nRecorder\n\n\nYou can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder.\n\n\nAdd a key by determining the \nusername\n and the \ndevice name\n of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the \nusername\n is \njjolie\n and the \ndevice name\n is \nPhone\n, the result will be \njjolie-phone\n.\n\n\nLoad the key into the (running) Recorder:\n\n\necho \njjolie-phone mysecreTpass01\n | ocat --load=keys\n\n\n\n\nFrom this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of \n_type: encrypted\n. The Recorder will decrypt the payload and will store the result in plain text in its storage.", 
            "title": "Encryption"
        }, 
        {
            "location": "/features/encrypt/#payload-encryption", 
            "text": "In addition to the  transport encryption via TLS , the OwnTracks apps support payload encryption using  libsodium , in particular  secret-key authenticated encryption . We have also implemented support for payload encryption (i.e. decryption) in the  OwnTracks Recorder .  You configure a  secret  (which you keep secret) in the app's settings. From this moment onwards, the apps encrypt the  JSON  with this secret and transport the payload in a new JSON object which looks like this:  {\n   _type :  encrypted ,\n   data :  1Vu7Owp ... W4lMnh28FB+el22GsCrlnggvEcp4H8GR9iKJdi1qfwkejYpzrQ+491Mwunjg= \n}  If you want to share location with a friend, both you and your friend need to share the same  secret . A  secret  should be kept secret; it is an up to 32 octet long passphrase (which the apps pad with binary zeroes) which is required both for encryption as well as for decryption of the payloads. It is not possible to share locations with a friend's device using different  secret  keys.  Recorder  You can set up multiple decryption keys on the Recorder (but not in the apps). This is to enable, say, different people to use different secrets on the same Recorder.  Add a key by determining the  username  and the  device name  of the client app. Lowercase these, and create a string with the two values separated with a dash. Suppose the  username  is  jjolie  and the  device name  is  Phone , the result will be  jjolie-phone .  Load the key into the (running) Recorder:  echo  jjolie-phone mysecreTpass01  | ocat --load=keys  From this moment onwards, the Recorder will use this secret key for this username/device combination when it receives JSON payloads of  _type: encrypted . The Recorder will decrypt the payload and will store the result in plain text in its storage.", 
            "title": "Payload encryption"
        }, 
        {
            "location": "/features/remoteconfig/", 
            "text": "Configuration file\n\n\nThe configuration can be send to the device as a file that can by imported into the apps. This can be used to initially configure the device or chane detailed settings later. \n\n\n\n\nCreate a configuration file in JSON with an \n.otrc\n suffix (for OwnTracks Configuration)\n\n\nEnsure the JSON is valid with \nonline JSON validator\n, \njq\n or simply by running \npython -mjson.tool \n your.otrc\n\n\nSend the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, ... you name it.\n\n\nHave the OwnTracks app user open the file on their device with OwnTracks.\n\n\n\n\nHere is a sample configuration file which contains some of the possible settings.\n\n\n{\n  \n_type\n: \nconfiguration\n,\n  \nauth\n: true,\n  \nusername\n: \njjolie\n,\n  \npassword\n: \ns1kr3t\n,\n  \nhost\n: \nmybroker.example.org\n,\n  \nport\n: 8883,\n}\n\n\n\n\nThe \n_type\nentry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described \non the JSON page\n.\n\n\nsetConfiguration\n\n\nThe configuration of a connected app can also be changed remotely if \nRemote Commands\n is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A \n_type: configuration\n as described \non the JSON page\n can be send to the device. \n\n\nsetWaypoints\n\n\nWaypoints can be configured remotely if \nRemote Commands\n is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the \ntst\n timestamp, so overwriting an existing \ntst\n actually overwrites an existing waypoint.)\n\n\n{\n  \n_type\n: \ncmd\n,\n  \naction\n: \nsetWaypoints\n,\n  \nwaypoints\n: {\n    \nwaypoints\n: [\n      {\n        \ndesc\n: \nSome place\n,\n        \nrad\n: 8867,\n        \nlon\n: 10.428771973,\n        \nlat\n: 46.935260881,\n        \ntst\n: 1437552714,\n        \n_type\n: \nwaypoint\n\n      }\n    ],\n    \n_type\n: \nwaypoints\n\n  }\n}\n\n\n\n\nPublishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints.", 
            "title": "Remoteconfig"
        }, 
        {
            "location": "/features/remoteconfig/#configuration-file", 
            "text": "The configuration can be send to the device as a file that can by imported into the apps. This can be used to initially configure the device or chane detailed settings later.    Create a configuration file in JSON with an  .otrc  suffix (for OwnTracks Configuration)  Ensure the JSON is valid with  online JSON validator ,  jq  or simply by running  python -mjson.tool   your.otrc  Send the file to the devices via e-mail, provide it for download on an HTTP server, send via Dropbox, ... you name it.  Have the OwnTracks app user open the file on their device with OwnTracks.   Here is a sample configuration file which contains some of the possible settings.  {\n   _type :  configuration ,\n   auth : true,\n   username :  jjolie ,\n   password :  s1kr3t ,\n   host :  mybroker.example.org ,\n   port : 8883,\n}  The  _type entry is mandatory, most other entries are optional. They are replaced by built-in defaults or previously configured values if not specified. A list of all possible settings is described  on the JSON page .", 
            "title": "Configuration file"
        }, 
        {
            "location": "/features/remoteconfig/#setconfiguration", 
            "text": "The configuration of a connected app can also be changed remotely if  Remote Commands  is enabled on the device, by publishing a JSON payload which is merged into existing configuration. A  _type: configuration  as described  on the JSON page  can be send to the device.", 
            "title": "setConfiguration"
        }, 
        {
            "location": "/features/remoteconfig/#setwaypoints", 
            "text": "Waypoints can be configured remotely if  Remote Commands  is enabled on the device, by publishing a JSON payload which is merged into existing waypoints. (Note: the \"key\" for a waypoint is the  tst  timestamp, so overwriting an existing  tst  actually overwrites an existing waypoint.)  {\n   _type :  cmd ,\n   action :  setWaypoints ,\n   waypoints : {\n     waypoints : [\n      {\n         desc :  Some place ,\n         rad : 8867,\n         lon : 10.428771973,\n         lat : 46.935260881,\n         tst : 1437552714,\n         _type :  waypoint \n      }\n    ],\n     _type :  waypoints \n  }\n}  Publishing the above payload to an OwnTracks iOS device will create/modify said waypoint. This also works for Beacon configurations, which are basically waypoints.", 
            "title": "setWaypoints"
        }, 
        {
            "location": "/features/debug/", 
            "text": "Debugging\n\n\nDesigning mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest. \nChristoph and Alexander\n know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today.\n\n\nBe that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for.\n\n\nFirst and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory.\n\n\n\n\nCheck whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so.\n\n\nIs your broker running and can it be reached by your device? We've \ngiven you tips on configuring your broker\n.\n\n\nMake liberal use of the Mosquitto \nclients\n to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.", 
            "title": "Debugging"
        }, 
        {
            "location": "/features/debug/#debugging", 
            "text": "Designing mobile apps is hard. Designing mobile apps which are killed off every once in a while by the underlying OS is harder (iOS). Designing mobile apps which reliable do what they should at all times is hardest.  Christoph and Alexander  know this and they've done a hell of a job to get stability and reliability of OwnTracks to where it stands today.  Be that as it may, there are things which can be difficult to test, and in this section we give you some things to watch out for.  First and foremost, and please don't laugh: does your device have either WiFi or 3G connectivity? No data means no location reported, which ought to be self-explanatory.   Check whether OwnTracks is connected to your broker. On iOS this is the green mushroom symbol on the map; on Android you can check in preferences. If need be, disconnect and reconnect OwnTracks and check your broker's logfile as you do so.  Is your broker running and can it be reached by your device? We've  given you tips on configuring your broker .  Make liberal use of the Mosquitto  clients  to test whether your broker is receiving messages, and please ensure your broker ACLs match the settings in OwnTracks.", 
            "title": "Debugging"
        }, 
        {
            "location": "/features/traccar/", 
            "text": "Traccar\n\n\nTraccar\n is a free and open source GPS tracking system for which there exists an \nOwnTracks\n protocol decoder (called \nowntracks\n)  which is, by default, configured on TCP port 5144 on the Traccar server:\n\n\nentry key='owntracks.port'\n5144\n/entry\n\n\n\n\n\nThus you need to configure OwnTracks clients \nin HTTP mode\n to connect to your Traccar server at this port, using a URL such as\n\n\nhttp://traccar.example.net:5144\n\n\n\n\nTo make Traccar accept a connection from an owntracks client, you need to set a matching \nidentifier\n. This identifier is per default the \ntid\n of your device. If you have configured a \ntopic\n for your device, owntracks will identify  using the \ntopic\n instead of the \ntid\n (currently iOS only). \n\n\n\n\nAn example of a configuration using a \ntopic\n of \nowntracks/jane/phone\n to identify against the Traccar server.\n\n\nNotes\n\n\n\n\nNeither encryption nor friends are supported in Traccar.\n\n\nIf you see a 400 error in the Traccar log, this means the \nidentifier\n you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one, \ntid\n or \ntopic\n.\n\n\n\n\nHTTP Payloads\n\n\nHTTP POST payloads shall contain at least the elements \nlat\n, \nlon\n, \n_type:location\n, \ntst\n, and either or both of \ntid\n and \ntopic\n. If \ntopic\n is contained in the payload, that will be used as Traccar's \nidentifier\n (in which case \ntid\n will be added to attributes), else \ntid\n.\n\n\n{\nlon\n:2.29513,\nlat\n:48.85833,\n_type\n:\nlocation\n,\ntst\n:1497476456, \ntid\n:\nJJ\n}\n\n\n\n\n{\nlon\n:2.29513,\nlat\n:48.85833,\n_type\n:\nlocation\n,\ntopic\n:\nowntracks/jane/phone\n, \ntid\n: \nJJ\n}\n\n\n\n\nThe following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes: \nvel\n, \nalt\n, \ncog\n, \nacc\n, \nt\n, \nbatt\n, so with an HTTP payload that an OwnTracks app produces like\n\n\n{\n  \ncog\n: 271,\n  \nbatt\n: 41,\n  \nlon\n: 2.29513,\n  \nacc\n: 5,\n  \nvel\n: 61,\n  \nvac\n: 21,\n  \nlat\n: 48.85833,\n  \nt\n: \nu\n,\n  \ntst\n: 1497508651,\n  \nalt\n: 167,\n  \n_type\n: \nlocation\n,\n  \ntopic\n: \nowntracks/jane/iphone\n,\n  \np\n: 71,\n  \ntid\n: \nJJ\n\n}\n\n\n\n\na query on the Traccar API could produce something like this:\n\n\n[\n  {\n    \nid\n: 475,\n    \nattributes\n: {\n      \nt\n: \nu\n,\n      \nbattery\n: 41,\n      \ntid\n: \nJJ\n,\n      \nip\n: \n127.0.0.1\n,\n      \ndistance\n: 0,\n      \ntotalDistance\n: 0\n    },\n    \ndeviceId\n: 4,\n    \ntype\n: null,\n    \nprotocol\n: \nowntracks\n,\n    \nserverTime\n: \n2017-06-15T06:37:32.000+0000\n,\n    \ndeviceTime\n: \n2017-06-15T06:37:31.000+0000\n,\n    \nfixTime\n: \n2017-06-15T06:37:31.000+0000\n,\n    \noutdated\n: false,\n    \nvalid\n: true,\n    \nlatitude\n: 48.85833,\n    \nlongitude\n: 2.29513,\n    \naltitude\n: 167,\n    \nspeed\n: 1.18575,\n    \ncourse\n: 271,\n    \naddress\n: \n9 Avenue Anatole France, Paris, \u00cele-de-France, FR\n,\n    \naccuracy\n: 5,\n    \nnetwork\n: null\n  }\n]", 
            "title": "Traccar"
        }, 
        {
            "location": "/features/traccar/#traccar", 
            "text": "Traccar  is a free and open source GPS tracking system for which there exists an  OwnTracks  protocol decoder (called  owntracks )  which is, by default, configured on TCP port 5144 on the Traccar server:  entry key='owntracks.port' 5144 /entry   Thus you need to configure OwnTracks clients  in HTTP mode  to connect to your Traccar server at this port, using a URL such as  http://traccar.example.net:5144  To make Traccar accept a connection from an owntracks client, you need to set a matching  identifier . This identifier is per default the  tid  of your device. If you have configured a  topic  for your device, owntracks will identify  using the  topic  instead of the  tid  (currently iOS only).    An example of a configuration using a  topic  of  owntracks/jane/phone  to identify against the Traccar server.  Notes   Neither encryption nor friends are supported in Traccar.  If you see a 400 error in the Traccar log, this means the  identifier  you configured for the Traccar device doesn't match the one sent by the OwnTracks app; try the other one,  tid  or  topic .   HTTP Payloads  HTTP POST payloads shall contain at least the elements  lat ,  lon ,  _type:location ,  tst , and either or both of  tid  and  topic . If  topic  is contained in the payload, that will be used as Traccar's  identifier  (in which case  tid  will be added to attributes), else  tid .  { lon :2.29513, lat :48.85833, _type : location , tst :1497476456,  tid : JJ }  { lon :2.29513, lat :48.85833, _type : location , topic : owntracks/jane/phone ,  tid :  JJ }  The following JSON elements, if they're contained in the HTTP payload, will be added to Traccar's position attributes:  vel ,  alt ,  cog ,  acc ,  t ,  batt , so with an HTTP payload that an OwnTracks app produces like  {\n   cog : 271,\n   batt : 41,\n   lon : 2.29513,\n   acc : 5,\n   vel : 61,\n   vac : 21,\n   lat : 48.85833,\n   t :  u ,\n   tst : 1497508651,\n   alt : 167,\n   _type :  location ,\n   topic :  owntracks/jane/iphone ,\n   p : 71,\n   tid :  JJ \n}  a query on the Traccar API could produce something like this:  [\n  {\n     id : 475,\n     attributes : {\n       t :  u ,\n       battery : 41,\n       tid :  JJ ,\n       ip :  127.0.0.1 ,\n       distance : 0,\n       totalDistance : 0\n    },\n     deviceId : 4,\n     type : null,\n     protocol :  owntracks ,\n     serverTime :  2017-06-15T06:37:32.000+0000 ,\n     deviceTime :  2017-06-15T06:37:31.000+0000 ,\n     fixTime :  2017-06-15T06:37:31.000+0000 ,\n     outdated : false,\n     valid : true,\n     latitude : 48.85833,\n     longitude : 2.29513,\n     altitude : 167,\n     speed : 1.18575,\n     course : 271,\n     address :  9 Avenue Anatole France, Paris, \u00cele-de-France, FR ,\n     accuracy : 5,\n     network : null\n  }\n]", 
            "title": "Traccar"
        }, 
        {
            "location": "/tech/json/", 
            "text": "Types\n\n\nOwnTracks publishes its message payloads in \nJSON\n format. The different payload types are identified by a \n_type\n element. Depending on the app platform, different payload types are supported.\n\n\n\n\n\n\n\n\n_type\n\n\niOS\n\n\nAndroid\n\n\n\n\n\n\n\n\n\n\nbeacon\n\n\nY\n\n\nN\n\n\n\n\n\n\ncard\n\n\nY\n\n\nY\n\n\n\n\n\n\ncmd\n\n\nY\n\n\nY\n\n\n\n\n\n\nconfiguration\n\n\nY\n\n\nY\n\n\n\n\n\n\nencrypted\n\n\nY\n\n\nY\n\n\n\n\n\n\nlocation\n\n\nY\n\n\nY\n\n\n\n\n\n\nlwt\n\n\nY\n\n\nY\n\n\n\n\n\n\nsteps\n\n\nY\n\n\nN\n\n\n\n\n\n\ntransition\n\n\nY\n\n\nY\n\n\n\n\n\n\nwaypoint\n\n\nY\n\n\nY\n\n\n\n\n\n\nwaypoints\n\n\nY\n\n\nY\n\n\n\n\n\n\n\n\nTopics\n\n\nIn MQTT mode the apps publish to:\n\n\n\n\nowntracks/user/device\n with \n_type=location\n for location updates, and with \n_type=lwt\n\n\nowntracks/user/device/cmd\n with \n_type=cmd\n for remote commands\n\n\nowntracks/user/device/event\n with \n_type=transition\n for enter/leave events\n\n\nowntracks/user/device/step\n to report step counter\n\n\nowntracks/user/device/beacon\n for beacon ranging\n\n\nowntracks/user/device/dump\n for config dumps\n\n\n\n\nIn MQTT mode apps subscribe to:\n\n\n\n\nowntracks/user/device/cmd\n if remote commands are enabled\n\n\nowntracks/+/+\n for seeing other user's locations, depending on broker ACL\n\n\nowntracks/+/+/event\n for transition messages (\nenter\n/\nleave\n)\n\n\nowntracks/+/+/info\n for obtaining \ncards\n.\n\n\n\n\nIn HTTP mode the apps POST their data to a single endpoint you configure.\n\n\n_type=location\n\n\nThis location object describes the location of the device that reported it.\n\n\n{\n    \n_type\n : \nlocation\n,\n    elements\n}\n\n\n\n\n\n\nacc\n Accuracy of the reported location in meters without unit \n(iOS,Android/integer/meters/optional)\n\n\nalt\n Altitude measured above sea level \n(iOS,Android/integer/meters/optional)\n\n\nbatt\n Device battery level \n(iOS,Android/integer/percent/optional)\n\n\nbs\n Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full  \n(iOS)\n\n\ncog\n Course over ground \n(iOS/integer/degree/optional)\n\n\nlat\n latitude \n(iOS,Android/float/degree/required)\n\n\nlon\n longitude \n(iOS,Android/float/degree/required)\n\n\nrad\n radius around the region when entering/leaving \n(iOS/integer/meters/optional)\n\n\nt\n trigger for the location report \n(iOS,Android/string/optional)\n\n\np\n ping issued randomly by background task \n(iOS,Android)\n\n\nc\n circular region enter/leave event \n(iOS,Android)\n\n\nb\n beacon region enter/leave event \n(iOS)\n\n\nr\n response to a reportLocation cmd message \n(iOS,Android)\n\n\nu\n manual publish requested by the user \n(iOS,Android)\n\n\nt\n timer based publish in move move \n(iOS)\n\n\nv\n updated by \nSettings/Privacy/Locations Services/System Services/Frequent Locations\n monitoring \n(iOS)\n\n\n\n\n\n\ntid\n Tracker ID used to display the initials of a user \n(iOS,Android/string/optional)\n required for \nhttp\n mode\n\n\ntst\n UNIX \nepoch timestamp\n in seconds of the location fix \n(iOS,Android/integer/epoch/required)\n\n\nvac\n vertical accuracy of the \nalt\n element \n(iOS/integer/meters/optional)\n\n\nvel\n velocity \n(iOS,Android/integer/kmh/optional)\n\n\np\n barometric pressure \n(iOS/float/kPa/optional/extended data)\n\n\nconn\n Internet connectivity status (route to host) when the message is created \n(iOS,Android/string/optional/extended data)\n\n\nw\n phone is connected to a WiFi connection \n(iOS,Android)\n\n\no\n phone is offline \n(iOS,Android)\n\n\nm\n mobile data \n(iOS,Android)\n\n\n\n\n\n\ntopic\n (only in HTTP payloads) contains the original publish topic (e.g. \nowntracks/jane/phone\n). \n(iOS)\n\n\ninregions\n contains a list of regions the device is currently in (e.g. \n[\"Home\",\"Garage\"]\n). Might be empty. \n(iOS,Android/list of strings/optional)\n\n\n\n\nNotes\n\n\n\n\nThe \ntst\n in a ping is a \ncurrent timestamp\n, so that it doesn't look like a duplicate.\n\n\nThe \ntid\n defaults to the last two characters of the topic\n\n\nA missing \nt\n element also indicates an automatic location update\n\n\nA publish of \n\"_type\": \"location\"\n with a \n\"b\"\n trigger is sent when an iOS device enters or leaves a beacon in addition to a \n\"_type\": \"transition\"\n: if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated.\n\n\nThe \nacc\n, \nalt\n, \ncog\n, \nvac\n, \nvel\n elements are only added if they are not zero\n\n\nSome Android devices always return 0 for \nalt\n or \nvel\n\n\nElements marked with \nextended data\n are only added if \nextendedData=true\n is configured\n\n\n\n\nGreenwich\n\n\nThe OwnTracks edition of the \nChoral Greenwich\n device reports the following additional elements in a \n_type=location\n message:\n\n\n{\n    \n_type\n: \nlocation\n,\n    elements\n}\n\n\n\n\n\n\nalt\n Altitude measured above sea level \n(integer/meters/optional)\n\n\nbatt\n Device battery level \n(integer/percent/optional)\n\n\ncog\n Course over ground \n(integer/degree/optional)\n\n\ndist\n Distance travelled since the last location report \n(integer/meters/optional)\n\n\ntrip\n Distance travelled since the last reboot \n(integer/meters/optional)\n\n\nvel\n velocity \n(integer/kmh/optional)\n\n\nt\n trigger for the location report \n(string/optional)\n\n\nf\n First publish after reboot\n\n\nm\n Manually requested locations (e.g. by publishing to \n/cmd\n)\n\n\nt\n Time for location published because device is moving.\n\n\nT\n Time for location published because of time passed while device is stationary (\nmaxInterval\n)\n\n\nk\n Transitioning from \nmove\n to \nstationary\n (park)\n\n\nv\n Transitioning from \nstationary\n to \nmove\n (mo-v-e)\n\n\nl\n Last known position when device lost GPS fix\n\n\nL\n Last known position before gracefull shutdown\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nThe device can be configured to produce or not produce fields marked as \noptional\n\n\n\n\nQueclink\n\n\nOwnTracks works with a selection of trackers by \nQueclink\n, for which the protocol conversion is done via \nqtripp\n.\nQueclink devices report the following additional elements in a \n_type=location\n message:\n\n\n{\n    \n_type\n: \nlocation\n,\n    elements\n}\n\n\n\n\n\n\n\n\nt\n trigger for the location report \n(string/optional)\n\n\n\n\no\n Corner\n\n\nM\n Mileage\n\n\n!\n Tow or fake tow or sensor without ignition\n\n\na\n motionless (aka park)\n\n\ni\n ignition on\n\n\nI\n ignition off\n\n\ne\n external power off\n\n\nE\n external power ON\n\n\n1\n Devices powered up\n\n\n2\n Battery stop charging\n\n\n3\n Battery start charging\n\n\n9\n Battery power low\n\n\nh\n harsh behavior\n\n\ns\n speed alarm\n\n\n\n\n\n\n\n\nodometer\n total distance of the device \n(float/kilometers/optional)\n\n\n\n\nhmc\n total hours of operation \n(float/seconds/optional)\n\n\nubatt\n voltage of the battery \n(float/volts/optional)\n\n\nuext\n voltage of the external power source \n(float/volts/optional)\n\n\nvin\n vehicle identification number \n(string/optional)\n\n\nimei\n identification number \n(string/optional)\n\n\nname\n vehicle name \n(string/optional)\n\n\ndon\n is duration since ignition on \n(float/seconds/optional)\n\n\ndoff\n is duration since ignition off \n(float/seconds/optional)\n\n\naiv\n is analog input voltage \n(float/volts/optional)\n\n\nrpm\n is engine rounds per minute \n(float/rounds per minute/optional)\n\n\nfcon\n is fuel consumption \n(float/L per 100km/optional)\n\n\nflvl\n is fuel level \n(float/percent/optional)\n\n\nanum\n is number of analog inputs \n(integer/optional)\n\n\nadid-xx\n is id of analog input number xx \n(string/optional)\n\n\nadty-xx\n is type of analog input number xx \n(string/optional)\n\n\nadda-xx\n is data of analog input number xx \n(string/optional)\n\n\ntemp_c-xx\n is temperature of analog input number xx \n(float/celsius/optional)\n\n\ncan\n is can data \n(string/optional)\n\n\ndin1\n is status of digital input 1 \n(boolean/optional)\n\n\ndin2\n is status of digital input 2 \n(boolean/optional)\n\n\ndout1\n is status of digital output 1 \n(boolean/optional)\n\n\ndout2\n is status of digital output 2 \n(boolean/optional)\n\n\nign\n is status of ignition \n(boolean/optional)\n\n\nmotion\n is motion status \n(boolean/optional)\n\n\ntow\n is status of tow sensor \n(boolean/optional)\n\n\nfake\n is status of fake tow sensor \n(boolean/optional)\n\n\nsens\n is status of motion sensor \n(boolean/optional)\n\n\nsent\n is epoch when message was sent \n(integer/epoch/optional)\n\n\nmcc\n is mobile country code \n(integer/optional)\n\n\nmnc\n is mobile network code \n(integer/optional)\n\n\nlac\n is location area code \n(string/optional)\n\n\ncid\n is cell id \n(string/optional)\n\n\nnmds\n is non movement detection status \n(boolean/optional)\n\n\nrit\n queclink record id and type \n(integer/optional)\n\n\nrty\n queclink record type \n(integer/optional)\n\n\nrid\n queclink record id \n(integer/optional)\n\n\nmst\n queclink motion state \n(integer/optional)\n\n\ncount\n is counter of message \n(string/optional)\n\n\nraw_line\n raw data \n(string/optional)\n\n\ncounter\n number of ignored positions \n(integer/optional)\n\n\nignored\n indicates counter positions have been ignored \n(boolean/optional)\n\n\n\n\nNotes\n\n\n\n\nThe device can be configured to produce or not produce fields marked as \noptional\n\n\n\n\n_type=lwt\n\n\nA \nlast will and testament\n is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this:\n\n\n{\n    \n_type\n:\nlwt\n,\n    elements\n}\n\n\n\n\n\n\ntst\n UNIX \nepoch timestamp\n at which the app first connected \n(iOS,Android/integer/epoch/required)\n\n\n\n\n_type=waypoint\n\n\nWaypoints denote specific geographical regions that you want to keep track of. You define a waypoint in the OwnTracks app, and OwnTracks publishes this waypoint. OwnTracks also monitors these waypoints and will publish \n{_type: \"transition\", ...}\n message when entering or leaving the region. A waypoint may also define a BLE \nBeacon\n instead of a geographical region.\n\n\n{\n    \n_type\n  : \nwaypoint\n,\n    elements\n}\n\n\n\n\n\n\ndesc\n Name of the waypoint that is included in the sent transition message \n(iOS,Android,string/required)\n\n\nlat\n Latitude  \n(iOS,Android/float/meters/optional)\n\n\nlon\n Longitude \n(iOS,Android/float/meters/optional)\n\n\nrad\n Radius around the latitude and longitude coordinates \n(iOS,Android/integer/meters/optional)\n\n\ntst\n Timestamp of waypoint \ncreation to identify the waypoint. Copied into the \nwtst\n element of the transition message \n(iOS,Android/integer/epoch/required)_\n\n\nuuid\n UUID of the BLE Beacon \n(iOS/string/optional)\n\n\nmajor\n Major number of the BLE Beacon \n(iOS/integer/optional)\n\n\nminor\n  Minor number of the BLE Beacon_(iOS/integer/optional)_\n\n\n\n\nNotes\n\n\n\n\nIn iOS version \n= 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the \ndesc\n element.\n\n\nIf \nlat\n, \nlon\n and \nrad\n elements are present, transition messages are sent when entering and leaving the geographical region\n\n\nIf \nuuid\n, \nmajor\n, \nminor\n elements are present, BLE becons with that specifications are monitored\n\n\nBeacons and Geographical regions can be defined together\n\n\nWaypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage.\n\n\nWaypoints are sent to the broker and transition messages contain a \ndesc\n and \nevent\n element.\n\n\n\n\n_type=transition\n\n\nA transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained.\n\n\n{\n    \n_type\n: \ntransition\n,\n    elements\n}\n\n\n\n\n\n\nwtst\n Timestamp of waypoint creation \n(iOS,Android/integer/epoch/required)\n\n\nlat\n Latitude at which the event occured \n(iOS,Android/float/meters/optional)\n\n\nlon\n Longitue at which the event occured \n(iOS,Android/float/meters/optional)\n\n\ntst\n Timestamp at which the event occured \n(iOS,Android/integer/epoch/required)\n\n\nacc\n Accuracy of the geographical coordinates \n(iOS,Android/float/meters/required)\n\n\ntid\n Tracker ID of the waypoint \n(iOS/string/none/optional)\n\n\nevent\n Event that triggered the transition (iOS,Android/string/required)\n\n\nenter\n The device entered the defined geographical region or BLE Beacon range \n(iOS)\n\n\nleave\n The device left the defined geographical region or BLE Beacon range \n(iOS)\n\n\n\n\n\n\ndesc\n Name of the waypoint \n(iOS,Android/string/optional)\n\n\ntid\n TrackerID required in http mode.\n\n\nt\n Trigger of the event \n(iOS,Android/string/optional)\n\n\nc\n Circular geographical region  \n(iOS, Android)\n\n\nb\n BLE Beacon \n(iOS)\n\n\nl\n Loction update \n(Android)\n\n\n\n\n\n\n\n\n_type=configuration\n\n\nThe device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages.\n\n\n{\n    \n_type\n: \nconfiguration\n,\n    elements\n}\n\n\n\n\n\n\nallowRemoteLocation\n Respond to reportLocation cmd message \n(iOS,Android/boolean)\n\n\nallowinvalidcerts\n Allow self signed certificates in user defined security policy \n(iOS/boolean)\n\n\nauth\n Use \nusername\n and \npassword\n for endpoint authentication \n(iOS,Android/boolean)\n\n\n\n\nautostartOnBoot\n Autostart the app on device boot \n(Android/boolean)\n\n\n\n\n\n\ncleanSession\n MQTT endpoint clean session \n(iOS,Android/boolean)\n\n\n\n\nclientId\n client id to use for MQTT connect. Defaults to \"\nuser\n \ndeviceId\n\" \n(iOS,Android/string)\n\n\nclientpkcs\n Name of the client pkcs12 file \n(iOS/string)\n\n\ncmd\n Respond to cmd messages \n(iOS,Android/boolean)\n\n\ndeviceId\n id of the device used for \npubTopicBase\n and \nclientId\n construction. Defaults to the os name of the device  \n(iOS,Android/string)\n\n\nextendedData\n Add extended data attributes to location messages \n(iOS,Android/boolean)\n\n\nhost\n MQTT endpoint host \n(iOS,Android/string)\n\n\nignoreInaccurateLocations\n Location accuracy below which reports are supressed \n(iOS,Android/integer/meters)\n\n\nignoreStaleLocations\n Number of days after which location updates are assumed stale \n(iOS,Android/integer/days)\n\n\nkeepalive\n MQTT endpoint keepalive \n(iOS,Android/integer/seconds)\n\n\nlocatorDisplacement\n maximum distance between location source updates \n(iOS,Android/integer/meters)\n\n\nlocatorInterval\n maximum interval between location source updates \n(iOS,Android/integer/seconds)\n\n\nlocatorPriority\n source/power setting for location updates \n(Android/integer/)\n\n\n0\n NO_POWER / best accuracy possible with zero additional power consumption \n(Android)\n\n\n1\n LOW_POWER / city level accuracy \n(Android)\n\n\n2\n BALANCED_POWER / block level accuracy based on Wifi/Cell \n(Android)\n\n\n3\n HIGH_POWER / most accurate accuracy based on GPS \n(Android)\n\n\n\n\n\n\nlocked\n Locks settings screen on device for editing \n(iOS/boolean)\n\n\nmode\n Endpoint protocol mode \n(iOS,Android/integer)\n\n\n0\n Private  MQTT \n(iOS, Android)\n\n\n3\n Private  HTTP \n(iOS, Android)\n\n\n\n\n\n\nmonitoring\n Location reporting mode \n(iOS,Android/integer)\n\n\n-1\n Quiet\n\n\n0\n Manual\n\n\n1\n Significant\n\n\n2\n Move\n\n\n\n\n\n\nmqttProtocolLevel\n MQTT broker protocol level \n(iOS,Android/integer)\n\n\n3\n MQTT 3 (default)\n\n\n4\n MQTT 3.1.1\n\n\n\n\n\n\nnotificationGeocoder\n Resolve last reported location in ongoing notification to an address  \n(Android/boolean)\n\n\nnotificationLocation\n Show last reported location in ongoing notification \n(Android/boolean)\n\n\nopencageApiKey\n API key for alternate Geocoding provider. See https://opencagedata.com/ for details. \n(Android/string)\n\n\npassphrase\n Passphrase of the client pkcs12 file \n(iOS/string)\n\n\npassword\n Endpoint password \n(iOS,Android/string)\n\n\nping\n Interval in which location messages of with \nt\n:\np\n are reported \n(Android/integer)\n\n\npolicymode\n User defined securiy policy mode \n(iOS/integer)\n\n\n0\n Do not used pinned certificates to validate servers\n\n\n1\n Validate host certificates against public keys of pinned certificates\n\n\n2\n Validate host certificates against pinned certificates\n\n\n\n\n\n\nport\n MQTT endpoint port \n(iOS,Android/integer)\n\n\npositions\n Number of locations to keep and display \n(iOS/integer)\n\n\npubTopicBase\n MQTT topic base to which the app publishes; \n%u\n is replaced by the user name, \n%d\n by device   \n(iOS,Android/string)\n\n\npubRetain\n MQTT retain flag for reported messages \n(iOS,Android/boolean)\n\n\npubQos\n MQTT QoS level for reported messages \n(iOS,Android/integer)\n\n\nranging\n Beacon ranging \n(iOS/boolean)\n\n\nremoteConfiguration\n Allow remote configuration by sending a \nsetConfiguration\n cmd message \n(Android/boolean)\n\n\nservercer\n Blank separated list of certificate file names in DER format \n(iOS/string)\n\n\nsub\n subscribe to \nsubTopic\n via MQTT \n(iOS,Android/boolean)\n\n\nsubTopic\n A whitespace separated list of MQTT topics to which the app subscribes if \nsub\n is true (defaults see \ntopics\n)   \n(iOS,Android/string)\n\n\nsubQos\n \n(iOS,Android/boolean)\n\n\ntid\n Two digit Tracker ID used to display short name and default face of a user \n(iOS,Android/string)\n\n\ntls\n MQTT endpoint TLS connection \n(iOS,Android/boolean)\n\n\ntlsClientCrtPassword\n Passphrase of the client pkcs12 file \n(Android/string)\n\n\nurl\n HTTP endpoint URL to which messages are POSTed \n(iOS,Android/string)\n\n\nusepolicy\n Use user defined security policy \n(iOS/boolean)\n\n\nusername\n Endpoint username \n(iOS,Android/string)\n\n\nvalidatedomainname\n Validate domain name during TLS handshake \n(iOS/boolean)\n\n\nvalidatecertificatechain\n Validate the whole certificate chain or just the server certificate \n(iOS/boolean)\n\n\nwillRetain\n\n\nwillTopic\n\n\nwillQos\n\n\nwaypoints\n Array of waypoint messages \n(iOS,Android/array)\n\n\n\n\nNotes\n\n\n\n\nWhen importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a \nmode\n element, the mode is changed first and all remaining elements are imported for the new mode.\n\n\nIn MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if \nkeepalive\n was 60). Afterwards, an \nlwt\n message will be send.\n\n\n\n\n_type=beacon\n\n\nThese messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life.\n\n\n{\n    \n_type\n:\nbeacon\n,\n    elements\n}\n\n\n\n\n\n\ndesc\n name of the seen beacon \n(iOS/String)\n\n\nuuid\n UUID of the seen beacon \n(iOS/String)\n\n\nmajor\n Major number of the seen beacon \n(iOS/integer/epoch)\n\n\nminor\n Minor number of the seen beacon \n(iOS/integer/epoch)\n\n\ntst\n Timestamp at which the beacon was seen \n(iOS/integer/epoch)\n\n\nacc\n Accuracy of the proximity value \n(iOS/integer/meters)\n\n\nrssi\n Received signal strength of the beacon \n(iOS/integer/decibel)\n\n\nprox\nRelative distance to the beacon \n(iOS/integer)\n\n\n0\n Proximity of the beacon could not be determined\n\n\n1\n Beacon is in the immediate vicinity\n\n\n2\n Beacon is relatively close to the user\n\n\n3\n Beacon is far away\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nThe theoretical relationship between RSSI and distance is \nRSSI[dbm] = \u2212(10n log10(d) \u2212 A)\n where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon.\n\n\n\n\n_type=cmd\n\n\n{\n_type\n:\ncmd\n,\naction\n:\nreportLocation\n}\n{\n_type\n:\ncmd\n,\naction\n:\nreportSteps\n}\n{\n_type\n:\ncmd\n,\naction\n:\ndump\n}\n{\n_type\n:\ncmd\n,\naction\n:\nwaypoints\n}\n{\n_type\n:\ncmd\n,\naction\n:\nsetConfiguration\n,\nconfiguration\n:{\n_type\n:\nconfiguration\n,...}\n{\n_type\n:\ncmd\n,\naction\n:\nsetWaypoints\n,\nwaypoints\n:{\n_type\n:\nwaypoints\n,\nwaypoints\n:[...]}\n{\n_type\n:\ncmd\n,\naction\n:\naction\n,\ncontent\n:\nBackend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org\n}\n{\n_type\n:\ncmd\n,\naction\n:\naction\n,\ncontent\n:\na href='http://support.owntracks.org'\nBackend Maintenance tonight\n/a\n}\n{\n_type\n:\ncmd\n,\naction\n:\naction\n,\nurl\n:\nhttp://support.owntracks.org\n}\n{\n_type\n:\ncmd\n,\naction\n:\naction\n,\nnotification\n:\nWarning! Battery low\n}\n\n\n\n\n\n\naction\n action to be performed by the device \n(iOS,Android/string)\n\n\naction\n Inserts an additional \nFeatured Content\n tab in the UI \n(iOS)\n\n\ndump\n Triggers the publish of a \nconfiguration\n message \n(iOS)\n\n\nreportSteps\n Triggers the report of a \nsteps\n messages_(iOS)_\n\n\nfrom\n Timestamp \n(iOS/epoch/optional)\n\n\nto\n Timestamp \n(iOS/epoch/optional)\n\n\n\n\n\n\nreportLocation\n Triggers the publish of a \nlocation\n messages \n(iOS,Android)\n\n\nsetWaypoints\n Imports (merge) and activates new waypoints \n(iOS,Android)\n\n\nwaypoints\n Array of \nwaypoint\n messages to import \n(iOS,Android/array/required)\n\n\n\n\n\n\nsetConfiguration\n Imports and activates new configuration values \n(iOS,Android)\n\n\nconfiguration\n Configuration message to import \n(iOS,Android/required)\n\n\n\n\n\n\nwaypoints\n Triggers publish of a \nwaypoints\n message \n(iOS,Android)\n\n\n\n\nNotes\n\n\n\n\nIf \nurl\n for the \naction\n cmd message is specified, the URL is opened in a full screen web view within the app\n\n\nIf the optional \nextern\n boolean is \ntrue\n a click on the notification will launch an external browser instead\n\n\nIf \nurl\n is not specified the text of the \ncontent\n element is displayed. Links embedded in the text are operational.\n\n\nIf the \ncontent\n consists of HTML, it is rendered\n\n\nThe \nFeatured Content\n tab can be removed with an \naction\n cmd message without \ncontent\n and without \nurl\n element\n\n\n\n\nIf the \naction\n cmd contains a \nnotification\n element, the value of the element is shown in the app\n\n\n\n\n\n\nOn iOS, the array of waypoints to the \nsetWaypoints\n command allows updates / removal; the key of the waypoint is its name (\ndesc\n). If you specify an invalid \nlat\n or \nlon\n (invalid means out of range number value e.g. \n-1000000\n, a string like \n\"foo\"\n will result in a \n0\n in app) the waypoint is deleted.\n\n\n\n\n\n\n_type=steps\n\n\n{\n    \n_type\n:\nsteps\n,\n    elements\n}\n\n\n\n\n\n\ntst\n Timestamp of the request \n(iOS/integer/epoch)\n\n\nsteps\n Steps walked with the device in the specfied time period  \n(iOS/integer/steps)\n\n\nfrom\n Effective start of time period \n(iOS/integer/epoch)\n\n\nto\n  Effective end of time period \n(iOS/integer/epoch)\n\n\n\n\nNotes\n\n\n\n\nsteps\n is -1 if device does not support step counting or specified time period is invalid\n\n\n\n\n_type=card\n\n\nApps read \nCard\n to display a name and icon for a user.\n\n\n{\n    \n_type\n: \ncard\n,\n    elements\n}\n\n\n\n\n\n\nname\n Name to identify a user \n(iOS,Android/string/optional)\n\n\nface\n Base64 encoded PNG image that is displayed instead of the Tracker ID \n(iOS,Android/string/optional)\n\n\ntid\n The tracker ID with which a friend is associated in the apps\n\n\n\n\n_type=waypoints\n\n\nThe app can export a list of configured waypoints to the endpoint.\n\n\n{\n    \n_type\n: \nwaypoints\n,\n    elements\n}\n\n\n\n\n\n\n_creator\n Identification of what created the array. Ignored by the apps \n(iOS,Android/string/optional)\n\n\nwaypoints\n Array of \nwaypoint\n messages \n(iOS,Android/array/required)\n\n\n\n\n_type=encrypted\n\n\nApps can optionally \nencrypt\n outgoing messages with a shared symmetric key.\nThe encrypted message is contained in the \ndata\nelement.\nFor security reasons, the encryption key is not exported with configuration messages and cannot be imported.\n\n\n{\n    \n_type\n: \nencrypted\n,\n    elements\n}\n\n\n\n\n\n\ndata\n Encrypted and Base64 encoded original JSON message \n(iOS,Android/string/required)", 
            "title": "JSON"
        }, 
        {
            "location": "/tech/json/#types", 
            "text": "OwnTracks publishes its message payloads in  JSON  format. The different payload types are identified by a  _type  element. Depending on the app platform, different payload types are supported.     _type  iOS  Android      beacon  Y  N    card  Y  Y    cmd  Y  Y    configuration  Y  Y    encrypted  Y  Y    location  Y  Y    lwt  Y  Y    steps  Y  N    transition  Y  Y    waypoint  Y  Y    waypoints  Y  Y", 
            "title": "Types"
        }, 
        {
            "location": "/tech/json/#topics", 
            "text": "In MQTT mode the apps publish to:   owntracks/user/device  with  _type=location  for location updates, and with  _type=lwt  owntracks/user/device/cmd  with  _type=cmd  for remote commands  owntracks/user/device/event  with  _type=transition  for enter/leave events  owntracks/user/device/step  to report step counter  owntracks/user/device/beacon  for beacon ranging  owntracks/user/device/dump  for config dumps   In MQTT mode apps subscribe to:   owntracks/user/device/cmd  if remote commands are enabled  owntracks/+/+  for seeing other user's locations, depending on broker ACL  owntracks/+/+/event  for transition messages ( enter / leave )  owntracks/+/+/info  for obtaining  cards .   In HTTP mode the apps POST their data to a single endpoint you configure.", 
            "title": "Topics"
        }, 
        {
            "location": "/tech/json/#_typelocation", 
            "text": "This location object describes the location of the device that reported it.  {\n     _type  :  location ,\n    elements\n}   acc  Accuracy of the reported location in meters without unit  (iOS,Android/integer/meters/optional)  alt  Altitude measured above sea level  (iOS,Android/integer/meters/optional)  batt  Device battery level  (iOS,Android/integer/percent/optional)  bs  Battery Status 0=unknown, 1=unplugged, 2=charging, 3=full   (iOS)  cog  Course over ground  (iOS/integer/degree/optional)  lat  latitude  (iOS,Android/float/degree/required)  lon  longitude  (iOS,Android/float/degree/required)  rad  radius around the region when entering/leaving  (iOS/integer/meters/optional)  t  trigger for the location report  (iOS,Android/string/optional)  p  ping issued randomly by background task  (iOS,Android)  c  circular region enter/leave event  (iOS,Android)  b  beacon region enter/leave event  (iOS)  r  response to a reportLocation cmd message  (iOS,Android)  u  manual publish requested by the user  (iOS,Android)  t  timer based publish in move move  (iOS)  v  updated by  Settings/Privacy/Locations Services/System Services/Frequent Locations  monitoring  (iOS)    tid  Tracker ID used to display the initials of a user  (iOS,Android/string/optional)  required for  http  mode  tst  UNIX  epoch timestamp  in seconds of the location fix  (iOS,Android/integer/epoch/required)  vac  vertical accuracy of the  alt  element  (iOS/integer/meters/optional)  vel  velocity  (iOS,Android/integer/kmh/optional)  p  barometric pressure  (iOS/float/kPa/optional/extended data)  conn  Internet connectivity status (route to host) when the message is created  (iOS,Android/string/optional/extended data)  w  phone is connected to a WiFi connection  (iOS,Android)  o  phone is offline  (iOS,Android)  m  mobile data  (iOS,Android)    topic  (only in HTTP payloads) contains the original publish topic (e.g.  owntracks/jane/phone ).  (iOS)  inregions  contains a list of regions the device is currently in (e.g.  [\"Home\",\"Garage\"] ). Might be empty.  (iOS,Android/list of strings/optional)   Notes   The  tst  in a ping is a  current timestamp , so that it doesn't look like a duplicate.  The  tid  defaults to the last two characters of the topic  A missing  t  element also indicates an automatic location update  A publish of  \"_type\": \"location\"  with a  \"b\"  trigger is sent when an iOS device enters or leaves a beacon in addition to a  \"_type\": \"transition\" : if somebody leaves and enters his home without having left the radius of detection for significant changes, a subscriber to his main topic would otherwise not get notified of any location change although beacon or circular region enter and leave transitions were generated.  The  acc ,  alt ,  cog ,  vac ,  vel  elements are only added if they are not zero  Some Android devices always return 0 for  alt  or  vel  Elements marked with  extended data  are only added if  extendedData=true  is configured   Greenwich  The OwnTracks edition of the  Choral Greenwich  device reports the following additional elements in a  _type=location  message:  {\n     _type :  location ,\n    elements\n}   alt  Altitude measured above sea level  (integer/meters/optional)  batt  Device battery level  (integer/percent/optional)  cog  Course over ground  (integer/degree/optional)  dist  Distance travelled since the last location report  (integer/meters/optional)  trip  Distance travelled since the last reboot  (integer/meters/optional)  vel  velocity  (integer/kmh/optional)  t  trigger for the location report  (string/optional)  f  First publish after reboot  m  Manually requested locations (e.g. by publishing to  /cmd )  t  Time for location published because device is moving.  T  Time for location published because of time passed while device is stationary ( maxInterval )  k  Transitioning from  move  to  stationary  (park)  v  Transitioning from  stationary  to  move  (mo-v-e)  l  Last known position when device lost GPS fix  L  Last known position before gracefull shutdown     Notes   The device can be configured to produce or not produce fields marked as  optional   Queclink  OwnTracks works with a selection of trackers by  Queclink , for which the protocol conversion is done via  qtripp .\nQueclink devices report the following additional elements in a  _type=location  message:  {\n     _type :  location ,\n    elements\n}    t  trigger for the location report  (string/optional)   o  Corner  M  Mileage  !  Tow or fake tow or sensor without ignition  a  motionless (aka park)  i  ignition on  I  ignition off  e  external power off  E  external power ON  1  Devices powered up  2  Battery stop charging  3  Battery start charging  9  Battery power low  h  harsh behavior  s  speed alarm     odometer  total distance of the device  (float/kilometers/optional)   hmc  total hours of operation  (float/seconds/optional)  ubatt  voltage of the battery  (float/volts/optional)  uext  voltage of the external power source  (float/volts/optional)  vin  vehicle identification number  (string/optional)  imei  identification number  (string/optional)  name  vehicle name  (string/optional)  don  is duration since ignition on  (float/seconds/optional)  doff  is duration since ignition off  (float/seconds/optional)  aiv  is analog input voltage  (float/volts/optional)  rpm  is engine rounds per minute  (float/rounds per minute/optional)  fcon  is fuel consumption  (float/L per 100km/optional)  flvl  is fuel level  (float/percent/optional)  anum  is number of analog inputs  (integer/optional)  adid-xx  is id of analog input number xx  (string/optional)  adty-xx  is type of analog input number xx  (string/optional)  adda-xx  is data of analog input number xx  (string/optional)  temp_c-xx  is temperature of analog input number xx  (float/celsius/optional)  can  is can data  (string/optional)  din1  is status of digital input 1  (boolean/optional)  din2  is status of digital input 2  (boolean/optional)  dout1  is status of digital output 1  (boolean/optional)  dout2  is status of digital output 2  (boolean/optional)  ign  is status of ignition  (boolean/optional)  motion  is motion status  (boolean/optional)  tow  is status of tow sensor  (boolean/optional)  fake  is status of fake tow sensor  (boolean/optional)  sens  is status of motion sensor  (boolean/optional)  sent  is epoch when message was sent  (integer/epoch/optional)  mcc  is mobile country code  (integer/optional)  mnc  is mobile network code  (integer/optional)  lac  is location area code  (string/optional)  cid  is cell id  (string/optional)  nmds  is non movement detection status  (boolean/optional)  rit  queclink record id and type  (integer/optional)  rty  queclink record type  (integer/optional)  rid  queclink record id  (integer/optional)  mst  queclink motion state  (integer/optional)  count  is counter of message  (string/optional)  raw_line  raw data  (string/optional)  counter  number of ignored positions  (integer/optional)  ignored  indicates counter positions have been ignored  (boolean/optional)   Notes   The device can be configured to produce or not produce fields marked as  optional", 
            "title": "_type=location"
        }, 
        {
            "location": "/tech/json/#_typelwt", 
            "text": "A  last will and testament  is published automatically by the MQTT broker when it loses contact with the app. This typically looks like this:  {\n     _type : lwt ,\n    elements\n}   tst  UNIX  epoch timestamp  at which the app first connected  (iOS,Android/integer/epoch/required)", 
            "title": "_type=lwt"
        }, 
        {
            "location": "/tech/json/#_typewaypoint", 
            "text": "Waypoints denote specific geographical regions that you want to keep track of. You define a waypoint in the OwnTracks app, and OwnTracks publishes this waypoint. OwnTracks also monitors these waypoints and will publish  {_type: \"transition\", ...}  message when entering or leaving the region. A waypoint may also define a BLE  Beacon  instead of a geographical region.  {\n     _type   :  waypoint ,\n    elements\n}   desc  Name of the waypoint that is included in the sent transition message  (iOS,Android,string/required)  lat  Latitude   (iOS,Android/float/meters/optional)  lon  Longitude  (iOS,Android/float/meters/optional)  rad  Radius around the latitude and longitude coordinates  (iOS,Android/integer/meters/optional)  tst  Timestamp of waypoint  creation to identify the waypoint. Copied into the  wtst  element of the transition message  (iOS,Android/integer/epoch/required)_  uuid  UUID of the BLE Beacon  (iOS/string/optional)  major  Major number of the BLE Beacon  (iOS/integer/optional)  minor   Minor number of the BLE Beacon_(iOS/integer/optional)_   Notes   In iOS version  = 9.1.0 the last three elements (uuid, major, and minor) are used to configure Beacon waypoints instead of encoding these values into the  desc  element.  If  lat ,  lon  and  rad  elements are present, transition messages are sent when entering and leaving the geographical region  If  uuid ,  major ,  minor  elements are present, BLE becons with that specifications are monitored  Beacons and Geographical regions can be defined together  Waypoint messages are published non-retained because the second waypoint would overwrite the first: a client would only get the last one which makes no sense. Your application will typically store waypoints to some kind of persistent storage.  Waypoints are sent to the broker and transition messages contain a  desc  and  event  element.", 
            "title": "_type=waypoint"
        }, 
        {
            "location": "/tech/json/#_typetransition", 
            "text": "A transition message is sent, when entering or leaving a previously configured geographical region or BLE Beacon. In addition to the coordinates where the event fired, the message contains the timestamp of the waypoint creation as well as the event that triggered the transition message with its description. MQTT transition messages are published non retained.  {\n     _type :  transition ,\n    elements\n}   wtst  Timestamp of waypoint creation  (iOS,Android/integer/epoch/required)  lat  Latitude at which the event occured  (iOS,Android/float/meters/optional)  lon  Longitue at which the event occured  (iOS,Android/float/meters/optional)  tst  Timestamp at which the event occured  (iOS,Android/integer/epoch/required)  acc  Accuracy of the geographical coordinates  (iOS,Android/float/meters/required)  tid  Tracker ID of the waypoint  (iOS/string/none/optional)  event  Event that triggered the transition (iOS,Android/string/required)  enter  The device entered the defined geographical region or BLE Beacon range  (iOS)  leave  The device left the defined geographical region or BLE Beacon range  (iOS)    desc  Name of the waypoint  (iOS,Android/string/optional)  tid  TrackerID required in http mode.  t  Trigger of the event  (iOS,Android/string/optional)  c  Circular geographical region   (iOS, Android)  b  BLE Beacon  (iOS)  l  Loction update  (Android)", 
            "title": "_type=transition"
        }, 
        {
            "location": "/tech/json/#_typeconfiguration", 
            "text": "The device configuration can be imported and exported as JSON. The exported configuration can contain an array of waypoints that are defined on the device. If enabled, apps also accept remote configuration messages.  {\n     _type :  configuration ,\n    elements\n}   allowRemoteLocation  Respond to reportLocation cmd message  (iOS,Android/boolean)  allowinvalidcerts  Allow self signed certificates in user defined security policy  (iOS/boolean)  auth  Use  username  and  password  for endpoint authentication  (iOS,Android/boolean)   autostartOnBoot  Autostart the app on device boot  (Android/boolean)    cleanSession  MQTT endpoint clean session  (iOS,Android/boolean)   clientId  client id to use for MQTT connect. Defaults to \" user   deviceId \"  (iOS,Android/string)  clientpkcs  Name of the client pkcs12 file  (iOS/string)  cmd  Respond to cmd messages  (iOS,Android/boolean)  deviceId  id of the device used for  pubTopicBase  and  clientId  construction. Defaults to the os name of the device   (iOS,Android/string)  extendedData  Add extended data attributes to location messages  (iOS,Android/boolean)  host  MQTT endpoint host  (iOS,Android/string)  ignoreInaccurateLocations  Location accuracy below which reports are supressed  (iOS,Android/integer/meters)  ignoreStaleLocations  Number of days after which location updates are assumed stale  (iOS,Android/integer/days)  keepalive  MQTT endpoint keepalive  (iOS,Android/integer/seconds)  locatorDisplacement  maximum distance between location source updates  (iOS,Android/integer/meters)  locatorInterval  maximum interval between location source updates  (iOS,Android/integer/seconds)  locatorPriority  source/power setting for location updates  (Android/integer/)  0  NO_POWER / best accuracy possible with zero additional power consumption  (Android)  1  LOW_POWER / city level accuracy  (Android)  2  BALANCED_POWER / block level accuracy based on Wifi/Cell  (Android)  3  HIGH_POWER / most accurate accuracy based on GPS  (Android)    locked  Locks settings screen on device for editing  (iOS/boolean)  mode  Endpoint protocol mode  (iOS,Android/integer)  0  Private  MQTT  (iOS, Android)  3  Private  HTTP  (iOS, Android)    monitoring  Location reporting mode  (iOS,Android/integer)  -1  Quiet  0  Manual  1  Significant  2  Move    mqttProtocolLevel  MQTT broker protocol level  (iOS,Android/integer)  3  MQTT 3 (default)  4  MQTT 3.1.1    notificationGeocoder  Resolve last reported location in ongoing notification to an address   (Android/boolean)  notificationLocation  Show last reported location in ongoing notification  (Android/boolean)  opencageApiKey  API key for alternate Geocoding provider. See https://opencagedata.com/ for details.  (Android/string)  passphrase  Passphrase of the client pkcs12 file  (iOS/string)  password  Endpoint password  (iOS,Android/string)  ping  Interval in which location messages of with  t : p  are reported  (Android/integer)  policymode  User defined securiy policy mode  (iOS/integer)  0  Do not used pinned certificates to validate servers  1  Validate host certificates against public keys of pinned certificates  2  Validate host certificates against pinned certificates    port  MQTT endpoint port  (iOS,Android/integer)  positions  Number of locations to keep and display  (iOS/integer)  pubTopicBase  MQTT topic base to which the app publishes;  %u  is replaced by the user name,  %d  by device    (iOS,Android/string)  pubRetain  MQTT retain flag for reported messages  (iOS,Android/boolean)  pubQos  MQTT QoS level for reported messages  (iOS,Android/integer)  ranging  Beacon ranging  (iOS/boolean)  remoteConfiguration  Allow remote configuration by sending a  setConfiguration  cmd message  (Android/boolean)  servercer  Blank separated list of certificate file names in DER format  (iOS/string)  sub  subscribe to  subTopic  via MQTT  (iOS,Android/boolean)  subTopic  A whitespace separated list of MQTT topics to which the app subscribes if  sub  is true (defaults see  topics )    (iOS,Android/string)  subQos   (iOS,Android/boolean)  tid  Two digit Tracker ID used to display short name and default face of a user  (iOS,Android/string)  tls  MQTT endpoint TLS connection  (iOS,Android/boolean)  tlsClientCrtPassword  Passphrase of the client pkcs12 file  (Android/string)  url  HTTP endpoint URL to which messages are POSTed  (iOS,Android/string)  usepolicy  Use user defined security policy  (iOS/boolean)  username  Endpoint username  (iOS,Android/string)  validatedomainname  Validate domain name during TLS handshake  (iOS/boolean)  validatecertificatechain  Validate the whole certificate chain or just the server certificate  (iOS/boolean)  willRetain  willTopic  willQos  waypoints  Array of waypoint messages  (iOS,Android/array)   Notes   When importing a configuration message, all contained values are imported for the currently active mode. If the message also contains a  mode  element, the mode is changed first and all remaining elements are imported for the new mode.  In MQTT mode the server will consider the client as dead if it the keepalive interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if  keepalive  was 60). Afterwards, an  lwt  message will be send.", 
            "title": "_type=configuration"
        }, 
        {
            "location": "/tech/json/#_typebeacon", 
            "text": "These messages are published when beacon ranging (iOS only) is enabled. Be advised that beacon ranging publishes a lot of messages and has a strong impact on battery life.  {\n     _type : beacon ,\n    elements\n}   desc  name of the seen beacon  (iOS/String)  uuid  UUID of the seen beacon  (iOS/String)  major  Major number of the seen beacon  (iOS/integer/epoch)  minor  Minor number of the seen beacon  (iOS/integer/epoch)  tst  Timestamp at which the beacon was seen  (iOS/integer/epoch)  acc  Accuracy of the proximity value  (iOS/integer/meters)  rssi  Received signal strength of the beacon  (iOS/integer/decibel)  prox Relative distance to the beacon  (iOS/integer)  0  Proximity of the beacon could not be determined  1  Beacon is in the immediate vicinity  2  Beacon is relatively close to the user  3  Beacon is far away     Notes   The theoretical relationship between RSSI and distance is  RSSI[dbm] = \u2212(10n log10(d) \u2212 A)  where d is the distance and A is the offset which is the measured RSSI one meter point away from the beacon.", 
            "title": "_type=beacon"
        }, 
        {
            "location": "/tech/json/#_typecmd", 
            "text": "{ _type : cmd , action : reportLocation }\n{ _type : cmd , action : reportSteps }\n{ _type : cmd , action : dump }\n{ _type : cmd , action : waypoints }\n{ _type : cmd , action : setConfiguration , configuration :{ _type : configuration ,...}\n{ _type : cmd , action : setWaypoints , waypoints :{ _type : waypoints , waypoints :[...]}\n{ _type : cmd , action : action , content : Backend maintenance scheduled for tonight\\n\\nhttp://support.owntracks.org }\n{ _type : cmd , action : action , content : a href='http://support.owntracks.org' Backend Maintenance tonight /a }\n{ _type : cmd , action : action , url : http://support.owntracks.org }\n{ _type : cmd , action : action , notification : Warning! Battery low }   action  action to be performed by the device  (iOS,Android/string)  action  Inserts an additional  Featured Content  tab in the UI  (iOS)  dump  Triggers the publish of a  configuration  message  (iOS)  reportSteps  Triggers the report of a  steps  messages_(iOS)_  from  Timestamp  (iOS/epoch/optional)  to  Timestamp  (iOS/epoch/optional)    reportLocation  Triggers the publish of a  location  messages  (iOS,Android)  setWaypoints  Imports (merge) and activates new waypoints  (iOS,Android)  waypoints  Array of  waypoint  messages to import  (iOS,Android/array/required)    setConfiguration  Imports and activates new configuration values  (iOS,Android)  configuration  Configuration message to import  (iOS,Android/required)    waypoints  Triggers publish of a  waypoints  message  (iOS,Android)   Notes   If  url  for the  action  cmd message is specified, the URL is opened in a full screen web view within the app  If the optional  extern  boolean is  true  a click on the notification will launch an external browser instead  If  url  is not specified the text of the  content  element is displayed. Links embedded in the text are operational.  If the  content  consists of HTML, it is rendered  The  Featured Content  tab can be removed with an  action  cmd message without  content  and without  url  element   If the  action  cmd contains a  notification  element, the value of the element is shown in the app    On iOS, the array of waypoints to the  setWaypoints  command allows updates / removal; the key of the waypoint is its name ( desc ). If you specify an invalid  lat  or  lon  (invalid means out of range number value e.g.  -1000000 , a string like  \"foo\"  will result in a  0  in app) the waypoint is deleted.", 
            "title": "_type=cmd"
        }, 
        {
            "location": "/tech/json/#_typesteps", 
            "text": "{\n     _type : steps ,\n    elements\n}   tst  Timestamp of the request  (iOS/integer/epoch)  steps  Steps walked with the device in the specfied time period   (iOS/integer/steps)  from  Effective start of time period  (iOS/integer/epoch)  to   Effective end of time period  (iOS/integer/epoch)   Notes   steps  is -1 if device does not support step counting or specified time period is invalid", 
            "title": "_type=steps"
        }, 
        {
            "location": "/tech/json/#_typecard", 
            "text": "Apps read  Card  to display a name and icon for a user.  {\n     _type :  card ,\n    elements\n}   name  Name to identify a user  (iOS,Android/string/optional)  face  Base64 encoded PNG image that is displayed instead of the Tracker ID  (iOS,Android/string/optional)  tid  The tracker ID with which a friend is associated in the apps", 
            "title": "_type=card"
        }, 
        {
            "location": "/tech/json/#_typewaypoints", 
            "text": "The app can export a list of configured waypoints to the endpoint.  {\n     _type :  waypoints ,\n    elements\n}   _creator  Identification of what created the array. Ignored by the apps  (iOS,Android/string/optional)  waypoints  Array of  waypoint  messages  (iOS,Android/array/required)", 
            "title": "_type=waypoints"
        }, 
        {
            "location": "/tech/json/#_typeencrypted", 
            "text": "Apps can optionally  encrypt  outgoing messages with a shared symmetric key.\nThe encrypted message is contained in the  data element.\nFor security reasons, the encryption key is not exported with configuration messages and cannot be imported.  {\n     _type :  encrypted ,\n    elements\n}   data  Encrypted and Base64 encoded original JSON message  (iOS,Android/string/required)", 
            "title": "_type=encrypted"
        }, 
        {
            "location": "/tech/http/", 
            "text": "HTTP\n\n\nAn optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all \nJSON\n payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads.\n\n\nThe URL you enter in the setting for HTTP mode has the following syntax:\n\n\nhttp[s]://[user[:password]@]host[:port]/path\n\n\n\n\nAuthentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS (\nhttps://\n scheme). The \nencryption\n feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself.\n\n\nThe Recorder supports \nHTTP mode\n out of the box at the \n/pub\n end point, as long as it is built with HTTP support and a \n--http-port\n is configured. When using Recorder in this mode, set the URL to:\n\n\nhttp[s]://recorder_host[:port]/pub\n\n\n\n\nThe username and password for HTTP Basic authentication can be configured in application settings, under \nIdentification\n. Device name and tracker name can also be configured there. Username and device name are \nrequired\n when using the Recorder. Parameters for \nusername\n and \ndevicename\n can also be included in the URL (\n?u=user\nd=device\n), or alternatively using the \nX-Limit-U\n and \nX-Limit-D\n headers respectively. You can also force \nusername\n using a proxy as described in the Recorder's documentation.\n\n\nAll publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same \nJSON\n payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.)\n\n\nIf the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code (\n2xx\n) is returned  the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time.\n\n\nIf the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array \n[]\n. It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid \n_type\n as described in \nJSON\n. Support for the following \n_type\n is implemented:\n\n\n\n\n\n\n\n\n_type\n\n\niOS\n\n\nAndroid\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nlocation\n\n\nY\n\n\nY\n\n\nCan return friend location objects.\n\n\n\n\n\n\ncmd\n\n\nY\n\n\nY\n\n\nwith \naction\n set to \ndump\n, \nreportLocation\n, \nreportSteps\n, \naction\n, and \nsetWaypoints\n\n\n\n\n\n\ncard\n\n\nY\n\n\nY\n\n\nCan return \ncard\n objects for self and friends\n\n\n\n\n\n\ntransition\n\n\nY\n\n\nY\n\n\nObtain friends' transition events.\n\n\n\n\n\n\n\n\nDistinguishing payloads\n\n\nWhen a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from:\n\n\n\n\nOn iOS, a new \ntopic\n key is added to the payload if the payload is unencrypted. If the payload is encrypted, the \ntopic\n key is only available in the decrypted payload.\n\n\nBoth the Android and iOS apps (iOS after \n#560\n is implemented) include headers to identify the user (\nX-Limit-U\n) and the device (\nX-Limit-D\n) if the user has entered this information in the \"Identification\" section of the connection settings.\n\n\n\n\nContent-Type: application/json\nX-Limit-U: jjolie\nX-Limit-D: myphone\n\n\n\n\nPHP example\n\n\nUsing a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table:\n\n\nmysql\n select * from locations;\n+---------------------+------+-----------+----------+\n| dt                  | tid  | lat       | lon      |\n+---------------------+------+-----------+----------+\n| 2016-02-20 09:16:05 | JJ   | 48.858330 | 2.295130 |\n| 2016-02-20 09:19:49 | JJ   | 48.860430 | 2.294010 |\n+---------------------+------+-----------+----------+\n\n\n\n\nFor the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a \ntst\n timestamp when the event actually occurred.\n\n\n?php\n    # Obtain the JSON payload from an OwnTracks app POSTed via HTTP\n    # and insert into database table.\n\n    header(\nContent-type: application/json\n);\n\n    $payload = file_get_contents(\nphp://input\n);\n    $data =  @json_decode($payload, true);\n\n    if ($data['_type'] == 'location') {\n\n        # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6));\n        $mysqli = new mysqli(\n127.0.0.1\n, \nuser\n, \npassword\n, \ndatabase\n);\n\n        $tst = $data['tst'];\n        $lat = $data['lat'];\n        $lon = $data['lon'];\n        $tid = $data['tid'];\n\n        # Convert timestamp to a format suitable for mysql\n        $dt = date('Y-m-d H:i:s', $tst);\n\n        $sql = \nINSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?)\n;\n        $stmt = $mysqli-\nprepare($sql);\n        # bind parameters (s = string, i = integer, d = double,  b = blob)\n        $stmt-\nbind_param('ssdd', $dt, $tid, $lat, $lon);\n        $stmt-\nexecute();\n        $stmt-\nclose();\n    }\n\n    $response = array();\n    # optionally add objects to return to the app (e.g.\n    # friends or cards)\n    print json_encode($response);\n?\n\n\n\n\n\nAssuming the Web server hosting this example is called \nexample.com\n, and assuming the above script is in Jane's home directory's \npublic_html\n saved as \nloc.php\n, the URL you configure in the OwnTracks app would be \nhttp://example.com/~jane/loc.php\n. We \nurge\n you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of \nhttps://user:password@example.com/~jane/loc.php\n.\n\n\nThere's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you \nstudy the API documentation\n.\n\n\nTesting your HTTP endpoint\n\n\nAn simple example for testing a HTTP endpoint you set up:\n\n\n#!/bin/sh\n\nuser=jane\ndevice=phone\n\npayload=$(jo _type=location \\\n   t=u \\\n   batt=11 \\\n   lat=48.856826 \\\n   lon=2.292713 \\\n   tid=JJ \\\n   tst=$(date +%s) \\\n   topic=\nowntracks/$user/$device\n)\n\ncurl --data \n${payload}\n http://127.0.0.1:8085/pub?u=${user}\nd=${device}\n\n\n\n\n\n\nsee also: \nTraccar", 
            "title": "HTTP"
        }, 
        {
            "location": "/tech/http/#http", 
            "text": "An optional HTTP mode is implemented with which the OwnTracks apps use a privately configured HTTP endpoint (a.k.a. a Web server) to which they POST requests over HTTP instead of publishing to MQTT. In this mode all  JSON  payloads reported by the apps are transmitted via HTTP to the endpoint. In particular and most importantly, the apps publish their location data. Note that the length of the payload may be zero if a friend is deleted from the app: the zero-length message which is normally published via MQTT will be POSTed via HTTP to your endpoint; as such it is best to ignore zero-length payloads.  The URL you enter in the setting for HTTP mode has the following syntax:  http[s]://[user[:password]@]host[:port]/path  Authentication to the endpoint is performed with HTTP Basic authentication and, as such, we very strongly recommend the use of TLS ( https://  scheme). The  encryption  feature is supported, and you can use it with HTTP endpoints; the Owntracks Recorder supports decryption, but if you implement your own endpoint you have to perform decryption at the endpoint yourself.  The Recorder supports  HTTP mode  out of the box at the  /pub  end point, as long as it is built with HTTP support and a  --http-port  is configured. When using Recorder in this mode, set the URL to:  http[s]://recorder_host[:port]/pub  The username and password for HTTP Basic authentication can be configured in application settings, under  Identification . Device name and tracker name can also be configured there. Username and device name are  required  when using the Recorder. Parameters for  username  and  devicename  can also be included in the URL ( ?u=user d=device ), or alternatively using the  X-Limit-U  and  X-Limit-D  headers respectively. You can also force  username  using a proxy as described in the Recorder's documentation.  All publishes which are currently done with MQTT will then be POSTed to the endpoint with exactly the same  JSON  payload formats. Support for Friends is available if your HTTP endpoint can produce appropriate data which is consumed by the app whenever it POSTs a location. This differs greatly from MQTT mode wherein the app subscribes to topics and is informed of data on those topics whenever it's available; in HTTP mode the apps do not periodically poll your HTTP endpoint; rather it is contacted only when the app is ready to publish its location or when you manually trigger a publish. (Support for friends and optionally their cards is implemented in the Recorder.)  If the HTTP endpoint is reachable (no exception, no timeout, DNS name exists, etc.) and a successfull return code ( 2xx ) is returned  the payload is considered POSTed. In the event that the endpoint is unreachable, the payload will be queued and posted at a later time.  If the HTTP endpoint returns a status code 200 it will typically return an empty JSON payload array  [] . It may, however, return an array of JSON objects to the OwnTracks device, each of which must be a valid  _type  as described in  JSON . Support for the following  _type  is implemented:     _type  iOS  Android  Usage      location  Y  Y  Can return friend location objects.    cmd  Y  Y  with  action  set to  dump ,  reportLocation ,  reportSteps ,  action , and  setWaypoints    card  Y  Y  Can return  card  objects for self and friends    transition  Y  Y  Obtain friends' transition events.     Distinguishing payloads  When a message is received over MQTT, the payload is sent to a topic, and this topic can be used to map the message to the user and their device. In the case that a message is received over HTTP, we don't have the context of a topic; instead, the iOS and Android apps use a different approach to help you figure out where the message came from:   On iOS, a new  topic  key is added to the payload if the payload is unencrypted. If the payload is encrypted, the  topic  key is only available in the decrypted payload.  Both the Android and iOS apps (iOS after  #560  is implemented) include headers to identify the user ( X-Limit-U ) and the device ( X-Limit-D ) if the user has entered this information in the \"Identification\" section of the connection settings.   Content-Type: application/json\nX-Limit-U: jjolie\nX-Limit-D: myphone  PHP example  Using a simple PHP script which you host, say, on an Apache or nginx server, you can quite easily record locations POSTed from the OwnTracks apps. The following very simple example will fill a database table:  mysql  select * from locations;\n+---------------------+------+-----------+----------+\n| dt                  | tid  | lat       | lon      |\n+---------------------+------+-----------+----------+\n| 2016-02-20 09:16:05 | JJ   | 48.858330 | 2.295130 |\n| 2016-02-20 09:19:49 | JJ   | 48.860430 | 2.294010 |\n+---------------------+------+-----------+----------+  For the sake of clarity this example uses a database table with a MySQL timestamp column which is automatically set upon INSERT; keep in mind that the real location event posted by the OwnTracks apps has a  tst  timestamp when the event actually occurred.  ?php\n    # Obtain the JSON payload from an OwnTracks app POSTed via HTTP\n    # and insert into database table.\n\n    header( Content-type: application/json );\n\n    $payload = file_get_contents( php://input );\n    $data =  @json_decode($payload, true);\n\n    if ($data['_type'] == 'location') {\n\n        # CREATE TABLE locations (dt TIMESTAMP, tid CHAR(2), lat DECIMAL(9,6), lon DECIMAL(9,6));\n        $mysqli = new mysqli( 127.0.0.1 ,  user ,  password ,  database );\n\n        $tst = $data['tst'];\n        $lat = $data['lat'];\n        $lon = $data['lon'];\n        $tid = $data['tid'];\n\n        # Convert timestamp to a format suitable for mysql\n        $dt = date('Y-m-d H:i:s', $tst);\n\n        $sql =  INSERT INTO locations (dt, tid, lat, lon) VALUES (?, ?, ?, ?) ;\n        $stmt = $mysqli- prepare($sql);\n        # bind parameters (s = string, i = integer, d = double,  b = blob)\n        $stmt- bind_param('ssdd', $dt, $tid, $lat, $lon);\n        $stmt- execute();\n        $stmt- close();\n    }\n\n    $response = array();\n    # optionally add objects to return to the app (e.g.\n    # friends or cards)\n    print json_encode($response);\n?   Assuming the Web server hosting this example is called  example.com , and assuming the above script is in Jane's home directory's  public_html  saved as  loc.php , the URL you configure in the OwnTracks app would be  http://example.com/~jane/loc.php . We  urge  you to consider transmitting your data to your Web server securely using TLS and authentication, in which case the URL you use will be along the lines of  https://user:password@example.com/~jane/loc.php .  There's lots of other data in the JSON payload from the OwnTracks apps you may be interested in; we reccomend you  study the API documentation .  Testing your HTTP endpoint  An simple example for testing a HTTP endpoint you set up:  #!/bin/sh\n\nuser=jane\ndevice=phone\n\npayload=$(jo _type=location \\\n   t=u \\\n   batt=11 \\\n   lat=48.856826 \\\n   lon=2.292713 \\\n   tid=JJ \\\n   tst=$(date +%s) \\\n   topic= owntracks/$user/$device )\n\ncurl --data  ${payload}  http://127.0.0.1:8085/pub?u=${user} d=${device}   see also:  Traccar", 
            "title": "HTTP"
        }, 
        {
            "location": "/tech/mqtt/", 
            "text": "MQTT\n\n\nKeepalives\n\n\nMQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the \nkeepalive\n interval which is set by the client.\n\n\nThe server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec.\n\n\nFrom the spec:\n\n\n\n\nThe actual value of the Keep Alive is application specific; typically this is\na few minutes. The maximum value is 18 hours 12 minutes and 15 seconds.\n\n\n\n\nFor example, \nmosquitto_sub\n uses a default of 60 sec.\n\n\nIn addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand.\n\n\nBroker\n\n\nBelow is a list of known configuration values that are required to connect to certain MQTT endpoints \n\n\nAWS IOT\n\n\nThe OwnTracks apps are partially compatible to the \nAWS IOT\n broker in MQTT private mode. \nAs AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. \n\n\nBefore connecting, a so called \nthing\n has to be configured which represents the connecting client. \nThe thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. \nThe most basic policy allows all actions for the \nthing\n. \n\n\n{\n  \nVersion\n: \n2012-10-17\n,\n  \nStatement\n: [\n    {\n      \nEffect\n: \nAllow\n,\n      \nAction\n: \niot:*\n,\n      \nResource\n: \n*\n\n    }\n  ]\n}\n\n\n\n\nThe following settings are required to connect \n\n\n{\n    \n_type\n:\nconfiguration\n, \n    \nmode\n:0, \n    \nhost\n: \nENDPOINT.amazonaws.com\n,\n    \nport\n: 8883,\n    \nsubQos\n:0,\n    \npubQos\n:0, \n    \nauth\n:false,\n    \npubRetain\n:false, \n    \ncleanSession\n:true, \n    \ntls\n:true\n    \nclientId\n:\nCLIENTID\n,\n}\n\n\n\n\nThe \nENDPOINT\n can be obtained in the \nthing\n details under \nInteract\n.\n\nAdditionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca.\nBefore importing it into the app, you need to set a password to the client TLS certificate. \n\n\nLosant IoT Developer Platform\n\n\nThe OwnTracks apps are partially compatible to the \nLosant IoT Developer Platform\n in MQTT private mode. \nAs Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected. \n\n\nThe following settings are required to connect \n\n\n{\n    \n_type\n: \nconfiguration\n,\n    \nmode\n:0,\n    \nmqttProtocolLevel\n: 4,\n    \nhost\n:\nbroker.losant.com\n,\n    \nport\n:8883,\n    \ntls\n:true,\n    \npubRetain\n: false,\n    \npubQos\n: 0,\n    \nsubQos\n:0,\n    \ncleanSession\n: true,\n    \nclientId\n:\nCLIENT_ID\n,\n    \nauth\n:true,\n    \nusername\n:\nACCESS_KEY\n,\n    \npassword\n:\nACCESS_SECRET\n\n}\n\n\n\n\nSee the \nofficial documentation\n how to obtain the \nACCESS_KEY\n and \nACCESS_SECRET\n.", 
            "title": "MQTT"
        }, 
        {
            "location": "/tech/mqtt/#mqtt", 
            "text": "Keepalives  MQTT was designed with mobile clients in mind so it doesn't require a persistent TCP connection. The broker detects a dead client if it hasn't heard from a client within the  keepalive  interval which is set by the client.  The server should send the LWT if it the interval plus 50% passed without receiving any MQTT packet from the client (e.g. after 90 sec if keepalive was 60 sec.  From the spec:   The actual value of the Keep Alive is application specific; typically this is\na few minutes. The maximum value is 18 hours 12 minutes and 15 seconds.   For example,  mosquitto_sub  uses a default of 60 sec.  In addition, note that the mosquitto broker sends an LWT message if the TCP connection is closed/aborts without sending an MQTT-Disconnect beforehand.", 
            "title": "MQTT"
        }, 
        {
            "location": "/tech/mqtt/#broker", 
            "text": "Below is a list of known configuration values that are required to connect to certain MQTT endpoints   AWS IOT  The OwnTracks apps are partially compatible to the  AWS IOT  broker in MQTT private mode. \nAs AWS IOT does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected.   Before connecting, a so called  thing  has to be configured which represents the connecting client. \nThe thing needs to have a client certificate generated for authentication and a policy attached that allows some actions. \nThe most basic policy allows all actions for the  thing .   {\n   Version :  2012-10-17 ,\n   Statement : [\n    {\n       Effect :  Allow ,\n       Action :  iot:* ,\n       Resource :  * \n    }\n  ]\n}  The following settings are required to connect   {\n     _type : configuration , \n     mode :0, \n     host :  ENDPOINT.amazonaws.com ,\n     port : 8883,\n     subQos :0,\n     pubQos :0, \n     auth :false,\n     pubRetain :false, \n     cleanSession :true, \n     tls :true\n     clientId : CLIENTID ,\n}  The  ENDPOINT  can be obtained in the  thing  details under  Interact . \nAdditionaly, you need to configure the app to use a client TLS certificate for authentication and the AWS TLS ca.\nBefore importing it into the app, you need to set a password to the client TLS certificate.   Losant IoT Developer Platform  The OwnTracks apps are partially compatible to the  Losant IoT Developer Platform  in MQTT private mode. \nAs Losant does not support some MQTT features (notable retained messages), some OwnTracks features might not work as expected.   The following settings are required to connect   {\n     _type :  configuration ,\n     mode :0,\n     mqttProtocolLevel : 4,\n     host : broker.losant.com ,\n     port :8883,\n     tls :true,\n     pubRetain : false,\n     pubQos : 0,\n     subQos :0,\n     cleanSession : true,\n     clientId : CLIENT_ID ,\n     auth :true,\n     username : ACCESS_KEY ,\n     password : ACCESS_SECRET \n}  See the  official documentation  how to obtain the  ACCESS_KEY  and  ACCESS_SECRET .", 
            "title": "Broker"
        }, 
        {
            "location": "/tech/qr/", 
            "text": "QR codes\n\n\nTo configure iBeacons in the OwnTracks for iOS app, you can use QR codes with specially-constructed URLs to configure the app. The QR codes can be scanned from the settings tab within the app, or the specially crafted URL can be opened from mobile Safari.\n\n\n\n\nAlternatively, you can use an external QR reader app (such as \nQrafter\n) or, even easier, you provide the URL and view it through the device's mobile Web browser.\n\n\n\n\nQR codes can be prepared with a number of tools: there are online offerings, and there is a standalone C program by the name of \nqrencode\n which works very well:\n\n\nqrencode -l H -v 10 -d 300 -o mybeacon.png 'owntracks:///beacon?name=MyBeacon\nuuid=12345678-1234-1234-1234-123456789A\nmajor=2\nminor=1'\n\n\n\n\niBeacon QR URL\n\n\n\n\nscheme = \nowntracks\n\n\nhost = \nempty\n\n\npath = \n/beacon\n\n\nquery = \nname=\nname\nuuid=\nuuid\nmajor=\nmajor\nminor=\nminor\n\n\n\n\nmajor and minor are optional\n\n\nExample:\n\n\nowntracks:///beacon?name=MyBeacon\nuuid=12345678-1234-1234-1234-123456789A\nmajor=2\nminor=1", 
            "title": "QR"
        }, 
        {
            "location": "/tech/qr/#qr-codes", 
            "text": "To configure iBeacons in the OwnTracks for iOS app, you can use QR codes with specially-constructed URLs to configure the app. The QR codes can be scanned from the settings tab within the app, or the specially crafted URL can be opened from mobile Safari.   Alternatively, you can use an external QR reader app (such as  Qrafter ) or, even easier, you provide the URL and view it through the device's mobile Web browser.   QR codes can be prepared with a number of tools: there are online offerings, and there is a standalone C program by the name of  qrencode  which works very well:  qrencode -l H -v 10 -d 300 -o mybeacon.png 'owntracks:///beacon?name=MyBeacon uuid=12345678-1234-1234-1234-123456789A major=2 minor=1'  iBeacon QR URL   scheme =  owntracks  host =  empty  path =  /beacon  query =  name= name uuid= uuid major= major minor= minor   major and minor are optional  Example:  owntracks:///beacon?name=MyBeacon uuid=12345678-1234-1234-1234-123456789A major=2 minor=1", 
            "title": "QR codes"
        }, 
        {
            "location": "/tech/program/", 
            "text": "Programming\n\n\nWe've \nshown you some clients which consume OwnTracks data\n, but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of \nPython\n together with the \nPaho Python client\n.\n\n\nGetting started: Paho Python\n\n\nWe're assuming you have Python installed, which you can verify by attempting to invoke \npython -V\n; if installed, it tells you the version number. We're also assuming you have \npip\n installed (a Python package manager) which may be called \npip2\n or something on your machine. You may have to install \nsetuptools\n via your distribution's package manager.\n\n\nInstall the \nPaho Python\n module using\n\n\npip install paho-mqtt\n\n\n\n\nProgress reports\n\n\nAssume we want to create a program which should report the location of our friends, as a simple list:\n\n\nTID = n4 is currently at 51.0343863, 9.4763712\nTID = n7 is currently at 52.7343671, 7.8764431\nTID = jp is currently at 53.134404655, 8.1063173\n\n\n\n\nWe need a small utility program which will subscribe to location publishes received by your broker by connecting to it on \nlocalhost\n and subscribing to \nowntracks/+/+\n (a wild-card expression in which each \n+\n means \nanything at this level\n).\n\n\nThe Code\n\n\nFor each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID (\nTID\n) as well as latitude, longitude coordinates. Keep a copy of our \nOwnTracks-JSON\n documentation handy and study the topic names of each possible publish by the apps.\n\n\n#!/usr/bin/env python\n\nimport paho.mqtt.client as mqtt\nimport json\n\n# The callback for when the client successfully connects to the broker\ndef on_connect(client, userdata, rc):\n    ''' We subscribe on_connect() so that if we lose the connection\n        and reconnect, subscriptions will be renewed. '''\n\n    client.subscribe(\nowntracks/+/+\n)\n\n# The callback for when a PUBLISH message is received from the broker\ndef on_message(client, userdata, msg):\n\n    topic = msg.topic\n\n    try:\n        data = json.loads(str(msg.payload))\n\n        print \nTID = {0} is currently at {1}, {2}\n.format(data['tid'], data['lat'], data['lon'])\n    except:\n        print \nCannot decode data on topic {0}\n.format(topic)\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect(\nlocalhost\n, 1883, 60)\n\n# Blocking call which processes all network traffic and dispatches\n# callbacks (see on_*() above). It also handles reconnecting.\n\nclient.loop_forever()\n\n\n\n\nMicro Map\n\n\nAssume for a moment that you alter the program above in such a way as that it writes your current location in JSON format to a file called \nme.json\n which could look like this:\n\n\n{\n    \nlat\n: 48.858334,\n    \nlon\n : 2.295134,\n    \ntid\n:\nJJ\n\n}\n\n\n\n\nWe could then create a Web page which would load that JSON and display a marker on a map.\n\n\n\n\nindex.html\n\n\n!DOCTYPE html\n\n\nhtml\n\n  \nhead\n\n    \ntitle\nMicromap\n/title\n\n    \nmeta name=\nviewport\n content=\nwidth=device-width, height=device-height, user-scalable=no, initial-scale=1.0\n /\n\n\n    \nmeta name=\nmobile-web-app-capable\n content=\nyes\n\n    \nmeta name=\napple-mobile-web-app-capable\n content=\nyes\n\n    \nstyle type=\ntext/css\n\n      body {  font-size: 80%; }\n\n      td { border-bottom: 1px solid; border-right: 1px dotted;}\n\n      #map-canvas { height: 100% }\n\n    \n/style\n\n     \nscript src=\nhttps://maps.googleapis.com/maps/api/js?v=3.exp\nsensor=false\n/script\n\n     \nscript src=\nhttp://code.jquery.com/jquery-1.9.1.min.js\n/script\n\n     \nscript src=\nhttp://code.jquery.com/jquery-migrate-1.1.1.min.js\n/script\n\n    \nscript src=\nfunctions.js\n/script\n\n  \n/head\n\n  \nbody\n\n    \ndiv\n\n      \ndiv id=\nmap-canvas\n style='width: 100%; height: 400px;'/\n/div\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nfunctions.js\n\n\nfunction initialize() {\n    var json = (function () {\n        var json = null; \n        $.ajax({ \n            'type' : 'GET',\n            'async': false, \n            'cache' : false,\n            'global': true, \n            'url'   : 'me.json',  // URI of JSON file we create\n            'dataType': \njson\n, \n            'success': function (data) {\n                json = data;\n                return json;\n             }\n        });\n    return json;\n    })();\n\n    var data = json;\n    console.log(JSON.stringify(data));\n\n    var center = new google.maps.LatLng(data.lat, data.lon);\n    mapOptions = {\n        center: center,\n        zoom: 12,\n        mapTypeId: google.maps.MapTypeId.ROADMAP,\n        scrollwheel: false,\n        disableDefaultUI: false,\n        panControl: false,\n        scaleControl: false,\n        streetViewControl: false,\n        overviewMapControl: false,\n    };\n\n    map = new google.maps.Map(document.getElementById(\nmap-canvas\n), mapOptions);\n\n    var LatLng = new google.maps.LatLng(data.lat, data.lon); \n    var m = new google.maps.Marker({\n        position: LatLng,\n        map: map,\n        title: data.tid,\n    });\n}\ngoogle.maps.event.addDomListener(window, 'load', initialize);\n\n\n\n\nwould result in a map being displayed in your Web browser with a marker at the last location received by your MQTT broker. Note: the marker won't move; we leave that as an exercise to you, or just head over and look \nat some clients\n which do that for you.\n\n\nTesting\n\n\nTesting location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply:\n\n\n\n\nUse the \npublish now\n button in OwnTracks to fire a location update. The smart phone won't really \nmove\n much of course, but it'll allow you to test your program a bit.\n\n\nPublish your own \nOwnTracks-JSON\n payload to the broker with \nmosquitto_pub\n or similar.\n\n\n\n\nLast words\n\n\nConsuming OwnTracks messages from your MQTT broker isn't particularly difficult, and people have built nice programs doing so.", 
            "title": "Code"
        }, 
        {
            "location": "/tech/program/#programming", 
            "text": "We've  shown you some clients which consume OwnTracks data , but you may well wish to dip your fingers into programming something of your own. Creating a program to consume OwnTracks data isn't particularly difficult, and we're going to show you what you can do with a bit of  Python  together with the  Paho Python client .", 
            "title": "Programming"
        }, 
        {
            "location": "/tech/program/#getting-started-paho-python", 
            "text": "We're assuming you have Python installed, which you can verify by attempting to invoke  python -V ; if installed, it tells you the version number. We're also assuming you have  pip  installed (a Python package manager) which may be called  pip2  or something on your machine. You may have to install  setuptools  via your distribution's package manager.  Install the  Paho Python  module using  pip install paho-mqtt", 
            "title": "Getting started: Paho Python"
        }, 
        {
            "location": "/tech/program/#progress-reports", 
            "text": "Assume we want to create a program which should report the location of our friends, as a simple list:  TID = n4 is currently at 51.0343863, 9.4763712\nTID = n7 is currently at 52.7343671, 7.8764431\nTID = jp is currently at 53.134404655, 8.1063173  We need a small utility program which will subscribe to location publishes received by your broker by connecting to it on  localhost  and subscribing to  owntracks/+/+  (a wild-card expression in which each  +  means  anything at this level ).  The Code  For each received message, the utility attempts to decode the JSON payload and then prints the tracker-ID ( TID ) as well as latitude, longitude coordinates. Keep a copy of our  OwnTracks-JSON  documentation handy and study the topic names of each possible publish by the apps.  #!/usr/bin/env python\n\nimport paho.mqtt.client as mqtt\nimport json\n\n# The callback for when the client successfully connects to the broker\ndef on_connect(client, userdata, rc):\n    ''' We subscribe on_connect() so that if we lose the connection\n        and reconnect, subscriptions will be renewed. '''\n\n    client.subscribe( owntracks/+/+ )\n\n# The callback for when a PUBLISH message is received from the broker\ndef on_message(client, userdata, msg):\n\n    topic = msg.topic\n\n    try:\n        data = json.loads(str(msg.payload))\n\n        print  TID = {0} is currently at {1}, {2} .format(data['tid'], data['lat'], data['lon'])\n    except:\n        print  Cannot decode data on topic {0} .format(topic)\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect( localhost , 1883, 60)\n\n# Blocking call which processes all network traffic and dispatches\n# callbacks (see on_*() above). It also handles reconnecting.\n\nclient.loop_forever()", 
            "title": "Progress reports"
        }, 
        {
            "location": "/tech/program/#micro-map", 
            "text": "Assume for a moment that you alter the program above in such a way as that it writes your current location in JSON format to a file called  me.json  which could look like this:  {\n     lat : 48.858334,\n     lon  : 2.295134,\n     tid : JJ \n}  We could then create a Web page which would load that JSON and display a marker on a map.   index.html  !DOCTYPE html  html \n   head \n     title Micromap /title \n     meta name= viewport  content= width=device-width, height=device-height, user-scalable=no, initial-scale=1.0  / \n\n     meta name= mobile-web-app-capable  content= yes \n     meta name= apple-mobile-web-app-capable  content= yes \n     style type= text/css \n      body {  font-size: 80%; }\n\n      td { border-bottom: 1px solid; border-right: 1px dotted;}\n\n      #map-canvas { height: 100% }\n\n     /style \n      script src= https://maps.googleapis.com/maps/api/js?v=3.exp sensor=false /script \n      script src= http://code.jquery.com/jquery-1.9.1.min.js /script \n      script src= http://code.jquery.com/jquery-migrate-1.1.1.min.js /script \n     script src= functions.js /script \n   /head \n   body \n     div \n       div id= map-canvas  style='width: 100%; height: 400px;'/ /div \n     /div \n   /body  /html   functions.js  function initialize() {\n    var json = (function () {\n        var json = null; \n        $.ajax({ \n            'type' : 'GET',\n            'async': false, \n            'cache' : false,\n            'global': true, \n            'url'   : 'me.json',  // URI of JSON file we create\n            'dataType':  json , \n            'success': function (data) {\n                json = data;\n                return json;\n             }\n        });\n    return json;\n    })();\n\n    var data = json;\n    console.log(JSON.stringify(data));\n\n    var center = new google.maps.LatLng(data.lat, data.lon);\n    mapOptions = {\n        center: center,\n        zoom: 12,\n        mapTypeId: google.maps.MapTypeId.ROADMAP,\n        scrollwheel: false,\n        disableDefaultUI: false,\n        panControl: false,\n        scaleControl: false,\n        streetViewControl: false,\n        overviewMapControl: false,\n    };\n\n    map = new google.maps.Map(document.getElementById( map-canvas ), mapOptions);\n\n    var LatLng = new google.maps.LatLng(data.lat, data.lon); \n    var m = new google.maps.Marker({\n        position: LatLng,\n        map: map,\n        title: data.tid,\n    });\n}\ngoogle.maps.event.addDomListener(window, 'load', initialize);  would result in a map being displayed in your Web browser with a marker at the last location received by your MQTT broker. Note: the marker won't move; we leave that as an exercise to you, or just head over and look  at some clients  which do that for you.", 
            "title": "Micro Map"
        }, 
        {
            "location": "/tech/program/#testing", 
            "text": "Testing location-based apps is a bit of a, well, pain, but remember there are a few simple tricks you can apply:   Use the  publish now  button in OwnTracks to fire a location update. The smart phone won't really  move  much of course, but it'll allow you to test your program a bit.  Publish your own  OwnTracks-JSON  payload to the broker with  mosquitto_pub  or similar.", 
            "title": "Testing"
        }, 
        {
            "location": "/tech/program/#last-words", 
            "text": "Consuming OwnTracks messages from your MQTT broker isn't particularly difficult, and people have built nice programs doing so.", 
            "title": "Last words"
        }, 
        {
            "location": "/terminology/", 
            "text": "Terminology\n\n\nSome of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with.\n\n\nMQTT\n\n\nMQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers\n\n\nAnd what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of \nyour friends\n). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same \nMQTT broker\n.\n\n\nThere are \na number of clients\n which do that already, and we're even going to show you how you can \ncreate your own client\n for specific purposes.\n\n\nPub/Sub\n\n\nIn MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so.\n\n\nbroker\n\n\nA MQTT \nbroker\n is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message. \n\n\npublish\n\n\nThe act of sending a message to a broker. \n\n\ntopic\n\n\nEach message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to. \n\n\nsubscribe\n\n\nClients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic \nowntracks/jane/iphone\n will, for example, not receive a message that is published to \nowntracks/john/nexus\n.\n\n\nQoS\n\n\nQoS\n or \nQuality of Service\n, specifies how the app should attempt to publish messages to an MQTT broker.\n\n\n\n\nQoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged.\n\n\nQoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times.\n\n\nQoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer.\n\n\n\n\nRetain\n\n\nWhen a message is published to a \nbroker\n with the \ndurable\n or \nretain\n flat\nset, it means that the MQTT broker will attempt to store the last published\nmessage on a particular topic.\n\n\nA client which subscribes to that topic will receive that last retained message once it\nconnects to the broker.\n\n\nGeocoding\n\n\nReverse geocoding\n is the act of looking up the address for a pair of coordinates.\n\n\nGeofence\n\n\nA \ngeofence\n is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.", 
            "title": "Terminology"
        }, 
        {
            "location": "/terminology/#terminology", 
            "text": "Some of the terms we use can be a little confusing at times, so here's a list of terms you should be familiar with.  MQTT  MQTT is a machine-to-machine (M2M)/\"Internet of Things\" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. For example, it has been used in sensors communicating to a broker via satellite link, over occasional dial-up connections with healthcare providers, and in a range of home automation and small device scenarios. It is also ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers  And what does OwnTracks have to do with all of this? Well, the OwnTracks apps are MQTT clients which publish messages (your location) and subscribe to and consume messages (e.g. the locations of  your friends ). OwnTracks' location updates land in the cauldron when the app publishes a location message from which it can be consumed by any number of subscribers to the same  MQTT broker .  There are  a number of clients  which do that already, and we're even going to show you how you can  create your own client  for specific purposes.  Pub/Sub  In MQTT-speak, clients publish messages, which means they send or transmit them, and other clients subscribe to messages, meaning they receive them. Messages are published on topics, and the MQTT server, which is called a broker is configured to permit or deny clients doing so.  broker  A MQTT  broker  is a server that enables the communication between clients. The broker is responsible for distributing messages to interested clients based on the topic of a message.   publish  The act of sending a message to a broker.   topic  Each message that is published by a client is send to a specific topic on the broker. Clients can opt to receive only certain or all messages depending on which topic they subscribe to.   subscribe  Clients can specify to receive messages that are published to specific topics by subscribing to them. A client that is subscribed to the topic  owntracks/jane/iphone  will, for example, not receive a message that is published to  owntracks/john/nexus .  QoS  QoS  or  Quality of Service , specifies how the app should attempt to publish messages to an MQTT broker.   QoS=0. The message is delivered at most once, or it is not delivered at all. Its delivery across the network is not acknowledged.  QoS=1. The message is always delivered at least once. If the sender does not receive an acknowledgment, the message is sent again with the DUP flag set until an acknowledgment is received. As a result receiver can be sent the same message multiple times, and might process it multiple times.  QoS=2. The message is always delivered exactly once. This is the safest but slowest method of transfer.   Retain  When a message is published to a  broker  with the  durable  or  retain  flat\nset, it means that the MQTT broker will attempt to store the last published\nmessage on a particular topic.  A client which subscribes to that topic will receive that last retained message once it\nconnects to the broker.  Geocoding  Reverse geocoding  is the act of looking up the address for a pair of coordinates.  Geofence  A  geofence  is an area around a particular coordinate. Geofences will trigger certain actions once the device enters or leaves the setup area.", 
            "title": "Terminology"
        }, 
        {
            "location": "/clients/recorder/", 
            "text": "Recorder\n\n\nThe \nOwnTracks Recorder\n is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database.\n\n\nDocker\n\n\nWe have a \nDocker image\n which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. Furthermore, you pass environment variables into the container at first launch with which TLS certificates are created with subject (and subjAltNames) according to your preference. \n\n\nThis is documented \non the docker-recorder\n repository.\n\n\nSynology\n\n\nAfter installing Docker on your compatible Synology DiskStation, click on \nImage\n and \nAdd\n the Recorder image from the URL \nhttps://hub.docker.com/r/owntracks/recorder\n; you do not have to specify a username/password. Select \nlatest\n when prompted to choose a tag.\n\n\nIn list of images you should then see one called \nowntracks/recorder:latest\n as shown below.\n\n\n\n\nThen, click on \nLaunch\n in the same window, select a container name (or leave it as \nowntracks-recorder1\n) and click on \nAdvanced Settings\n.\n\n\n\n\nUnder \nVolume\n, add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the \n/store\n mount path.\n\n\nUnder \nPort Settings\n, ensure \nLocal Port\n \n8083\n is mapped to \nContainer Port\n \n8083\n; you will have to replace \nAuto\n by \n8083\n.\n\n\nUnder \nEnvironment\n, add two variables: \nOTR_HOST\n with the address or host name of your MQTT broker and \nOTR_PORT\n with its port number (typically \n1883\n). If you need authentication, check the \nRecorder documentation\n for further variables you can set to configure that.\n\n\n\n\nJust before running the container, you should see something like this with the settings you specified:\n\n\n\n\nWhen you launch the container, it will show up in the \nContainer\n tab:\n\n\n\n\nYou should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above.\n\n\n\n\nUpgrades to the container running on your Synology DiskStation are easily done from the command line:\n\n\n$ docker stop owntracks-recorder1\n$ docker pull owntracks/recorder:latest\n$ docker start owntracks-recorder1", 
            "title": "Docker"
        }, 
        {
            "location": "/clients/recorder/#recorder", 
            "text": "The  OwnTracks Recorder  is a lightweight program for storing and accessing location data published via MQTT by the OwnTracks apps. It is a compiled program which is easily to install and operate even on low-end hardware, and it doesn't require an external database.  Docker  We have a  Docker image  which you can use to launch the Recorder. The image expects a volume which you mount into it into which it will write persistent data. Furthermore, you pass environment variables into the container at first launch with which TLS certificates are created with subject (and subjAltNames) according to your preference.   This is documented  on the docker-recorder  repository.  Synology  After installing Docker on your compatible Synology DiskStation, click on  Image  and  Add  the Recorder image from the URL  https://hub.docker.com/r/owntracks/recorder ; you do not have to specify a username/password. Select  latest  when prompted to choose a tag.  In list of images you should then see one called  owntracks/recorder:latest  as shown below.   Then, click on  Launch  in the same window, select a container name (or leave it as  owntracks-recorder1 ) and click on  Advanced Settings .   Under  Volume , add a folder. Select a folder you created and have reserved for the recorder, and associate (mount) that folder onto the  /store  mount path.  Under  Port Settings , ensure  Local Port   8083  is mapped to  Container Port   8083 ; you will have to replace  Auto  by  8083 .  Under  Environment , add two variables:  OTR_HOST  with the address or host name of your MQTT broker and  OTR_PORT  with its port number (typically  1883 ). If you need authentication, check the  Recorder documentation  for further variables you can set to configure that.   Just before running the container, you should see something like this with the settings you specified:   When you launch the container, it will show up in the  Container  tab:   You should then be able to access the Recorder's Web interface at the address of your Synology DiskStation and the port 8083 you specified above.   Upgrades to the container running on your Synology DiskStation are easily done from the command line:  $ docker stop owntracks-recorder1\n$ docker pull owntracks/recorder:latest\n$ docker start owntracks-recorder1", 
            "title": "Recorder"
        }, 
        {
            "location": "/privacy/", 
            "text": "It's your data!\n\n\nYour data should be yours. OwnTracks does all it can to ensure that,\nand you decide where you store your data, how to process it, and for\nhow long you store it (if at all).\n\n\nHowever, be advised, that if you're very concerned about privacy,\nyou probably shouldn't be using a smartphone at all. OwnTracks uses\nyour smartphone's location services to determine where it is. While\nyou decide whether you want to enable or disable this feature (check\nyour phone's documentation), there is no guarantee that the APIs used\nby OwnTracks won't submit your data to the vendor's servers.\n\n\nFor example, it's quite possible that Apple or Google keep requests\nused for reverse geo-coding your location; there is pretty much\nnothing OwnTracks can do to avoid this.\n\n\nAs one of the developers writes:\n\n\n\n\nWe could, with great sacrifices to code complexity, battery efficiency and\nperformance code around all native services offered by the platform in order\nto use third party maps and geo coders. In that case Google might not receive\nyour geocoder requests but another third party that sells it. We could also\nwork around the Play Services by handling all the location acquiring the old\nway by querying the GPS/WIFI/Cell positioning ourselves.  I however doubt\nthat these information isn't sent to Google in that case too. The thing is,\nif you don't want Google or Apple to collect your position you have to\ndisable location services in which case you don't have to bother installing\nthe app anyway.\n\n\n\n\nIt's your choice.\n\n\nPrivacy Policy\n\n\nWebsite Visitors\n\n\nLike most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website.\n\n\nOwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below.\n\n\nGathering of Personally-Identifying Information\n\n\nCertain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in\nways that require OwnTracks to gather personally-identifying information. The\namount and type of information that OwnTracks gathers depends on the nature of\nthe interaction. Those who engage in\ntransactions with OwnTracks\nare asked to provide additional information,\nincluding as necessary the personal and financial information required to\nprocess those transactions. In each case, OwnTracks collects such information\nonly insofar as is necessary or appropriate to fulfill the purpose of the\nvisitor\u2019s interaction with OwnTracks. OwnTracks does not disclose\npersonally-identifying information other than as described below. And visitors\ncan always refuse to supply personally-identifying information, with the caveat\nthat it may prevent them from engaging in certain website-related activities.\n\n\nOwnTracks collects personally-identifying information in the form of location\nreports made by OwnTracks' apps which use OwnTracks servers. This information\nmay be stored in order to make it available to OwnTracks' users.\n\n\nAggregated Statistics\n\n\nOwnTracks may collect statistics about the behavior of visitors to its\nwebsites. \nOwnTracks may display this information publicly or provide it to others.\nHowever, OwnTracks does not disclose personally-identifying information other\nthan as described below.\n\n\nProtection of Certain Personally-Identifying Information\n\n\nOwnTracks discloses potentially personally-identifying and\npersonally-identifying information only to those of its employees, contractors\nand affiliated organizations that (i) need to know that information in order to\nprocess it on OwnTracks\u2019s behalf or to provide services available at\nOwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others.\nSome of those employees, contractors and affiliated organizations may be\nlocated outside of your home country; by using OwnTracks\u2019s websites and servers, you\nconsent to the transfer of such information to them. OwnTracks will not rent or\nsell potentially personally-identifying and personally-identifying information\nto anyone. Other than to its employees, contractors and affiliated\norganizations, as described above, OwnTracks discloses potentially\npersonally-identifying and personally-identifying information only in response\nto a subpoena, court order or other governmental request, or when OwnTracks\nbelieves in good faith that disclosure is reasonably necessary to protect the\nproperty or rights of OwnTracks, third parties or the public at large. If you\nare a registered user of an OwnTracks website or service and have supplied your email\naddress, OwnTracks may occasionally send you an email to tell you about new\nfeatures, solicit your feedback, or just keep you up to date with what\u2019s going\non with OwnTracks and our products. We primarily use our various product blogs\nto communicate this type of information, so we expect to keep this type of\nemail to a minimum. If you send us a request (for example via a support email\nor via one of our feedback mechanisms), we reserve the right to publish it in\norder to help us clarify or respond to your request or to help us support other\nusers. OwnTracks takes all measures reasonably necessary to protect against the\nunauthorized access, use, alteration or destruction of potentially\npersonally-identifying and personally-identifying information.\n\n\nCookies\n\n\nA cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies.\n\n\nBusiness Transfers\n\n\nIf OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy.\n\n\nAds\n\n\nAds appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers.\n\n\nPrivacy Policy Changes\n\n\nAlthough most changes are likely to be minor, OwnTracks may change its Privacy\nPolicy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks\nencourages visitors to frequently check this page for any changes to its\nPrivacy Policy. Your continued use of this site\nafter any change in this Privacy Policy will constitute your acceptance of such\nchange.\n\n\nThis privacy policy was adapted from \nAutomattic's Privacy Policy\n.", 
            "title": "Privacy"
        }, 
        {
            "location": "/privacy/#privacy-policy", 
            "text": "Website Visitors  Like most website operators, OwnTracks collects non-personally-identifying information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. OwnTracks' purpose in collecting non-personally identifying information is to better understand how OwnTracks' visitors use its website. From time to time, OwnTracks may release non-personally-identifying information in the aggregate, e.g., by publishing a report on trends in the usage of its website.  OwnTracks also collects potentially personally-identifying information like Internet Protocol (IP) addresses for logged in users and for users leaving comments on OwnTracks' Web sites. OwnTracks only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses personally-identifying information as described below.  Gathering of Personally-Identifying Information  Certain visitors to OwnTracks' websites and servers choose to interact with OwnTracks in\nways that require OwnTracks to gather personally-identifying information. The\namount and type of information that OwnTracks gathers depends on the nature of\nthe interaction. Those who engage in\ntransactions with OwnTracks\nare asked to provide additional information,\nincluding as necessary the personal and financial information required to\nprocess those transactions. In each case, OwnTracks collects such information\nonly insofar as is necessary or appropriate to fulfill the purpose of the\nvisitor\u2019s interaction with OwnTracks. OwnTracks does not disclose\npersonally-identifying information other than as described below. And visitors\ncan always refuse to supply personally-identifying information, with the caveat\nthat it may prevent them from engaging in certain website-related activities.  OwnTracks collects personally-identifying information in the form of location\nreports made by OwnTracks' apps which use OwnTracks servers. This information\nmay be stored in order to make it available to OwnTracks' users.  Aggregated Statistics  OwnTracks may collect statistics about the behavior of visitors to its\nwebsites. \nOwnTracks may display this information publicly or provide it to others.\nHowever, OwnTracks does not disclose personally-identifying information other\nthan as described below.  Protection of Certain Personally-Identifying Information  OwnTracks discloses potentially personally-identifying and\npersonally-identifying information only to those of its employees, contractors\nand affiliated organizations that (i) need to know that information in order to\nprocess it on OwnTracks\u2019s behalf or to provide services available at\nOwnTracks\u2019s websites, and (ii) that have agreed not to disclose it to others.\nSome of those employees, contractors and affiliated organizations may be\nlocated outside of your home country; by using OwnTracks\u2019s websites and servers, you\nconsent to the transfer of such information to them. OwnTracks will not rent or\nsell potentially personally-identifying and personally-identifying information\nto anyone. Other than to its employees, contractors and affiliated\norganizations, as described above, OwnTracks discloses potentially\npersonally-identifying and personally-identifying information only in response\nto a subpoena, court order or other governmental request, or when OwnTracks\nbelieves in good faith that disclosure is reasonably necessary to protect the\nproperty or rights of OwnTracks, third parties or the public at large. If you\nare a registered user of an OwnTracks website or service and have supplied your email\naddress, OwnTracks may occasionally send you an email to tell you about new\nfeatures, solicit your feedback, or just keep you up to date with what\u2019s going\non with OwnTracks and our products. We primarily use our various product blogs\nto communicate this type of information, so we expect to keep this type of\nemail to a minimum. If you send us a request (for example via a support email\nor via one of our feedback mechanisms), we reserve the right to publish it in\norder to help us clarify or respond to your request or to help us support other\nusers. OwnTracks takes all measures reasonably necessary to protect against the\nunauthorized access, use, alteration or destruction of potentially\npersonally-identifying and personally-identifying information.  Cookies  A cookie is a string of information that a website stores on a visitor\u2019s computer, and that the visitor\u2019s browser provides to the website each time the visitor returns. OwnTracks uses cookies to help OwnTracks identify and track visitors, their usage of OwnTracks website, and their website access preferences. OwnTracks visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using OwnTracks\u2019s websites, with the drawback that certain features of OwnTracks\u2019s websites may not function properly without the aid of cookies.  Business Transfers  If OwnTracks, or substantially all of its assets, were acquired, or in the unlikely event that OwnTracks goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of OwnTracks may continue to use your personal information as set forth in this policy.  Ads  Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by OwnTracks and does not cover the use of cookies by any advertisers.  Privacy Policy Changes  Although most changes are likely to be minor, OwnTracks may change its Privacy\nPolicy from time to time, and in OwnTracks\u2019s sole discretion. OwnTracks\nencourages visitors to frequently check this page for any changes to its\nPrivacy Policy. Your continued use of this site\nafter any change in this Privacy Policy will constitute your acceptance of such\nchange.  This privacy policy was adapted from  Automattic's Privacy Policy .", 
            "title": "Privacy Policy"
        }, 
        {
            "location": "/people/", 
            "text": "People\n\n\nAlexander Rust\n created the first proof-of-concept for the Android app which started out under the very geeky name \nMQTTitude\n, a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013.\n\n\nOnly a few days later, \nChristoph Krey\n implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out.\n\n\nJan-Piet Mens\n had the \noriginal crazy idea of combining location updates and MQTT\n and tries to keep abreast on what Christoph and Alexander do. As \nBen\n once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles.\n\n\nIncidentally, \nBen Jones\n, who works closely with us, has given us loads of invaluable feedback and he's the chap who created the \nmqttitude binding\n for the wonderful \nopenHAB\n Home Automation project.\n\n\nContributors\n\n\nMany good people have assisted us, be it by testing, by contributing bits of code or documentation, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-)\n\n\n\n\nBrad Pillatsch\n wrote the initial implementation of PKCS#12 import for Android.\n\n\nbrunkj\n for help in tracking down an address book crash.\n\n\nMatthew Bordignon\n for ideas and help with testing.\n\n\nStefano Costa\n for bug reports.\n\n\nMark Clark\n for bug reports.\n\n\nAdrian Brown originally suggested the \nidea for location-based services\n\n\nfriesenkiwi\n contributed sundry large patches to Android and drove the LOST integration.\n\n\nMikael Berthe\n initiated the idea for the \n_cp\n attribute (which we removed in May 2018).", 
            "title": "People"
        }, 
        {
            "location": "/people/#people", 
            "text": "Alexander Rust  created the first proof-of-concept for the Android app which started out under the very geeky name  MQTTitude , a term coined from our use of MQTT and the then obsolete Latitude app, which Google took out of service in 2013.  Only a few days later,  Christoph Krey  implemented a rough prototype on iOS, and didn't stop implementing new and exciting features on the iOS version of OwnTracks until his coffee machine burned out.  Jan-Piet Mens  had the  original crazy idea of combining location updates and MQTT  and tries to keep abreast on what Christoph and Alexander do. As  Ben  once said: \"JP just sits back and cracks the whips\". So these three could be called the \"core team\", if we were in the market for cool-sounding titles.  Incidentally,  Ben Jones , who works closely with us, has given us loads of invaluable feedback and he's the chap who created the  mqttitude binding  for the wonderful  openHAB  Home Automation project.", 
            "title": "People"
        }, 
        {
            "location": "/people/#contributors", 
            "text": "Many good people have assisted us, be it by testing, by contributing bits of code or documentation, or just by complaining loudly, and we want to acknowledge the following contributions. (If you think your name should be on this list, tell us, or forever hold your peace. :-)   Brad Pillatsch  wrote the initial implementation of PKCS#12 import for Android.  brunkj  for help in tracking down an address book crash.  Matthew Bordignon  for ideas and help with testing.  Stefano Costa  for bug reports.  Mark Clark  for bug reports.  Adrian Brown originally suggested the  idea for location-based services  friesenkiwi  contributed sundry large patches to Android and drove the LOST integration.  Mikael Berthe  initiated the idea for the  _cp  attribute (which we removed in May 2018).", 
            "title": "Contributors"
        }, 
        {
            "location": "/ideas/", 
            "text": "Ideas\n\n\nOver the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already.\n\n\n\n\nAllow KML, GPX export. This we do enable in the back-end.\n\n\nPublish \ncharging\n alongside battery level. No.\n\n\nAdd temperature to the JSON payload. No.\n\n\nHave the device track a route; we do this in the back-end.\n\n\n\n\nShort term\n\n\nMid-term\n\n\nLong-term\n\n\n\n\nAdd presence. Are my friends in the area?\n\n\nNeeds friends/family on same broker\n\n\nNeeds 'standardized' topic names (maybe with Twitter id in topic?)\n\n\nAdd transportation info (e.g. trains) as friends\n\n\nQueue updates on device (with \ntst\n etc) to be PUBlished upon available connection\n\n\nNFC support, \nsuggested by mrizvic\n\n\n\n\nVery-long term, a.k.a. \"Neat ideas\"\n\n\n\n\nPublish incoming phone call (caller-id), \nsubmitted by @bordingnon\n. JPM: Also SMS? Have to force TLS then, at least.\n\n\nRequested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\"\n\n\nGeneralized messaging app \n\n\nIndoors edition with iBeacons as requested in \n#296\n\n\n\n\nWaypoints\n\n\nJPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload: \n{ \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\"\ncurrent\n\", \"lon\":\ncurrent\n\", \"text\":\"utf-8 text\" }\n\n\nRemote control\n\n\n\n\nMaybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139)\n\n\nInteresting idea in \n#227\n: device can change mode (e.g. \nsilent\n, \nairplane mode\n, etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes.\n\n\nAdd remote-control for setting waypoints via MQTT", 
            "title": "Ideas"
        }, 
        {
            "location": "/ideas/#ideas", 
            "text": "Over the course of time, we've had people propose a number of ideas for OwnTracks. Some of these we thought excellent, others we thought would maybe sometime be nice to have, and others, well, see for yourself. Be that as it may, this page lists a few of these in the hope that you'll see we know of them and if you dream up something new, that you'll first check wether we've heard of it already.   Allow KML, GPX export. This we do enable in the back-end.  Publish  charging  alongside battery level. No.  Add temperature to the JSON payload. No.  Have the device track a route; we do this in the back-end.", 
            "title": "Ideas"
        }, 
        {
            "location": "/ideas/#short-term", 
            "text": "", 
            "title": "Short term"
        }, 
        {
            "location": "/ideas/#mid-term", 
            "text": "", 
            "title": "Mid-term"
        }, 
        {
            "location": "/ideas/#long-term", 
            "text": "Add presence. Are my friends in the area?  Needs friends/family on same broker  Needs 'standardized' topic names (maybe with Twitter id in topic?)  Add transportation info (e.g. trains) as friends  Queue updates on device (with  tst  etc) to be PUBlished upon available connection  NFC support,  suggested by mrizvic", 
            "title": "Long-term"
        }, 
        {
            "location": "/ideas/#very-long-term-aka-neat-ideas", 
            "text": "Publish incoming phone call (caller-id),  submitted by @bordingnon . JPM: Also SMS? Have to force TLS then, at least.  Requested in #86: \"app should register a subscriprion (configurable topic) a) if someone sends a text message it should be displayed as popup window b) if someone sends an HTML message it should be opened in a embedded browser\"  Generalized messaging app   Indoors edition with iBeacons as requested in  #296   Waypoints  JPM added 2013-11-22: We currently have \"Annotations\" on iOS (see above). I'd like to be able to have an annotation PUBlished to the broker so that m2s (or other processors) can pick it up. I propose the following payload:  { \"_type\": \"_waypoint\", \"tst\":\"xx\", \"lat\":\" current \", \"lon\": current \", \"text\":\"utf-8 text\" }  Remote control   Maybe add remote-control for enabling \"move-mode\" on iOS (https://github.com/binarybucks/mqttitude/issues/139)  Interesting idea in  #227 : device can change mode (e.g.  silent ,  airplane mode , etc.) depending on location and by listening to a remote-control topic with which it is instructed to switch modes.  Add remote-control for setting waypoints via MQTT", 
            "title": "Very-long term, a.k.a. \"Neat ideas\""
        }, 
        {
            "location": "/faq/", 
            "text": "Answers\n\n\nThis is a list of question we really get asked a lot and some answers to these questions.\n\n\nQ: Can I have OwnTracks not publish location for a specific period of time?\n\nA: Set mode to manual (iOS) or disable automatic location reporting (Android)\n\n\nQ: How can I restart OwnTracks?\n\nA: Swip away and start (iOS), Force close and start (Android)\n\n\nQ: Can you remove Google Play Services from the Android app? \n\nA: No\n\n\nQ: Can you remove Google Maps from the Android app? \n\nA: No\n\n\nQ: Since updating to Android 6 (or higher), background location reporting does not work as before\n\nA: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. \nYour best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection. \n\n\nQ: I've moved, but OwnTracks is not reporting my location\n\nA: Depending on the mode the apps report location changes only after significant changes. \n\n\nQ: How do I enable region monitoring? (Waypoints)\n\n\nQ: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that.\n\n\nQ: Why are transition events delayed?\n\n\nQ: How can I increase reporting frequency and does that have any negative impact?\n\n\nA: I have a question\n\nA: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the \nOwnTracks meta tracker\n.\n\n\nQ: How can I report an issue?\n\nA: If you think you've found a bug, please report it on our respective \nandroid\n or \nios\n issue tracker on Github.", 
            "title": "Answers"
        }, 
        {
            "location": "/faq/#answers", 
            "text": "This is a list of question we really get asked a lot and some answers to these questions.  Q: Can I have OwnTracks not publish location for a specific period of time? \nA: Set mode to manual (iOS) or disable automatic location reporting (Android)  Q: How can I restart OwnTracks? \nA: Swip away and start (iOS), Force close and start (Android)  Q: Can you remove Google Play Services from the Android app?  \nA: No  Q: Can you remove Google Maps from the Android app?  \nA: No  Q: Since updating to Android 6 (or higher), background location reporting does not work as before \nA: Since Android 6 Google has startet to restrict background apps. We're doing our best to work agains this were we can. \nYour best bet is to enable the ongoing notifications which enables some background features. HTTP mode works best in the background because it can rely on the OS background scheduling in contrast to MQTT mode which requires a persistent TCP connection.   Q: I've moved, but OwnTracks is not reporting my location \nA: Depending on the mode the apps report location changes only after significant changes.   Q: How do I enable region monitoring? (Waypoints)  Q: I'm sure I've moved into (or out of) a region, but OwnTracks isn't reporting that.  Q: Why are transition events delayed?  Q: How can I increase reporting frequency and does that have any negative impact?  A: I have a question \nA: We love questions. Well, sometimes. If you want to ask us a question or desire feedback from other OwnTracks users, visit us at the  OwnTracks meta tracker .  Q: How can I report an issue? \nA: If you think you've found a bug, please report it on our respective  android  or  ios  issue tracker on Github.", 
            "title": "Answers"
        }, 
        {
            "location": "/press/", 
            "text": "Press\n\n\nEnglish\n\n\n\n\nOwnTracks Poster @ eclipsecon Europe 2015\n\n\nGerman\n\n\n\n\nAnwesenheitserkennung reloaded\n\n\nownTracks \n Mosquitto \u2013 Google Latitude-Clon im Eigenbau\n\n\nLatitude im Eigenbau \u2013 volle Kontrolle\n\n\nopenHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung\n mentions OwnTracks\n\n\nopenHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts", 
            "title": "Press"
        }, 
        {
            "location": "/press/#press", 
            "text": "", 
            "title": "Press"
        }, 
        {
            "location": "/press/#english", 
            "text": "OwnTracks Poster @ eclipsecon Europe 2015", 
            "title": "English"
        }, 
        {
            "location": "/press/#german", 
            "text": "Anwesenheitserkennung reloaded  ownTracks   Mosquitto \u2013 Google Latitude-Clon im Eigenbau  Latitude im Eigenbau \u2013 volle Kontrolle  openHAB f\u00fcr mehr Datenschutz in der Heimautomatisierung  mentions OwnTracks  openHAB 1.4: Offenheit und Datenschutz im Fokus des Smart-Home-Projekts", 
            "title": "German"
        }
    ]
}